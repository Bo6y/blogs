{"meta":{"title":"Leo Angel","subtitle":null,"description":"Luckyw前端开发个人博客，汇集Html5、Css3、Jquery、NodeJs、Python、Php、AngularJs等相关内容，坚持每周一篇进行前端工作总结","author":"Leo Angel","url":"https://blog.luckyw.cn"},"pages":[{"title":"Tags","date":"2016-12-15T09:30:43.067Z","updated":"2016-09-09T08:16:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.luckyw.cn/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-12-15T09:30:43.067Z","updated":"2016-09-09T08:16:08.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.luckyw.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Chrome插件开发——本地天气","slug":"chrome-plugin-dev","date":"2016-12-30T16:00:00.000Z","updated":"2017-01-07T09:19:51.471Z","comments":true,"path":"2016/12/31/chrome-plugin-dev/","link":"","permalink":"https://blog.luckyw.cn/2016/12/31/chrome-plugin-dev/","excerpt":"经常在Chrome应用商店下载扩展程序也就是插件，有时候在想可不可以自己也开发一个插件用用呢？本文就是在这样的背景下产生的，以一个生活必需的简单获取天气的插件作为开发演示，下面就开始我们的Chrome插件开发之旅吧！源码地址: https://github.com/leoyaojy/chrome-plugin-weather.git目录结构：123456789101112├── css│ └── main.css├── imgs│ ├── icon-128.png│ ├── icon-16.png│ ├── icon-19.png│ └── icon-38.png├── js│ ├── jquery.js│ └── main.js├── manifest.json└── popup.html 效果图:","text":"经常在Chrome应用商店下载扩展程序也就是插件，有时候在想可不可以自己也开发一个插件用用呢？本文就是在这样的背景下产生的，以一个生活必需的简单获取天气的插件作为开发演示，下面就开始我们的Chrome插件开发之旅吧！源码地址: https://github.com/leoyaojy/chrome-plugin-weather.git目录结构：123456789101112├── css│ └── main.css├── imgs│ ├── icon-128.png│ ├── icon-16.png│ ├── icon-19.png│ └── icon-38.png├── js│ ├── jquery.js│ └── main.js├── manifest.json└── popup.html 效果图: manifest.json 入口文件，每个Chrome插件都必须包含一个manifest.json文件，其中必须包含name、version和manifest_version属性12345678910111213141516171819202122&#123; &quot;manifest_version&quot;: 2, &quot;version&quot;: &quot;1.0&quot;, &quot;name&quot;: &quot;weather&quot;, &quot;description&quot;: &quot;a chrome extension for local weather&quot;, &quot;icons&quot;: &#123; &quot;128&quot;: &quot;imgs/icon-128.png&quot;, &quot;16&quot;: &quot;imgs/icon-16.png&quot; &#125;, &quot;browser_action&quot;: &#123; &quot;default_icon&quot;: &#123; &quot;19&quot;: &quot;imgs/icon-19.png&quot;, &quot;38&quot;: &quot;imgs/icon-38.png&quot; &#125;, &quot;default_title&quot;: &quot;weather&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; &#125;, &quot;permissions&quot;:[ &quot;http://*/*&quot;, &quot;https://*/*&quot; ]&#125; 属性说明： manifest_version：此键指定此扩展使用的manifest.json的版本，目前必须是2 version：插件版本号 name：插件名称 description：插件描述 icons：插件图标，Chrome扩展程序页显示 browser_action：指定插件在Chrome工具栏中的显示信息 default_icon：图标 default_title：标题 default_popup：弹出页 permissions：权限注意:如果我们需要向服务器请求数据，就需要在permissions中添加请求数据的接口，否则会报跨域请求的限制。但是如果需要向多个接口请求数据，建议直接按我的方式书写匹配规则，这样不管多少接口都适用popup.html popup页面是当用户点击插件图标时，展示在图标下方的页面123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Weather&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;today&quot;&gt; &lt;h1 id=&quot;city&quot;&gt;北京&lt;/h1&gt; &lt;h3 id=&quot;updateTime&quot;&gt;09:00发布&lt;/h3&gt; &lt;div id=&quot;pic&quot;&gt; &lt;img src=&quot;./imgs/0.svg&quot; alt=&quot;&quot; /&gt; &lt;p&gt;8℃&lt;/p&gt; &lt;p&gt;晴&lt;/p&gt; &lt;/div&gt; &lt;ul id=&quot;info&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div id=&quot;future&quot;&gt; &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里我们使用了jQuery，方便对dom元素进行操作，注意我们不能直接在html里写js代码，只能通过外部引用的方式引入js文件，css也一样 main.js ajax请求接口数据并渲染到popup页面中去，这里使用的是心知天气的api接口，但是发现使用它提供的免费数据api只能获取最多三天的天气预报数据，而且默认提供的图标不是我想要的风格，需调用多个接口才能实现基本功能。后来发现它也有提供插件的服务，只需要简单的几行js代码就可以实现酷炫天气效果，在控制台Network分析面板提取了它的api接口，可获取近五天的天气情况，一个接口就可以很方便地实现所需要的功能，我这里代码使用了ES6模板字符串，减少了对字符串拼接的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var week = [&apos;周日&apos;,&apos;周一&apos;,&apos;周二&apos;,&apos;周三&apos;,&apos;周四&apos;,&apos;周五&apos;,&apos;周六&apos;],api=&quot;http://widget.thinkpage.cn/api/weather?flavor=bubble&amp;location=WX4FBXXFKE4F&amp;geolocation=enabled&amp;position=top-right&amp;margin=0px%200px&amp;language=zh-chs&amp;unit=c&amp;theme=chameleon&amp;uid=U3816AF56B&amp;hash=aa5b2d23df45bcc88f28908ecf64e0a5&quot;;$.ajax(&#123; url:api, type:&quot;GET&quot;, success:function(d)&#123; var w = d.weather, city = w.location.name, air = w.air.city, now = w.now, daily = w.daily, text = now.text, code = now.code, temperature = now.temperature, humidity = now.humidity, wind_direction = now.wind_direction, wind_scale = now.wind_scale, last_update = now.last_update, hour = new Date(last_update).getHours()&gt;=10?new Date(last_update).getHours():&quot;0&quot;+new Date(last_update).getHours(), minutes = new Date(last_update).getMinutes()&gt;=10?new Date(last_update).getMinutes():&quot;0&quot;+new Date(last_update).getMinutes(), aqi = air.aqi, quality = air.quality; $(daily).each(function(index, el) &#123; var date = new Date(this.date), i = date.getDay(), month = date.getMonth()+1, today = date.getDate(); var day = index === 0?&quot;今天&quot;:(index===1?&quot;明天&quot;:week[i]); $(&quot;#list&quot;).append(` &lt;li&gt; &lt;div class=&quot;date&quot;&gt; $&#123;day&#125; $&#123;month&#125;/$&#123;today&#125; &lt;/div&gt; &lt;div class=&quot;weather&quot;&gt; &lt;img src=&quot;./imgs/$&#123;this.code_day&#125;.svg&quot; alt=&quot;&quot;&gt; &lt;span&gt;$&#123;this.text_day&#125;/$&#123;this.text_night&#125;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;tempRange&quot;&gt; $&#123;this.low&#125;/$&#123;this.high&#125;℃ &lt;/div&gt; &lt;/li&gt; `); &#125;); $(&quot;#city&quot;).text(city); $(&quot;#updateTime&quot;).text(hour+&quot;:&quot;+minutes+&quot;发布&quot;); $(&quot;#pic&quot;).find(&quot;img&quot;).attr(&quot;src&quot;,&quot;./imgs/&quot;+code+&quot;.svg&quot;).end().find(&apos;p&apos;).first().text(temperature+&quot;℃&quot;).next().text(text); $(&quot;#info&quot;).html(` &lt;li&gt;$&#123;wind_direction&#125;风&lt;p&gt;$&#123;wind_scale&#125;级&lt;/p&gt;&lt;/li&gt; &lt;li&gt;空气$&#123;quality&#125;&lt;p&gt;$&#123;aqi&#125;&lt;/p&gt;&lt;/li&gt; &lt;li&gt;相对湿度&lt;p&gt;$&#123;humidity&#125;&lt;/p&gt;&lt;/li&gt; `); &#125;&#125;); 最后，祝大家新年快乐，2017和你一起~~~","categories":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/categories/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/tags/Chrome/"}],"keywords":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/categories/Chrome/"}]},{"title":"GD库生成图片验证码","slug":"php-gd-captcha","date":"2016-12-24T16:00:00.000Z","updated":"2017-01-04T11:09:33.101Z","comments":true,"path":"2016/12/25/php-gd-captcha/","link":"","permalink":"https://blog.luckyw.cn/2016/12/25/php-gd-captcha/","excerpt":"对于验证码，我们并不陌生，随处可见，比如:登录注册、论坛灌水、刷票、密码破解等，主要作用是屏蔽机器请求，保障业务不受机器提交请求干扰下面就来写一个验证码demo，使用最常见的字母加数字验证码，加上干扰点和干扰线，使用的GD库生成的，如果你没有安装的话，请自行谷歌安装，另如何判断是否安装启用，请直接在phpinfo页面搜GD库即可效果如下图:","text":"对于验证码，我们并不陌生，随处可见，比如:登录注册、论坛灌水、刷票、密码破解等，主要作用是屏蔽机器请求，保障业务不受机器提交请求干扰下面就来写一个验证码demo，使用最常见的字母加数字验证码，加上干扰点和干扰线，使用的GD库生成的，如果你没有安装的话，请自行谷歌安装，另如何判断是否安装启用，请直接在phpinfo页面搜GD库即可效果如下图: 前台页面 demo.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpif(isset($_REQUEST[&quot;code&quot;]))&#123; session_start(); if(strtolower($_POST[&quot;code&quot;])==$_SESSION[&quot;code&quot;])&#123; echo &quot;&lt;script&gt;alert(&apos;正确！&apos;)&lt;/script&gt;&quot;; &#125;else&#123; echo &quot;&lt;script&gt;alert(&apos;错误！&apos;)&lt;/script&gt;&quot;; &#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;验证码&lt;/title&gt; &lt;style&gt; #code&#123; border: 1px solid #ccc; vertical-align: bottom; &#125; #refresh&#123; text-decoration: none; font-size: .875em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt; 验证码： &lt;img src=&quot;code.php?r=&lt;?php echo rand()?&gt;&quot; alt=&quot;&quot; id=&quot;code&quot;&gt; &lt;a href=&quot;javascript:;&quot; id=&quot;refresh&quot;&gt;看不清？&lt;/a&gt; &lt;/p&gt; &lt;p&gt; 输入验证码： &lt;input type=&quot;text&quot; name=&quot;code&quot;&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;script&gt; document.getElementById(&quot;code&quot;).onclick = document.getElementById(&quot;refresh&quot;).onclick = refresh; function refresh() &#123; document.getElementById(&apos;code&apos;).src=&apos;code.php?r=&apos;+Math.random() &#125; &lt;/script&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后台页面 code.php123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php//启动sessionsession_start();$code = &quot;&quot;; //验证码字符串$str = &quot;qwertyuiopasdfghjklzxcvbnm1234567890&quot;; //验证码字符取值范围[a-z0-9]$w = 160; //图片宽度$h = 40; //图片高度$num = 4; //验证码字符数$dotNum = 300; //干扰点个数$lineNum = rand(3, 5); //干扰线条数$font = &quot;./api/DejaVuSansMono.ttf&quot;; //设置字体文件$image = imagecreatetruecolor($w, $h); //创建一张指定宽高的图片$imageColor = imagecolorallocate($image, 255, 255, 255); //设置背景图片颜色为白色imagefill($image, 0, 0, $imageColor); //填充图片背景//随机验证码，包含字母和数字for ($i = 0; $i &lt; $num; $i++) &#123; $fontColor = imagecolorallocate($image, rand(0, 120), rand(0, 120), rand(0, 120)); //生成随机字体颜色 $content = substr($str, rand(0, strlen($str)), 1); //随机取字符集中的值 $code .= $content; $fontSize = rand(15, 25); //字体大小 $x = $i * $w / $num + rand(5, 10); //指定生成位置X轴偏移量 $y = rand(20, 30); //指定生成位置Y轴偏移量 imagettftext($image, $fontSize, 0, $x, $y, $fontColor, $font, $content);&#125;$_SESSION[&quot;code&quot;] = $code; //保存验证码字符串到session中//生成干扰点for ($i = 0; $i &lt; $dotNum; $i++) &#123; $dotColor = imagecolorallocate($image, rand(0, 255), rand(0, 255), rand(0, 255)); imagesetpixel($image, rand(0, $w), rand(0, $h), $dotColor);&#125;//生成干扰线for ($i = 0; $i &lt; $lineNum; $i++) &#123; $lineColor = imagecolorallocate($image, rand(0, 100), rand(0, 100), rand(0, 100)); imageline($image, rand(0, $w), rand(0, $h), rand(0, $w), rand(0, $h), $lineColor);&#125;header(&quot;content-type:image/png&quot;);imagepng($image);imagedestroy($image);","categories":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/categories/Php/"}],"tags":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/tags/Php/"}],"keywords":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/categories/Php/"}]},{"title":"sass入门初体验","slug":"sass-learn","date":"2016-12-17T16:00:00.000Z","updated":"2016-12-28T12:51:22.556Z","comments":true,"path":"2016/12/18/sass-learn/","link":"","permalink":"https://blog.luckyw.cn/2016/12/18/sass-learn/","excerpt":"接上文less入门初体验，接下来讲讲sass，sass有两种文件后缀名，一种是.sass，另一种是.scss。前者类似于ruby的语法规则，没有花括号，没有分号，具有严格的缩进；而后者更贴近于css的语法规则，易于阅读，更具语义性，所以本文采用.scss后缀名来编写sass代码 编译 1、Ruby:sass是由Ruby语言编写的，所以我们可以通过Ruby来编辑sass代码，首先需要安装ruby，然后再安装sass，之后通过sass命令编译文件123sudo apt install rubysudo gem install sasssass style.scss style.css sass提供四个编译风格的选项: nested：嵌套缩进的css代码，默认值expanded：没有缩进的、扩展的css代码compact：简洁格式的css代码compressed：压缩后的css代码 生产环境中一般使用最后一个1sass --style compressed style.scss style.css","text":"接上文less入门初体验，接下来讲讲sass，sass有两种文件后缀名，一种是.sass，另一种是.scss。前者类似于ruby的语法规则，没有花括号，没有分号，具有严格的缩进；而后者更贴近于css的语法规则，易于阅读，更具语义性，所以本文采用.scss后缀名来编写sass代码 编译 1、Ruby:sass是由Ruby语言编写的，所以我们可以通过Ruby来编辑sass代码，首先需要安装ruby，然后再安装sass，之后通过sass命令编译文件123sudo apt install rubysudo gem install sasssass style.scss style.css sass提供四个编译风格的选项: nested：嵌套缩进的css代码，默认值expanded：没有缩进的、扩展的css代码compact：简洁格式的css代码compressed：压缩后的css代码 生产环境中一般使用最后一个1sass --style compressed style.scss style.css 变量 变量使用以$开头(这也是我喜爱sass多于less的原因，谁不喜欢money呢？O(∩_∩)O哈哈~，开个玩笑)，如果变量需要在字符串中使用，只需要写在#{}中即可1234567$color:#999;$side:left;$bw:2px;div &#123; background-color: $color; border-#&#123;$side&#125;-width: $bw;&#125; 编译后:1234div &#123; background-color: #999; border-left-width: 2px;&#125; Mixin(混合) 实现代码块的重用，使用@mixin定义一个代码块，通过@include就可以调用此代码块1234567891011@mixin b_r($radius:5px)&#123; -webkit-border-radius:$radius; -mz-border-radius:$radius; border-radius:$radius;&#125;div1&#123; @include b_r();&#125;div2&#123; @include b_r(10px);&#125; 编译后:1234567891011div1 &#123; -webkit-border-radius: 5px; -mz-border-radius: 5px; border-radius: 5px;&#125;div2 &#123; -webkit-border-radius: 10px; -mz-border-radius: 10px; border-radius: 10px;&#125; 嵌套 与less类似，不多介绍123456789div &#123; background-color: #333; a &#123; text-decoration: none; &amp;:hover &#123; color: red; &#125; &#125;&#125; 编译后:123456789div &#123; background-color: #333;&#125;div a &#123; text-decoration: none;&#125;div a:hover &#123; color: red;&#125; 运算 与less类似，不多介绍1234567$w:1000px;body &#123; width: $w/2; div &#123; height: 100px*5; &#125;&#125; 编译后:123456body &#123; width: 500px;&#125;body div &#123; height: 500px;&#125; 颜色函数 1234div &#123; color: lighten(#ccc, 10%); background-color: darken(#999, 10%);&#125; 编译后:1234div &#123; color: #e6e6e6; background-color: gray;&#125; 注释 1234567891011121314/* Hello Sass 我依然在这里 */div1 &#123; color: red;&#125;// Hello Sass 我不见了div2 &#123; color: green;&#125;/*! Hello Sass 即使压缩了，我依然还在 */div3 &#123; color: blue;&#125; 编译后:1234567891011121314@charset &quot;UTF-8&quot;;/* Hello Sass 我依然在这里 */div1 &#123; color: red;&#125;div2 &#123; color: green;&#125;/*! Hello Sass 即使压缩了，我依然还在 */div3 &#123; color: blue;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"less入门初体验","slug":"less-learn","date":"2016-12-10T16:00:00.000Z","updated":"2016-12-28T12:50:15.887Z","comments":true,"path":"2016/12/11/less-learn/","link":"","permalink":"https://blog.luckyw.cn/2016/12/11/less-learn/","excerpt":"css有众多的预处理器，其中比较流行的三个是less、sass、stylus，本文就一起来体验less编写css代码官方文档:http://lesscss.org/官网栗子:1234567891011121314@base: #f938ab;.box-shadow(@style, @c) when (iscolor(@c)) &#123; -webkit-box-shadow: @style @c; box-shadow: @style @c;&#125;.box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) &#123; .box-shadow(@style, rgba(0, 0, 0, @alpha));&#125;.box &#123; color: saturate(@base, 5%); border-color: lighten(@base, 30%); div &#123; .box-shadow(0 0 5px, 30%) &#125;&#125; 编译成css文件:12345678.box &#123; color: #fe33ac; border-color: #fdcdea;&#125;.box div &#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);&#125;","text":"css有众多的预处理器，其中比较流行的三个是less、sass、stylus，本文就一起来体验less编写css代码官方文档:http://lesscss.org/官网栗子:1234567891011121314@base: #f938ab;.box-shadow(@style, @c) when (iscolor(@c)) &#123; -webkit-box-shadow: @style @c; box-shadow: @style @c;&#125;.box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) &#123; .box-shadow(@style, rgba(0, 0, 0, @alpha));&#125;.box &#123; color: saturate(@base, 5%); border-color: lighten(@base, 30%); div &#123; .box-shadow(0 0 5px, 30%) &#125;&#125; 编译成css文件:12345678.box &#123; color: #fe33ac; border-color: #fdcdea;&#125;.box div &#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);&#125; 编译 1、客户端(浏览器)通过在源代码中引入less.js文件，用于实时对.less样式表文件进行编译(并不推荐)注意:你的less样式文件一定要在引入less.js前先引入，并且需要设置rel属性值为stylesheet/less12&lt;link rel=&quot;stylesheet/less&quot; href=&quot;style.less&quot;&gt;&lt;script src=&quot;less.js&quot;&gt;&lt;/script&gt; 2、NodeJs需要在全局安装less模块，然后借助lessc命令把less文件编译成css文件12sudo npm install -g lesslessc style.less style.css 3、Koala推荐的是国人自主开发的实时编译软件Koala，不仅支持多种css预处理器，而且也可以跨平台运行，从而帮助web开发者更高效地进行开发 变量 变量是个好东西，允许我们单独定义一系列通用的样式，然后在需要的时候去调用，了解css中如何定义变量可查看张大神的小tips:了解CSS/CSS3原生变量var1234567@color: #999;body &#123; background-color: @color;&#125;h2 &#123; color: @color;&#125; 编译后:123456body &#123; background-color: #999;&#125;h2 &#123; color: #999;&#125; Mixin(混合) 将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有样式1234567891011.br (@radius: 5px) &#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius;&#125;#logo &#123; .br;&#125;#avatar &#123; .br(50%);&#125; 编译后:12345678910#logo &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125;#avatar &#123; -webkit-border-radius: 50%; -moz-border-radius: 50%; border-radius: 50%;&#125; 嵌套 在一个选择器中嵌套另一个选择器来实现继承，从而减少代码量1234567891011121314151617ul&#123; background-color: #666; padding: 10px; list-style: none; li&#123; background-color: #fff; border-radius: 5px; margin: 10px 0; &#125; a&#123; text-decoration:none; &amp;:hover&#123; color:red; &#125; &#125;&#125; 编译后:12345678910111213141516ul &#123; background-color: #666; padding: 10px; list-style: none;&#125;ul li &#123; background-color: #fff; border-radius: 5px; margin: 10px 0;&#125;ul a &#123; text-decoration: none;&#125;ul a:hover &#123; color: red;&#125; 运算 我们可以在less中进行加减乘除运算12345678@bdw: 5px;@bgc: #333;@tc: #030405;body&#123; border-width: @bdw + 10; background-color: @bgc * 2; color: @tc + #336699;&#125; 编译后:12345body &#123; border-width: 15px; background-color: #666666; color: #366a9e;&#125; 函数 less提供了一系列的颜色运算函数1234567891011121314151617181920@c1: #369;@c2: #963;.test1&#123; background-color:lighten(@c1,10%); color:darken(@c1,10%);&#125;.test2&#123; background-color:saturate(@c1,10%); color:desaturate(@c1,10%);&#125;.test2&#123; background-color:fadein(@c1,10%); color:fadeout(@c1,10%); border-color:fade(@c1,50%);&#125;.test4&#123; background-color:spin(@c1,10); color:spin(@c1,-10); border-color:mix(@c1,@c2);&#125; 编译后:123456789101112131415161718.test1 &#123; background-color: #407fbf; color: #264c73;&#125;.test2 &#123; background-color: #2966a3; color: #3d668f;&#125;.test2 &#123; background-color: #336699; color: rgba(51, 102, 153, 0.9); border-color: rgba(51, 102, 153, 0.5);&#125;.test4 &#123; background-color: #335599; color: #337799; border-color: #666666;&#125; 注释 12345注意:两种注释的区别/* Hello Less(我依然在这里) */.comment-show &#123; color: black &#125;// Hello Less(你看不到我了).comment-hide &#123; color: white &#125; 编译后:1234567/* Hello Less(我依然在这里) */.comment-show &#123; color: black;&#125;.comment-hide &#123; color: white;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"Linux下有趣的命令","slug":"linux-funny-cmd","date":"2016-12-03T16:00:00.000Z","updated":"2017-01-04T11:08:11.980Z","comments":true,"path":"2016/12/04/linux-funny-cmd/","link":"","permalink":"https://blog.luckyw.cn/2016/12/04/linux-funny-cmd/","excerpt":"之前介绍过linux常用命令一文，接下来我们来一起学习一下linux里好玩的命令 screenfetch:显示系统、主题信息 安装使用:12sudo apt install screenfetchscreenfetch 效果图:","text":"之前介绍过linux常用命令一文，接下来我们来一起学习一下linux里好玩的命令 screenfetch:显示系统、主题信息 安装使用:12sudo apt install screenfetchscreenfetch 效果图: linux_logo:linux版本logo图片及系统信息 安装使用:12sudo apt install linuxlogolinux_logo 效果图:查看内置的logo列表:12345678910111213141516171819202122232425262728293031323334353637linux_logo -f -L listAvailable Built-in Logos: Num Type Ascii Name Description 1 Classic Yes aix AIX Logo 2 Classic Yes bsd FreeBSD Logo 3 Banner Yes bsd_banner FreeBSD Logo 4 Classic Yes irix Irix Logo 5 Classic Yes openbsd OpenBSD Logo 6 Banner Yes openbsd_banner OpenBSD Logo 7 Banner Yes solaris The Default Banner Logos 8 Banner Yes banner-simp Simplified Banner Logo 9 Banner Yes banner The Default Banner Logo 10 Classic Yes classic-nodots The Classic Logo, No Periods 11 Classic Yes classic-simp Classic No Dots Or Letters 12 Classic Yes classic The Default Classic Logo 13 Classic Yes core Core Linux Logo 14 Banner Yes debian_banner_2 Debian Banner 2 15 Banner Yes debian_banner Debian Banner (white) 16 Classic Yes debian_old Debian Old Penguin Logos 17 Classic Yes debian Debian Swirl Logos 18 Classic Yes gnu_linux Classic GNU/Linux 19 Banner Yes mandrake_banner Mandrake(TM) Linux Banner 20 Banner Yes mandrake Mandrakelinux(TM) Banner 21 Banner Yes mandriva Mandriva(TM) Linux Banner 22 Banner Yes pld PLD Linux banner 23 Classic Yes raspi An ASCII Raspberry Pi logo 24 Banner Yes redhat RedHat Banner (white) 25 Banner Yes slackware Slackware Logo 26 Banner Yes sme SME Server Banner Logo 27 Banner Yes sourcemage_ban Source Mage GNU/Linux banner 28 Banner Yes sourcemage Source Mage GNU/Linux large 29 Banner Yes suse SUSE Logo 30 Banner Yes ubuntu Ubuntu LogoDo &quot;linux_logo -L num&quot; where num is from above to get the appropriate logo.Remember to also use -a to get ascii version. 接下来我们开始利用命令在终端循环打印logo:1for i in &#123;1..30&#125;;do linux_logo -f -L $i;sleep 2;done 效果图如下: sl:蒸汽火车 安装使用:12sudo apt install slsl ls命令用于查看文件夹的内容，而ls如果反着写的话，sl就会输出一台嘟嘟嘟的火车，如下图所示:注:当敲入LS时，此命令也会运行 fortune:幽默 安装使用:12sudo apt install fortunefortune 效果图:当然这都是英文的，如果需要它输出中国的唐诗三百首，则:12sudo apt install fortune-zhfortune-zh 效果图:注:此时再敲入fortune回车，输出的内容包括中、英文 cowsay:会说话的小牛 安装使用:12sudo apt install cowsaycowsay 效果图:接下来结合fortune和cowsay让小牛说唐诗:注:|是管道命令符，将一个命令的输出作为下一个命令的输入，经常用在脚本和程序编写中和此命令类似的还有xcowsay以及cowthink，在此不作详细说明了 toilet 安装使用:12sudo apt install toilettoilet 效果图: cmatrix:黑客帝国 安装使用:12sudo apt install cmatrixcmatrix 效果图: aafire:火焰 安装使用:12sudo apt install aafireaafire 效果图:","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/categories/Linux/"}]},{"title":"JS阻止事件冒泡以及浏览器默认行为","slug":"js-stop-prevent","date":"2016-11-26T16:00:00.000Z","updated":"2016-12-03T05:25:21.854Z","comments":true,"path":"2016/11/27/js-stop-prevent/","link":"","permalink":"https://blog.luckyw.cn/2016/11/27/js-stop-prevent/","excerpt":"e的兼容 123function fn(e)&#123; var event = e || window.event;&#125; FireFox里的Event跟IE里的不同，IE里的是全局变量，随时可用。FireFox里的要用参数引导才能用，是运行时的临时变量在IE/Opera中是window.event，在FireFox中是event。而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用 阻止事件冒泡 W3C的方法是e.stopPropagation()，IE则是使用e.cancelBubble = truestopPropagation是事件对象Event的一个方法，作用是阻止目标元素的冒泡事件，但是不会阻止默认行为什么是冒泡事件？如在一个按钮是绑定一个click事件，那么click事件会依次在它的父级元素中被触发，stopPropagation就是阻止目标元素的事件冒泡到父级元素了解更多请点这:理解DOM中的事件流","text":"e的兼容 123function fn(e)&#123; var event = e || window.event;&#125; FireFox里的Event跟IE里的不同，IE里的是全局变量，随时可用。FireFox里的要用参数引导才能用，是运行时的临时变量在IE/Opera中是window.event，在FireFox中是event。而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用 阻止事件冒泡 W3C的方法是e.stopPropagation()，IE则是使用e.cancelBubble = truestopPropagation是事件对象Event的一个方法，作用是阻止目标元素的冒泡事件，但是不会阻止默认行为什么是冒泡事件？如在一个按钮是绑定一个click事件，那么click事件会依次在它的父级元素中被触发，stopPropagation就是阻止目标元素的事件冒泡到父级元素了解更多请点这:理解DOM中的事件流阻止事件冒泡兼容:12345678function stopPropagation(e) &#123; var e = e || window.event; if ( e &amp;&amp; e.stopPropagation )&#123; e.stopPropagation(); &#125;else&#123; e.cancelBubble = true; &#125;&#125; 阻止浏览器默认行为 W3C的方法是e.preventDefault()，IE则是使用e.returnValue = falsepreventDefault是事件对象Event的一个方法，作用是取消一个目标元素的默认行为。如果元素没有默认行为，调用无效。什么元素有默认行为呢？如链接&lt;a href=&quot;xxx&quot;&gt;点我&lt;/a&gt;，提交按钮&lt;input type=”submit”&gt;等 return false:JS的return false只会阻止默认行为，而jQuery则既阻止默认行为又防止对象冒泡阻止浏览器默认行为兼容：123456789function stopDefault(e) &#123; var e = e || window.event; if (e &amp;&amp; e.preventDefault)&#123; e.preventDefault(); &#125;else&#123; e.returnValue = false; &#125; return false;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"手把手教你近乎免费搭建VPS和网站——.me域名","slug":"vps-website-build-website","date":"2016-11-19T16:00:00.000Z","updated":"2016-12-02T02:31:15.062Z","comments":true,"path":"2016/11/20/vps-website-build-website/","link":"","permalink":"https://blog.luckyw.cn/2016/11/20/vps-website-build-website/","excerpt":"","text":"注册.me域名 先看下图优惠码:图①:SSL证书申请地址，价值$9/年，点击之后会进入类似购物车的页面，在Promo Code输入优惠码，点Apply即可免费使用了图②:.me域名申请地址，价值$18.99/年，点击之后会出现一个需要github进行认证的页面，点击Login With Github成功认证通过之后就会进入.me域名搜索注册页面，之后添加进购物车购买即可，难度在于英语要好 转移DNS服务到DNSPod 为什么转移到DNSPod？，老实说就是我之前的几个域名都是DNSPod进行管理的，如果你用其他的(比如:digitalocean)，可仿照此步骤进行。登录到namecheap(PS:怎么注册我就略过了)，输入用户名、密码登录成功之后进入到控制面板Dashboard，选择左侧Domain List，选择右侧域名后的Manage按钮，鼠标滑动到NAMESERVERS选项，右侧选择第三项Custom DNS，ADD NAMESERVER两条记录(f1g1ns1.dnspod.net、f1g1ns2.dnspod.net)，之后等48小时全球DNS更新即可，如下图所示:","categories":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/categories/建站/"}],"tags":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/tags/建站/"}],"keywords":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/categories/建站/"}]},{"title":"手把手教你近乎免费搭建VPS和网站——VPS服务器","slug":"vps-website-build-vps","date":"2016-11-12T16:00:00.000Z","updated":"2016-12-02T02:31:00.823Z","comments":true,"path":"2016/11/13/vps-website-build-vps/","link":"","permalink":"https://blog.luckyw.cn/2016/11/13/vps-website-build-vps/","excerpt":"购置VPS服务器 点击图中所示区域或者直接点这注册，进入注册页面，点击页面右上角Sign Up按钮之后输入邮箱、密码进行注册(自己任意邮箱即可)，之后网站会向你的邮箱发送一封验证邮件，你进邮箱验证成功之后就是第二步验证了，需要你有一张信用卡或贷记卡或者PayPal(本人穷屌丝一枚，没有信用卡也没有贷记卡，只有几个银行的借记卡，如果你和我一样的话，直接注册一个PayPal好了注册链接)，注册好了之后选择PayPal验证，需要支付5美金人民币也就35块左右吧；第三步是创建一个VPS，网站称之为Droplets的东西，看自己情况进行选购，之后也就验证成功了我的配置为: 标题 选择 Choose an image Ubuntu 16.04.1 x64 Choose a size $5/mo $0.007/hour Choose a datacenter region Singapore","text":"购置VPS服务器 点击图中所示区域或者直接点这注册，进入注册页面，点击页面右上角Sign Up按钮之后输入邮箱、密码进行注册(自己任意邮箱即可)，之后网站会向你的邮箱发送一封验证邮件，你进邮箱验证成功之后就是第二步验证了，需要你有一张信用卡或贷记卡或者PayPal(本人穷屌丝一枚，没有信用卡也没有贷记卡，只有几个银行的借记卡，如果你和我一样的话，直接注册一个PayPal好了注册链接)，注册好了之后选择PayPal验证，需要支付5美金人民币也就35块左右吧；第三步是创建一个VPS，网站称之为Droplets的东西，看自己情况进行选购，之后也就验证成功了我的配置为: 标题 选择 Choose an image Ubuntu 16.04.1 x64 Choose a size $5/mo $0.007/hour Choose a datacenter region Singapore 选择Ubuntu系统是因为我自己用的就是Ubuntu系统，比较了解使用，一般建议使用Centos，因为它提供的是十年的更新服务，而Ubuntu只有五年，看个人喜好吧。我选择的低配，因为注册的时候花了5美元加上50美元的Credit Code，一共55美元，一个月5美元的话，可以使用11个月，也就是35块左右你就可以使用差不多一年的VPS服务，哪还有比这个还划算的呢？至于数据中心，我选择新加坡，因为新加坡够近啊，ping值不会很高，我测了测也就100左右 添加Credit Code 点击digitalocean登录之后右上角你的头像，选择Settings，之后在左侧选择Billing，你会发现此时Your credit的位置的值为$5.00。鼠标拉到Promo code的位置，选择你的Credit Code复制过来添加之后你再拉到页面上方Your credit的位置，发现此时的值为$55.00，那么恭喜你成功添加了50美元的Credit了 SSH登录VPS服务器 点击你创建的Droplets，进入VPS详情页，选择左侧Access，然后在右侧内容区域Reset root password点击Reset Root Password按钮，网站就会把root用户的密码重置之后然后发到你邮箱，之后你在终端输入ssh root@your_server_ip敲回车，然后复制刚才网站发给你的密码之后就发现登录成功了(PS:我会告诉你passwd可以修改登录密码吗，才不可能了) 注:如果你想搭建LAMP环境的话，可参考这篇文章Ubuntu16.04搭建LAMP环境","categories":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/categories/建站/"}],"tags":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/tags/建站/"}],"keywords":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/categories/建站/"}]},{"title":"手把手教你近乎免费搭建VPS和网站——注册edu邮箱","slug":"vps-website-build-edumail","date":"2016-11-05T16:00:00.000Z","updated":"2016-12-02T02:30:47.000Z","comments":true,"path":"2016/11/06/vps-website-build-edumail/","link":"","permalink":"https://blog.luckyw.cn/2016/11/06/vps-website-build-edumail/","excerpt":"注册edu邮箱 先说下为什么要注册edu邮箱，因为github提供的学生包顾名思义是给学生使用的，如果你不是学生的话，那么就无法使用。那么github怎么知道你是不是学生的了，简单的说就是检测你注册github的邮箱是不是edu邮箱如果你是大学生或者你有亲戚朋友的孩子是大学生的话，那么你可以直接注册你大学的edu邮箱或者借你亲戚朋友孩子的edu邮箱使用下。如果你和我一样，恰好刚毕业几年，那么就错过了这么好的服务了，请直接参考:http://www.sgld.org/2015/02/11/1054 注册github并激活 注册github我就不说了，每个码农都懂的，邮箱使用你上一步获取的edu邮箱，然后github会对你刚才用来注册的edu邮箱发送验证邮件，大概可能要等个10来分钟左右邮箱才能收到，验证成功之后进到github学生包申请页面，点击GET YOUR PACK按钮申请，进入到申请页面，信息正常填写即可，只要是edu邮箱很容易通过的，通过之后我们就可以获取我们所需要的优惠码了","text":"注册edu邮箱 先说下为什么要注册edu邮箱，因为github提供的学生包顾名思义是给学生使用的，如果你不是学生的话，那么就无法使用。那么github怎么知道你是不是学生的了，简单的说就是检测你注册github的邮箱是不是edu邮箱如果你是大学生或者你有亲戚朋友的孩子是大学生的话，那么你可以直接注册你大学的edu邮箱或者借你亲戚朋友孩子的edu邮箱使用下。如果你和我一样，恰好刚毕业几年，那么就错过了这么好的服务了，请直接参考:http://www.sgld.org/2015/02/11/1054 注册github并激活 注册github我就不说了，每个码农都懂的，邮箱使用你上一步获取的edu邮箱，然后github会对你刚才用来注册的edu邮箱发送验证邮件，大概可能要等个10来分钟左右邮箱才能收到，验证成功之后进到github学生包申请页面，点击GET YOUR PACK按钮申请，进入到申请页面，信息正常填写即可，只要是edu邮箱很容易通过的，通过之后我们就可以获取我们所需要的优惠码了DigitalOcean 50美元Credit Code Get√:NameCheap 价值$18.99/年.me域名，$9/年SSL DV证书","categories":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/categories/建站/"}],"tags":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/tags/建站/"}],"keywords":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/categories/建站/"}]},{"title":"手把手教你近乎免费搭建VPS和网站——背景介绍","slug":"vps-website-build-background","date":"2016-10-29T16:00:00.000Z","updated":"2016-12-02T02:30:31.553Z","comments":true,"path":"2016/10/30/vps-website-build-background/","link":"","permalink":"https://blog.luckyw.cn/2016/10/30/vps-website-build-background/","excerpt":"背景介绍 由于国内的网络政策，购买服务器必须备案，而备案就差不多要等半个月左右才能弄好。而我是个急性子的人，等不了那么久，没办法只好另辟蹊径首先是在godaddy购买了一个虚拟主机，大概百来块的样子(PS:我是不会告诉你有优惠码的，自寻)，而且还送了一个免费顶级域名，算起来还是蛮划算的，服务器在新加坡，速度也还是可以的，但是唯一不足的是和VPS相比差距蛮大的后来又在性价比超高的搬瓦工(号称翻墙神器)上买了一台洛杉矶直连中国线路的，价值$19.99(PS:我也不会告诉你优惠码可以省1美元左右的，自寻，不会找的右键查看源代码，顶部就有)，上面可以一键搭建SS、一键搭建OpenVPN，唯一不足的是速度太慢了，洛杉矶直连中国的ping还在三、四百左右，但是又没有办法，毕竟是个穷B，只能慢慢忍受蜗牛般的速度，每次在终端敲命令得好一会才能返回结果，着实令人抓狂","text":"背景介绍 由于国内的网络政策，购买服务器必须备案，而备案就差不多要等半个月左右才能弄好。而我是个急性子的人，等不了那么久，没办法只好另辟蹊径首先是在godaddy购买了一个虚拟主机，大概百来块的样子(PS:我是不会告诉你有优惠码的，自寻)，而且还送了一个免费顶级域名，算起来还是蛮划算的，服务器在新加坡，速度也还是可以的，但是唯一不足的是和VPS相比差距蛮大的后来又在性价比超高的搬瓦工(号称翻墙神器)上买了一台洛杉矶直连中国线路的，价值$19.99(PS:我也不会告诉你优惠码可以省1美元左右的，自寻，不会找的右键查看源代码，顶部就有)，上面可以一键搭建SS、一键搭建OpenVPN，唯一不足的是速度太慢了，洛杉矶直连中国的ping还在三、四百左右，但是又没有办法，毕竟是个穷B，只能慢慢忍受蜗牛般的速度，每次在终端敲命令得好一会才能返回结果，着实令人抓狂然而在最近，我在浏览知乎的时候发现码农之家(github)有给学生提供使用的学生包，包含以下内容如下图所示:我们只需要这三个就完全足够了:123Digital Ocean 免费50刀Credit(一个100ping左右的VPS)NameCheap 免费ME域名一个(一年，价值18.99刀)NameCheap 免费DV SSL证书一个(一年，价值9刀) 好了，接下来让我来手把手教你使用这些学生包搭建自己的网站吧 PS:由于博客近乎一个来月没有更新了，so偷个懒，我就把这个教程当成一个系列来讲解吧，抱歉哈知乎:免费稳定的 Linux vps 主机有哪些推荐？","categories":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/categories/建站/"}],"tags":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/tags/建站/"}],"keywords":[{"name":"建站","slug":"建站","permalink":"https://blog.luckyw.cn/categories/建站/"}]},{"title":"JS、jQuery各种宽高属性","slug":"js-jquery-wh","date":"2016-10-22T16:00:00.000Z","updated":"2016-12-02T02:28:54.767Z","comments":true,"path":"2016/10/23/js-jquery-wh/","link":"","permalink":"https://blog.luckyw.cn/2016/10/23/js-jquery-wh/","excerpt":"JS下各种宽高 Window和Document:JS下宽高分为挂载在Window对象和Document对象下的宽高属性，先说下Window和Document的区别: Window对象表示浏览器中打开的窗口，window对象可以省略，比如window.alert()可以简写为alert() Document对象是Window对象的一部分，那么window.document.body我们可以写成document.body，浏览器的HTML文档成为Document对象 Window下的宽高属性:12345678910window.innerWidth:浏览器窗口内部宽度window.innerHeight:浏览器窗口内部高度window.outerWidth:浏览器窗口外部宽度window.outerHeight:浏览器窗口外部高度window.screen.width:屏幕宽度window.screen.height:屏幕高度window.screen.availWidth:屏幕的可使用宽度window.screen.availHeight:屏幕的可使用高度window.screenTop:浏览器窗口距屏幕顶部的距离window.screenLeft:浏览器窗口距屏幕左侧的距离 注:innerWidth、innerHeight和outerWidth、outerHeight是不支持IE9以下版本的，而screen系列宽高则不存在兼容问题参考图如下:","text":"JS下各种宽高 Window和Document:JS下宽高分为挂载在Window对象和Document对象下的宽高属性，先说下Window和Document的区别: Window对象表示浏览器中打开的窗口，window对象可以省略，比如window.alert()可以简写为alert() Document对象是Window对象的一部分，那么window.document.body我们可以写成document.body，浏览器的HTML文档成为Document对象 Window下的宽高属性:12345678910window.innerWidth:浏览器窗口内部宽度window.innerHeight:浏览器窗口内部高度window.outerWidth:浏览器窗口外部宽度window.outerHeight:浏览器窗口外部高度window.screen.width:屏幕宽度window.screen.height:屏幕高度window.screen.availWidth:屏幕的可使用宽度window.screen.availHeight:屏幕的可使用高度window.screenTop:浏览器窗口距屏幕顶部的距离window.screenLeft:浏览器窗口距屏幕左侧的距离 注:innerWidth、innerHeight和outerWidth、outerHeight是不支持IE9以下版本的，而screen系列宽高则不存在兼容问题参考图如下:Document下的宽高属性:Docment下有三类属性: 与client相关的宽高 与offset相关的宽高 与scroll相关的宽高 与client相关的宽高:1234document.body.clientWidthdocument.body.clientHeightdocument.body.clientLeftdocument.body.clientTop clientWidth和clientHeight该属性指的是元素的可视部分宽度和高度，即padding+content 如果没有滚动条，即为元素设定的高度和宽度 如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高 clientLeft和clientTop这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是012clientTop = border-top.border-widthclientLeft = border-left.border-width 获取浏览器窗口可视区域大小在不同浏览器都实用的JS方案:12var w = document.documentElement.clientWidth || document.body.clientWidth;var h = document.documentElement.clientHeight || document.body.clientHeight; 与offset相关宽高介绍:1234document.body.offsetWidthdocument.body.offsetHeightdocument.offsetLeftdocument.offsetTop offsetWidth与offsetHeight这一对属性指的是元素的border+padding+content的宽度和高度该属性和其内部的内容是否超出元素大小无关，只和本来设定的border以及padding和content有关offsetLeft和offsetTop这两个属性是基于offsetParent的，了解这两个属性我们必须先了解什么是offsetParent如果当前元素的父级元素没有进行CSS定位（position为absolute或relative）,offsetParent为border.假如当前元素的父级元素中有CSS定位，offsetParent取最近的那个父级元素。 在IE6/7中：offsetLeft=(offsetParent的padding-left)+(当前元素的margin-left) 在IE8/9/10及Chrome中：offsetLeft=(offsetParent的margin-left)+(offsetParent的border宽度)+(offsetParent的padding-left)+(当前元素的margin-left) 在FireFox中：offsetLeft=(offsetParent的margin-left)+(offsetParent的padding-left)+(当前元素的margin-left) 与scroll相关宽高介绍:1234document.body.scrollWidthdocument.body.scrollHeightdocument.body.scrollLeftdocument.body.scrollTop scrollWidth和scrollHeight: 给定宽高小于浏览器窗口:scrollWidth:浏览器窗口的宽度scrollHeight:浏览器窗口的高度 给定宽高大于浏览器窗口，且内容小于给定宽高:scrollWidth:给定的宽度+其所有padding、margin、borderscrollHeight:给定的高度+其所有的padding、margin、border 给定宽高大于浏览器窗口，且内容大于给定宽高:scrollWidth:内容宽度+其所有的padding、margin、borderscrollHeight:内容高度+其所有的padding、margin、border scrollLeft和scrollTop这对属性是可读写的，指的是当元素其中的内容超出其宽高的时候，元素被卷起来的宽度和高度 Event对象的5种坐标12345clientX和clientY，相对于浏览器（可视区左上角0,0）的坐标screenX和screenY，相对于设备屏幕左上角（0,0）的坐标offsetX和offsetY，相对于事件源左上角（0,0）的坐标pageX和pageY，相对于整个网页左上角（0,0）的坐标X和Y，本来是IE属性，相对于用CSS动态定位的最内层包容元素 JQuery下各种宽高 12345678910width():元素的content区域宽度height():元素的content区域高度innerWidth():元素的content+padding区域宽度innerHeight():元素的content+padding区域高度outerWidth(Boolean):可选，默认表示元素的content+padding+border区域的宽度，如果为true表示元素的content+padding+border+margin区域的宽度outerHeight(Boolean):可选，默认表示元素的content+padding+border区域的高度，如果为true表示元素的content+padding+border+margin区域的高度scrollLeft():相对于水平滚动条左边的距离scrollTop():相对于垂直滚动条上边的距离offset():返回相对于document的当前坐标值，包含left、top值position():返回相对于offsetParent的当前坐标值，包含left、top值 本文整理自慕课网课程《JS/jQuery宽高的理解和应用》","categories":[{"name":"JS,JQuery","slug":"JS-JQuery","permalink":"https://blog.luckyw.cn/categories/JS-JQuery/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://blog.luckyw.cn/tags/JQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS,JQuery","slug":"JS-JQuery","permalink":"https://blog.luckyw.cn/categories/JS-JQuery/"}]},{"title":"利用腾讯云免费证书打造全https站","slug":"https-whole-website","date":"2016-10-15T16:00:00.000Z","updated":"2016-11-21T00:06:23.639Z","comments":true,"path":"2016/10/16/https-whole-website/","link":"","permalink":"https://blog.luckyw.cn/2016/10/16/https-whole-website/","excerpt":"什么是https? 超文本传输安全协议(Hypertext Transfer Protocol Secure，缩写为HTTPS)是一种网络安全传输协议http是HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。HTTPS通过TLS层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被查看或篡改，以及防止中间人冒充，相比http而言更安全，越来越多的网站选择了全站 HTTPS 如何搭建https? 通过腾讯云申请免费的SSL证书，为期一年，申请地址:https://console.qcloud.com/ssl我就不废话了，直接上图如下:注意:域名这里我们填的是二级域名，因为腾讯云仅支持单个非顶级域名的证书申请，如果我们有多个子域需要申请多次","text":"什么是https? 超文本传输安全协议(Hypertext Transfer Protocol Secure，缩写为HTTPS)是一种网络安全传输协议http是HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。HTTPS通过TLS层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被查看或篡改，以及防止中间人冒充，相比http而言更安全，越来越多的网站选择了全站 HTTPS 如何搭建https? 通过腾讯云申请免费的SSL证书，为期一年，申请地址:https://console.qcloud.com/ssl我就不废话了，直接上图如下:注意:域名这里我们填的是二级域名，因为腾讯云仅支持单个非顶级域名的证书申请，如果我们有多个子域需要申请多次DNS验证可以选择自动和手动，如果自动失败的话可以再手动验证，手动验证操作如下，自动验证通过可无视，查看证书详情，看到如下信息:这里以DNSPOD解析为例，其他解析服务基本一样，主机记录就是上图标记①中内容，记录类型选择CNAME，记录值选择上图标记②的内容，点击保存，然后等差不多一分钟左右证书就申请下来了:配置的话请参考证书安装指南，需要上传到服务器 配置htaccess 此时我们访问我们的网站可以发现加https和不加https都可以访问到，那么如何强制把网站重定向到https页面中去了，也就是接下来要说到的htaccess文件了，可以用来重定向页面我们在服务器根目录下新建一个.htaccess文件，然后往其中添加以下几行就会自动定向到https中去123RewriteEngine OnRewriteCond %&#123;HTTPS&#125; offRewriteRule ^(.*)$ https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [L,R=301] 当然如果你需要你每个子域都重定向到https页面中去，那么可以在每个子域的根目录下添加上面的.htaccess文件，暂时我选用的就是这个笨办法此时你可以发现直接重定向到https页面了，但是由于之前引用的微博图床的图片因为是http协议，所以控制台会报错，提示Mixed Content错误信息。如果图片是直接输出到页面中的话，因为微博图床也支持https引用，所以我们可以修改http协议为https，此时控制台就不会再报错了。如果图片信息是从数据库里获取的话，我们可以在mysql执行以下命令批量修改1update table set imgSrc=REPLACE(imgSrc,&apos;http:&apos;,&apos;https:&apos;) 但是我建议的是不直接使用https，而是采用无协议头的用法，也即引用大多数CDN所使用的方法好了，到此全站https的启用就完成了，你会发现访问我的网站时浏览器地址栏都加了一把小锁了 参考资料:超文本传输安全协议Redirect HTTP to HTTPS automatically25个有用.htaccess技巧21个非常有用的.htaccess提示和技巧","categories":[{"name":"Https","slug":"Https","permalink":"https://blog.luckyw.cn/categories/Https/"}],"tags":[{"name":"Https","slug":"Https","permalink":"https://blog.luckyw.cn/tags/Https/"}],"keywords":[{"name":"Https","slug":"Https","permalink":"https://blog.luckyw.cn/categories/Https/"}]},{"title":"免费日本樱花搭建谷歌镜像","slug":"free-google-mirror","date":"2016-10-09T16:00:00.000Z","updated":"2016-11-20T10:46:47.606Z","comments":true,"path":"2016/10/10/free-google-mirror/","link":"","permalink":"https://blog.luckyw.cn/2016/10/10/free-google-mirror/","excerpt":"前言 日本樱花由于之前我已经在arukas.io免费docker搭建ss服务一文中介绍过，所以不再赘述了，不了解的可以先去看看，我们可以利用它来搭建SS、VPS、VPN等等，本文介绍的是怎么利用它来搭建谷歌镜像，利用的是cuber大大写的ngx_http_google_filter_module——Nginx Google 扩展因为不知道什么时候日本樱花会突然停止测试，所以有效性待查，失效的话我会及时更新告诉各位亲 安装ubuntu 由于我本机用的linux系统是ubuntu，对它相比较其它linux系统而言熟悉些，所以本测试在日本樱花服务安装的是ubuntu系统，如果你有其它的系统可以用其它的，安装过程见下图:docker镜像地址:tutum/ubuntu:latest，看不清的点图放大看，最后点击创建，然后启动服务等待完成也就是running状态，然后点击watch查看输出的信息也就是ssh的随机密码注意:如果点击watch之后没反应，那么反复点击吧，不过别太快，大概十秒一次就可以，如果将近五六分钟还没反应建议重启以下，我也是这么熬过来的╮(╯▽╰)╭ 安装nginx反向代理谷歌镜像 首先我们先从app的port中查找到我们的服务器的ip和端口号，详见下图:","text":"前言 日本樱花由于之前我已经在arukas.io免费docker搭建ss服务一文中介绍过，所以不再赘述了，不了解的可以先去看看，我们可以利用它来搭建SS、VPS、VPN等等，本文介绍的是怎么利用它来搭建谷歌镜像，利用的是cuber大大写的ngx_http_google_filter_module——Nginx Google 扩展因为不知道什么时候日本樱花会突然停止测试，所以有效性待查，失效的话我会及时更新告诉各位亲 安装ubuntu 由于我本机用的linux系统是ubuntu，对它相比较其它linux系统而言熟悉些，所以本测试在日本樱花服务安装的是ubuntu系统，如果你有其它的系统可以用其它的，安装过程见下图:docker镜像地址:tutum/ubuntu:latest，看不清的点图放大看，最后点击创建，然后启动服务等待完成也就是running状态，然后点击watch查看输出的信息也就是ssh的随机密码注意:如果点击watch之后没反应，那么反复点击吧，不过别太快，大概十秒一次就可以，如果将近五六分钟还没反应建议重启以下，我也是这么熬过来的╮(╯▽╰)╭ 安装nginx反向代理谷歌镜像 首先我们先从app的port中查找到我们的服务器的ip和端口号，详见下图:可以看到我们服务器的ip地址为:153.125.232.238，端口为31985，之后我们打开终端输入以下代码:ssh -p31985 root@153.125.232.238，敲回车之后提示输入密码，再复制上一步我们看到的密码过来，接下来我们就登录成功了，为了防止每次登录都需要取复制密码，可以直接passwd修改密码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 安装gcc&amp;&amp;gitapt-get install build-essential git gcc g++ make# 下载最新版nginx源码# nginx官网:http://nginx.org/en/download.htmlwget &quot;http://nginx.org/download/nginx-1.10.2.tar.gz&quot;# 下载最新版pcre源码# pcre官网:# http://www.pcre.org/wget &quot;ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz&quot;# 下载最新版openssl源码# opessl官网:# https://www.openssl.org/wget &quot;https://www.openssl.org/source/openssl-1.1.0b.tar.gz&quot;# 下载最新版zlib源码# zlib官网:# http://www.zlib.net/wget &quot;http://zlib.net/zlib-1.2.8.tar.gz&quot;# 下载Nginx Google扩展git clone https://github.com/cuber/ngx_http_google_filter_module# 下载substitutions扩展git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module# 解压缩tar xzvf nginx-1.10.2.tar.gztar xzvf pcre-8.39.tar.gztar xzvf openssl-1.1.0b.tar.gztar xzvf zlib-1.2.8.tar.gz# 进入nginx源码目录cd nginx-1.10.2# 设置编译选项./configure \\ --prefix=/opt/nginx-1.10.2 \\ --with-pcre=../pcre-8.39 \\ --with-openssl=../openssl-1.1.0b \\ --with-zlib=../zlib-1.2.8 \\ --with-http_ssl_module \\ --add-module=../ngx_http_google_filter_module \\ --add-module=../ngx_http_substitutions_filter_module# 编译、安装make //时间可能微长make install //这个略快# 启动, 安装过程到此结束/opt/nginx-1.10.2/sbin/nginx# 这时我们鼠标点击app中port的第一条即80端口那条# 会出来Welcome to nginx页面表示安装完成 修改配置文件 首先先安装vim，因为vi不会，习惯用gedit，但是装了用不了，谷歌了也解决不了问题，索性vim，略懂一点点12345678910111213141516171819202122232425# 安装vimapt install vim# 编辑配置文件vim /opt/nginx-1.10.2/conf/nginx.conf# 增加两行server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; resolver 8.8.8.8; //加这句 location / &#123; root html; index index.html index.htm; google on; //加这句 &#125; .......&#125;# 配置修改后, 需要reload nginx来让配置生效/opt/nginx-1.10.2/sbin/nginx -s reload OK，到此安装完成，效果见链接:luckywcn谷歌镜像了解更多请参考:Nginx Google 扩展","categories":[{"name":"Google","slug":"Google","permalink":"https://blog.luckyw.cn/categories/Google/"}],"tags":[{"name":"Google","slug":"Google","permalink":"https://blog.luckyw.cn/tags/Google/"}],"keywords":[{"name":"Google","slug":"Google","permalink":"https://blog.luckyw.cn/categories/Google/"}]},{"title":"heroku线上部署node小程序","slug":"ubuntu-heroku-node","date":"2016-10-04T16:00:00.000Z","updated":"2016-11-20T11:07:35.746Z","comments":true,"path":"2016/10/05/ubuntu-heroku-node/","link":"","permalink":"https://blog.luckyw.cn/2016/10/05/ubuntu-heroku-node/","excerpt":"环境安装 首先我们需要个heroku账户，可以点这里申请，然后我们需要在本地下载安装它的工具包(我这里只讲Ubuntu，其他请转https://devcenter.heroku.com/articles/heroku-command-line)1wget -O- https://toolbelt.heroku.com/install-ubuntu.sh | sh 如果上面代码安装失败(可能只是我的电脑问题)，并报认证之类的错误，那就把https://toolbelt.heroku.com/install-ubuntu.sh的代码复制到本地保存为install.sh,将第13行的http改为https,如下所示:123456789101112131415161718192021222324252627282930#!/bin/sh&#123; echo &quot;This script requires superuser access to install apt packages.&quot; echo &quot;You will be prompted for your password by sudo.&quot; # clear any previous sudo permission sudo -k # run inside sudo sudo sh &lt;&lt;SCRIPT # add heroku repository to apt echo &quot;deb https://toolbelt.heroku.com/ubuntu ./&quot; &gt; /etc/apt/sources.list.d/heroku.list # install heroku&apos;s release key for package verification wget -O- https://toolbelt.heroku.com/apt/release.key | apt-key add - # update your sources apt-get update # install the toolbelt apt-get install -y heroku-toolbelt # install ruby if needed (vervet) if ! type ruby &gt;/dev/null 2&gt;&amp;1; then apt-get install -y ruby fiSCRIPT&#125; 然后再执行sh install.sh应该就没问题了","text":"环境安装 首先我们需要个heroku账户，可以点这里申请，然后我们需要在本地下载安装它的工具包(我这里只讲Ubuntu，其他请转https://devcenter.heroku.com/articles/heroku-command-line)1wget -O- https://toolbelt.heroku.com/install-ubuntu.sh | sh 如果上面代码安装失败(可能只是我的电脑问题)，并报认证之类的错误，那就把https://toolbelt.heroku.com/install-ubuntu.sh的代码复制到本地保存为install.sh,将第13行的http改为https,如下所示:123456789101112131415161718192021222324252627282930#!/bin/sh&#123; echo &quot;This script requires superuser access to install apt packages.&quot; echo &quot;You will be prompted for your password by sudo.&quot; # clear any previous sudo permission sudo -k # run inside sudo sudo sh &lt;&lt;SCRIPT # add heroku repository to apt echo &quot;deb https://toolbelt.heroku.com/ubuntu ./&quot; &gt; /etc/apt/sources.list.d/heroku.list # install heroku&apos;s release key for package verification wget -O- https://toolbelt.heroku.com/apt/release.key | apt-key add - # update your sources apt-get update # install the toolbelt apt-get install -y heroku-toolbelt # install ruby if needed (vervet) if ! type ruby &gt;/dev/null 2&gt;&amp;1; then apt-get install -y ruby fiSCRIPT&#125; 然后再执行sh install.sh应该就没问题了看是否安装成功，输入heroku --version，如果如下图之类输出的话表示安装成功登录:执行命令heroku login，输入你的注册邮箱和密码，认证成功登录 代码部署 我以慕课网下载解析为例，首先从我的gitub上克隆这个项目到本地123git clone https://github.com/leoyaojy/imooc-video-downloader.gitcd imooc-video-downloaderheroku create //创建一个app应用 修改package.json文件两处地方,添加对bower的支持，如下:123456789101112&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;postinstall&quot;: &quot;./node_modules/bower/bin/bower install&quot; //增加此行&#125;,&quot;dependencies&quot;: &#123; &quot;bower&quot;:&quot;^1.7.9&quot;, //增加此行 &quot;body-parser&quot;: &quot;^1.15.2&quot;, &quot;cheerio&quot;: &quot;^0.22.0&quot;, &quot;express&quot;: &quot;^4.14.0&quot;, &quot;jade&quot;: &quot;^1.11.0&quot;, &quot;request&quot;: &quot;^2.74.0&quot;&#125;, 新建Procfile文件，里面内容为web: node app接着执行以下几行代码，部署就完成了123git add .git commit -m &quot;deploy&quot;git push heroku master 最后执行heroku open就可以直接在浏览器打开，测试地址:https://pure-thicket-46482.herokuapp.com/","categories":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/tags/Node/"}],"keywords":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/categories/Node/"}]},{"title":"Python3爬取豆瓣电影保存到MySQL数据库","slug":"py3-douban-movie","date":"2016-09-26T16:00:00.000Z","updated":"2016-11-20T11:06:28.134Z","comments":true,"path":"2016/09/27/py3-douban-movie/","link":"","permalink":"https://blog.luckyw.cn/2016/09/27/py3-douban-movie/","excerpt":"48行代码实现Python3爬取豆瓣电影排行榜 代码基于python3，用到的类库有: requests:通过伪造请求头或设置代理等方式获取页面内容，参考文档BeautifulSoup:对页面进行解析，提取数据，参考文档PyMySQL:python3版本中用于操作MySQL数据库，python2中则使用mysqldb，Github pip安装用到的几个类库:123pip install requestspip install bs4pip install pymysql 分析豆瓣电影页面 页面分析:爬取数据之前，我们都需要对页面进行分析，看我们可以从中提取到哪些数据，从下图我们看到豆瓣电影top250的页面结构，我们可以从中提取出排行榜(rank)、电影名字(name)、电影详情页链接(link)、电影海报(poster)、电影评分(score)、电影评论(quote)等，我在图中进行了标注URL分析:通过点击分页我们可以发现URL的格式为:https://movie.douban.com/top250?start=num&amp;filter=其中num表示25的倍数的数字，最小是0也就是第一页，最大为225也就是最后一页，这可以作为我们爬取页面的限制条件，filter为过滤条件这里可不用管","text":"48行代码实现Python3爬取豆瓣电影排行榜 代码基于python3，用到的类库有: requests:通过伪造请求头或设置代理等方式获取页面内容，参考文档BeautifulSoup:对页面进行解析，提取数据，参考文档PyMySQL:python3版本中用于操作MySQL数据库，python2中则使用mysqldb，Github pip安装用到的几个类库:123pip install requestspip install bs4pip install pymysql 分析豆瓣电影页面 页面分析:爬取数据之前，我们都需要对页面进行分析，看我们可以从中提取到哪些数据，从下图我们看到豆瓣电影top250的页面结构，我们可以从中提取出排行榜(rank)、电影名字(name)、电影详情页链接(link)、电影海报(poster)、电影评分(score)、电影评论(quote)等，我在图中进行了标注URL分析:通过点击分页我们可以发现URL的格式为:https://movie.douban.com/top250?start=num&amp;filter=其中num表示25的倍数的数字，最小是0也就是第一页，最大为225也就是最后一页，这可以作为我们爬取页面的限制条件，filter为过滤条件这里可不用管 代码 引入类库:123import pymysqlimport requestsfrom bs4 import BeautifulSoup 定义爬取链接，%d用作数字占位:1baseUrl = &quot;https://movie.douban.com/top250?start=%d&amp;filter=&quot; 定义爬取数据方法:12345678910111213141516def get_movies(start): url = baseUrl % start # 拼接爬取链接 lists = [] # 存储此页面的电影数据 html = requests.get(url) # requests请求页面内容，由于豆瓣没有限制爬取，所以不用设置伪请求头 soup = BeautifulSoup(html.content, &quot;html.parser&quot;) # BeautifulSoup解析页面内容 items = soup.find(&quot;ol&quot;, &quot;grid_view&quot;).find_all(&quot;li&quot;) # 获取所有的电影内容 for i in items: movie = &#123;&#125; # 临时存取电影的数据 movie[&quot;rank&quot;] = i.find(&quot;em&quot;).text # 电影排行榜 movie[&quot;link&quot;] = i.find(&quot;div&quot;,&quot;pic&quot;).find(&quot;a&quot;).get(&quot;href&quot;) # 电影详情页链接 movie[&quot;poster&quot;] = i.find(&quot;div&quot;,&quot;pic&quot;).find(&quot;a&quot;).find(&apos;img&apos;).get(&quot;src&quot;) # 电影海报地址 movie[&quot;name&quot;] = i.find(&quot;span&quot;, &quot;title&quot;).text # 电影名字 movie[&quot;score&quot;] = i.find(&quot;span&quot;, &quot;rating_num&quot;).text # 电影评分 movie[&quot;quote&quot;] = i.find(&quot;span&quot;, &quot;inq&quot;).text if(i.find(&quot;span&quot;, &quot;inq&quot;)) else &quot;&quot; # 某些电影没有点评，没有就设为空 lists.append(movie) # 保存到返回数组中 return lists 连接数据库并创建数据表:1234567891011121314151617# 连接数据库，需指定charset否则可能会报错db = pymysql.connect(host=&quot;localhost&quot;,user=&quot;root&quot;,password=&quot;root&quot;,db=&quot;test&quot;,charset=&quot;utf8mb4&quot;)cursor = db.cursor() # 创建一个游标对象cursor.execute(&quot;DROP TABLE IF EXISTS movies&quot;) # 如果表存在则删除# 创建表sql语句createTab = &quot;&quot;&quot;CREATE TABLE movies( id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(20) NOT NULL, rank VARCHAR(4) NOT NULL, link VARCHAR(50) NOT NULL, poster VARCHAR(100) NOT NULL, score VARCHAR(4) NOT NULL, quote VARCHAR(50))&quot;&quot;&quot;cursor.execute(createTab) # 执行创建数据表操作......db.close() # 关闭数据库 将提取到的数据存储到数据表中:1234567891011lists = get_movies(start) # 获取提取到数据 for i in lists: # 插入数据到数据库sql语句，%s用作字符串占位 sql = &quot;INSERT INTO `movies`(`name`,`rank`,`link`,`poster`,`score`,`quote`) VALUES(%s,%s,%s,%s,%s,%s)&quot; try: cursor.execute(sql, (i[&quot;name&quot;], i[&quot;rank&quot;], i[&quot;link&quot;], i[&quot;poster&quot;], i[&quot;score&quot;], i[&quot;quote&quot;])) db.commit() print(i[0]+&quot; is success&quot;) except: db.rollback() start += 25 完整代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import pymysqlimport requestsfrom bs4 import BeautifulSoupbaseUrl = &quot;https://movie.douban.com/top250?start=%d&amp;filter=&quot;def get_movies(start): url = baseUrl % start lists = [] html = requests.get(url) soup = BeautifulSoup(html.content, &quot;html.parser&quot;) items = soup.find(&quot;ol&quot;, &quot;grid_view&quot;).find_all(&quot;li&quot;) for i in items: movie = &#123;&#125; movie[&quot;rank&quot;] = i.find(&quot;em&quot;).text movie[&quot;link&quot;] = i.find(&quot;div&quot;,&quot;pic&quot;).find(&quot;a&quot;).get(&quot;href&quot;) movie[&quot;poster&quot;] = i.find(&quot;div&quot;,&quot;pic&quot;).find(&quot;a&quot;).find(&apos;img&apos;).get(&quot;src&quot;) movie[&quot;name&quot;] = i.find(&quot;span&quot;, &quot;title&quot;).text movie[&quot;score&quot;] = i.find(&quot;span&quot;, &quot;rating_num&quot;).text movie[&quot;quote&quot;] = i.find(&quot;span&quot;, &quot;inq&quot;).text if(i.find(&quot;span&quot;, &quot;inq&quot;)) else &quot;&quot; lists.append(movie) return listsif __name__ == &quot;__main__&quot;: db = pymysql.connect(host=&quot;localhost&quot;,user=&quot;root&quot;,password=&quot;root&quot;,db=&quot;test&quot;,charset=&quot;utf8mb4&quot;) cursor = db.cursor() cursor.execute(&quot;DROP TABLE IF EXISTS movies&quot;) createTab = &quot;&quot;&quot;CREATE TABLE movies( id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(20) NOT NULL, rank VARCHAR(4) NOT NULL, link VARCHAR(50) NOT NULL, poster VARCHAR(100) NOT NULL, score VARCHAR(4) NOT NULL, quote VARCHAR(50) )&quot;&quot;&quot; cursor.execute(createTab) start = 0 while (start &lt; 250): lists = get_movies(start) for i in lists: sql = &quot;INSERT INTO `movies`(`name`,`rank`,`link`,`poster`,`score`,`quote`) VALUES(%s,%s,%s,%s,%s,%s)&quot; try: cursor.execute(sql, (i[&quot;name&quot;], i[&quot;rank&quot;], i[&quot;link&quot;], i[&quot;poster&quot;], i[&quot;score&quot;], i[&quot;quote&quot;])) db.commit() print(i[&quot;name&quot;]+&quot; is success&quot;) except: db.rollback() start += 25 db.close()","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.luckyw.cn/categories/Python/"}],"tags":[{"name":"Python，Mysql","slug":"Python，Mysql","permalink":"https://blog.luckyw.cn/tags/Python，Mysql/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://blog.luckyw.cn/categories/Python/"}]},{"title":"Linux crontab 定时任务","slug":"linux-crontab","date":"2016-09-17T16:00:00.000Z","updated":"2016-11-20T11:01:02.479Z","comments":true,"path":"2016/09/18/linux-crontab/","link":"","permalink":"https://blog.luckyw.cn/2016/09/18/linux-crontab/","excerpt":"今天是个特殊的日子，不用说大家也知道，在这里我只想说八个字:勿忘国耻，振兴中华 什么是crontab？ crontab命令是cron table的简写，它是cron的配置文件，也叫作任务列表，我们可以在下列目录下找到相关配置文件 /var/spool/cron/:存放所有用户定义要定期执行的任务，文件名与用户名一致/etc/crontab:系统周期性所要执行的任务/etc/cron.d/:目录用来存放任何要执行的crontab文件或脚本其他目录:/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly，各代表存放每小时、每天、每星期、每月执行一次的任务","text":"今天是个特殊的日子，不用说大家也知道，在这里我只想说八个字:勿忘国耻，振兴中华 什么是crontab？ crontab命令是cron table的简写，它是cron的配置文件，也叫作任务列表，我们可以在下列目录下找到相关配置文件 /var/spool/cron/:存放所有用户定义要定期执行的任务，文件名与用户名一致/etc/crontab:系统周期性所要执行的任务/etc/cron.d/:目录用来存放任何要执行的crontab文件或脚本其他目录:/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly，各代表存放每小时、每天、每星期、每月执行一次的任务 crontab的使用 1234crontab [-u username] //可选，省略则表示操作当前用户的crontab -e //编辑crontab定时任务 -l //列出crontab里的内容 -r //删除crontab crontab的命令由时间和命令构成，其时间由分、时、日、月、周五种按顺序排列，操作符有: *:任何时间/:每隔多久-:连续时间,:不连续的时间 实例说明 每分钟执行一次命令 1* * * * * 命令 每小时的第10分钟和第30分钟执行 110,30 * * * * 命令 在8点到10点的每分钟执行 1* 8-10 * * * 命令 每月15号每隔10分钟执行 1*/10 * 15 * * 命令 每周一的六点三十分执行 130 6 * * 1 命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/categories/Linux/"}]},{"title":"php实现图片上传与下载","slug":"php-upload-download","date":"2016-09-10T16:00:00.000Z","updated":"2016-11-20T11:05:06.142Z","comments":true,"path":"2016/09/11/php-upload-download/","link":"","permalink":"https://blog.luckyw.cn/2016/09/11/php-upload-download/","excerpt":"本文接下来的内容讲的是如何通过php实现图片的上传与下载 构建上传文件前端页面 这里我借助bootstrap前端框架以及fontawesome图标库，内容很简单就一个图片上传框以及一个提交按钮，代码如下:1234567891011121314&lt;!--form.php--&gt;&lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;upload_del.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; class=&quot;form-horizontal&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;2097152&quot;&gt; &lt;div class=&quot;btn btn-success fileBox&quot;&gt; &lt;span&gt; &lt;i class=&quot;fa fa-file-image-o&quot;&gt;&lt;/i&gt; 上传图片 &lt;/span&gt; &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; name=&quot;file[]&quot; multiple&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot; class=&quot;btn btn-primary&quot;&gt; &lt;/form&gt;&lt;/div&gt; 其中:&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;2097152&quot;&gt;隐藏域主要是用来现在文件上传大小的，设置为2M=&gt;2*1024*1024=&gt;2097152&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; name=&quot;file[]&quot; multiple&gt;设置接收文件类型为图片格式，可多张图片上传，注意name属性值为file[]时服务器可接收多图片","text":"本文接下来的内容讲的是如何通过php实现图片的上传与下载 构建上传文件前端页面 这里我借助bootstrap前端框架以及fontawesome图标库，内容很简单就一个图片上传框以及一个提交按钮，代码如下:1234567891011121314&lt;!--form.php--&gt;&lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;upload_del.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; class=&quot;form-horizontal&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;2097152&quot;&gt; &lt;div class=&quot;btn btn-success fileBox&quot;&gt; &lt;span&gt; &lt;i class=&quot;fa fa-file-image-o&quot;&gt;&lt;/i&gt; 上传图片 &lt;/span&gt; &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; name=&quot;file[]&quot; multiple&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot; class=&quot;btn btn-primary&quot;&gt; &lt;/form&gt;&lt;/div&gt; 其中:&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;2097152&quot;&gt;隐藏域主要是用来现在文件上传大小的，设置为2M=&gt;2*1024*1024=&gt;2097152&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; name=&quot;file[]&quot; multiple&gt;设置接收文件类型为图片格式，可多张图片上传，注意name属性值为file[]时服务器可接收多图片 后台服务器图片上传处理 文件从前端上传到服务器之后，服务器得到上传文件的信息之后进行处理，主要包括以下几点: 首先图片上传有没有错误，如果没有下一步，有则返回错误信息 检测文件上传的大小 检测文件类型，看是否为图片类型 检测是否为真实图片类型，有些图片可能是伪造的，比如我们把一个文本文件扩展名修改成图片类型，上述几条照样通过 移动服务器临时文件到指定目录 针对2、3步有人可能会问，我们不是前端已经在隐藏域中限制上传大小了嘛，而且也设置了文件的接收类型，为什么服务器还要进行验证呢？有句话是这么说的，服务器永远不要相信客户端传过来的数据，有过编程经验的人都知道，我们可以在浏览器修改前端的页面结构以及内容，而且还可以伪造数据，前端的验证只是起到过滤的作用，并不能一劳永逸，服务器还是得验证前台传过来的数据 接下来直接看代码，处理文件上传函数upload_fun.php:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?php/** * 获取上传文件信息,处理单文件和多文件上传 * @return array 上传文件信息 */function getFiles()&#123; $i = 0; $files=[]; foreach ($_FILES as $file) &#123; if (is_string($file[&quot;name&quot;])) &#123; $files[$i] = $file; $i++; &#125; elseif (is_array($file[&quot;name&quot;])) &#123; foreach ($file[&quot;name&quot;] as $key =&gt; $val) &#123; $files[$i][&quot;name&quot;] = $file[&quot;name&quot;][$key]; $files[$i][&quot;type&quot;] = $file[&quot;type&quot;][$key]; $files[$i][&quot;tmp_name&quot;] = $file[&quot;tmp_name&quot;][$key]; $files[$i][&quot;error&quot;] = $file[&quot;error&quot;][$key]; $files[$i][&quot;size&quot;] = $file[&quot;size&quot;][$key]; $i++; &#125; &#125; &#125; return $files;&#125;/** * 获取文件的扩展名 * @param $filename:文件名 * @return string 扩展名 */function getExt($filename)&#123; return strtolower(pathinfo($filename, PATHINFO_EXTENSION));&#125;/** * 生成唯一字符串作为文件名 * @return string 唯一文件名 */function getUniName()&#123; return md5(uniqid(microtime(true), true));&#125;/** * 上传文件主处理模块 * @param $fileInfo:文件信息 * @param string $path:上传文件路径 * @param bool $flag:是否开启验证是否为真实图片 * @param int $maxSize:文件最大上传大小 * @param array $allowExt:允许的文件扩展名 * @return array 信息 */function upload_file($fileInfo, $path = &quot;./uploads&quot;, $flag = true, $maxSize = 2*1024 * 1024, $allowExt = [&quot;jpeg&quot;, &apos;jpg&apos;, &apos;png&apos;, &apos;gif&apos;])&#123; $res = []; if ($fileInfo[&apos;error&apos;] == UPLOAD_ERR_OK) &#123; $ext = getExt($fileInfo[&quot;name&quot;]); $uniName = getUniName(); $dest = $path . &quot;/&quot; . $uniName . &quot;.&quot; . $ext; //检测上传文件大小 if ($fileInfo[&quot;size&quot;] &gt; $maxSize) &#123; $res[&quot;msg&quot;] = $fileInfo[&quot;name&quot;] . &quot;上传文件过大&quot;; &#125; //上传文件类型 if (!in_array($ext, $allowExt)) &#123; $res[&quot;msg&quot;] = $fileInfo[&quot;name&quot;] . &quot;非法文件类型&quot;; &#125; //检测是否为真实图片 if ($flag) &#123; if (!getimagesize($fileInfo[&quot;tmp_name&quot;])) &#123; $res[&quot;mes&quot;] = $fileInfo[&quot;name&quot;] . &quot;不是真实图片&quot;; &#125; &#125; if ($res) return $res; if (!file_exists($path)) &#123; mkdir($path, 0777, true); &#125; if (!@move_uploaded_file($fileInfo[&quot;tmp_name&quot;], $dest)) &#123; $res[&apos;msg&apos;] = $fileInfo[&quot;name&quot;] . &quot;文件上传失败&quot;; &#125; else &#123; $res[&quot;msg&quot;] = $fileInfo[&quot;name&quot;] . &quot;文件上传成功&quot;; $res[&quot;dest&quot;] = $dest; &#125; return $res; &#125; else &#123; //判断错误信息 switch ($fileInfo[&quot;error&quot;]) &#123; case 1: $res[&quot;mes&quot;] = &quot;上传文件超过php配置文件中upload_max_filesize选项的值&quot;; break; case 2: $res[&quot;mes&quot;] = &quot;超过了表单MMAX_FILE_SIZE限制的大小&quot;; break; case 3: $res[&quot;mes&quot;] = &quot;文件部分被上传&quot;; break; case 4: $res[&quot;mes&quot;] = &quot;没有选择上传文件&quot;; break; case 6: $res[&quot;mes&quot;] = &quot;没有找到临时目录&quot;; break; case 7: $res[&apos;msg&apos;] = &quot;文件写入失败&quot;; break; case 8: $res[&quot;mes&quot;] = &quot;系统错误&quot;; break; &#125; return $res; &#125;&#125; 服务器接收上传文件调用处理文件上传函数upload_fun.php进行处理:123456789101112&lt;?php//upload_del.phprequire_once &quot;upload_fun.php&quot;;$files = getFiles();foreach ($files as $fileInfo)&#123; $res = upload_file($fileInfo); echo $res[&quot;msg&quot;].&apos;&lt;br&gt;&apos;; $uploadFiles[] = $res[&quot;dest&quot;];&#125;$uploadFiles = array_values(array_filter($uploadFiles));print_r($uploadFiles); $uploadFiles = array_values(array_filter($uploadFiles));这句主要是因为上传多文件时可能会有个别文件出错而上传失败导致$uploadFiles[]中的某个值是空值，所以我们需要对其进行过滤并赋值给一个新数组","categories":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/categories/Php/"}],"tags":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/tags/Php/"}],"keywords":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/categories/Php/"}]},{"title":"arukas.io免费docker搭建ss服务","slug":"arukas-create-ss","date":"2016-09-03T16:00:00.000Z","updated":"2016-11-20T09:22:54.555Z","comments":true,"path":"2016/09/04/arukas-create-ss/","link":"","permalink":"https://blog.luckyw.cn/2016/09/04/arukas-create-ss/","excerpt":"之前 Chrome插件分享 一文中文章最末分享过通过修改hosts文件科学上网，但其实还是有些网站无法通过此途径访问，那么只能通过付费SS服务、VPN等途径才可以，而本文将要介绍的日本免费Docker，简单搭建免费使用，何乐而不为了 搭建SS arukas.io是岛国推出的Docker服务，开发者可以购买此服务，将代码部署在其中运行。我们从服务价格可以发现目前该服务处于测试阶段完全免费使用，而且我们可以创建多达10个应用，下面我们就开始搭建之旅吧注册:官网地址: https://app.arukas.io/ 进行用户注册，如果你有github账号的话推荐使用github进行登录绕过注册环节，如果没有，那你就还是老老实实注册吧创建app:点击左侧控制面板的Create新建一个app，然后在右边的创建面板对应输入: 属性 值 App Name 随便取 Image oddrationale/docker-shadowsocks Instances 不用管，默认1即可 Memory 512，免费的当然越大越好 Endpoint 不用管，不填写 Port 端口，8888 ENV 不用管，不勾选 CMD ssserver -p 8888 -k luckywcn -m aes-256-cfb","text":"之前 Chrome插件分享 一文中文章最末分享过通过修改hosts文件科学上网，但其实还是有些网站无法通过此途径访问，那么只能通过付费SS服务、VPN等途径才可以，而本文将要介绍的日本免费Docker，简单搭建免费使用，何乐而不为了 搭建SS arukas.io是岛国推出的Docker服务，开发者可以购买此服务，将代码部署在其中运行。我们从服务价格可以发现目前该服务处于测试阶段完全免费使用，而且我们可以创建多达10个应用，下面我们就开始搭建之旅吧注册:官网地址: https://app.arukas.io/ 进行用户注册，如果你有github账号的话推荐使用github进行登录绕过注册环节，如果没有，那你就还是老老实实注册吧创建app:点击左侧控制面板的Create新建一个app，然后在右边的创建面板对应输入: 属性 值 App Name 随便取 Image oddrationale/docker-shadowsocks Instances 不用管，默认1即可 Memory 512，免费的当然越大越好 Endpoint 不用管，不填写 Port 端口，8888 ENV 不用管，不勾选 CMD ssserver -p 8888 -k luckywcn -m aes-256-cfb 其中-p表示内网端口，8888为你设置的端口号，-k表示密码，luckyw为我设置的密码也即我的域名，你的密码可随意设置，配置SS需要用到，-m表示加密方式，我们选择aes-256-cfb以防我说的这么明白还是有人不理解，特意上一张配置图解:配置好了我们启动服务显示Deploying...，等待几分钟显示Running之后，首先查看自己刚才创建的app的配置信息，那接下来我们开始对SS客户端进行配置，填入对应的项即可app配置信息:配置SSSS安装教程请绕道github搜索关键词:因为是从日本直连国内，从下图可以看到延迟还是很低的结果最后我们看下是否真的成功了，恭喜success:","categories":[{"name":"SS","slug":"SS","permalink":"https://blog.luckyw.cn/categories/SS/"}],"tags":[{"name":"SS","slug":"SS","permalink":"https://blog.luckyw.cn/tags/SS/"}],"keywords":[{"name":"SS","slug":"SS","permalink":"https://blog.luckyw.cn/categories/SS/"}]},{"title":"一行代码系列","slug":"one-cmdline","date":"2016-08-27T16:00:00.000Z","updated":"2016-11-20T11:50:26.018Z","comments":true,"path":"2016/08/28/one-cmdline/","link":"","permalink":"https://blog.luckyw.cn/2016/08/28/one-cmdline/","excerpt":"1、一行代码可视化CSS盒子布局 1[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;) 源码解读 首先我们把代码格式化一下:12345[].forEach.call($$(&quot;*&quot;), function(a)&#123; a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16) &#125;) 1、选取页面所有DOM元素$$()相当于document.querySelectorAll()，返回的是一个NodeList对象数组，现代浏览器几乎都支持","text":"1、一行代码可视化CSS盒子布局 1[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;) 源码解读 首先我们把代码格式化一下:12345[].forEach.call($$(&quot;*&quot;), function(a)&#123; a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16) &#125;) 1、选取页面所有DOM元素$$()相当于document.querySelectorAll()，返回的是一个NodeList对象数组，现代浏览器几乎都支持2、循环遍历DOM元素$$(&quot;*&quot;)将所有的DOM元素转化为NodeList对象，但这并不是一个JS数组，所以不能直接使用$$(&quot;*&quot;).forEach()方法来进行迭代，但是我们可以通过call或apply方法来使用forEach[].forEach.call等价于Array.prototype.forEach.call，不过前者字节数更少3、给元素添加outline为什么不使用border而是使用outline的原因在于:border在CSS盒子模型之内，会影响页面的整体布局，而outline在CSS盒子模型之外，不会影响到页面的布局4、生成随机颜色函数1(~~(Math.random()*(1&lt;&lt;24))).toString(16) 随机颜色区间: 最小:000000,转为十进制为0最大:ffffff,转为十进制为256*256*256 = 16777216 = (1&lt;&lt;24) Math.random()返回0~1的浮点数，Math.random()*(1&lt;&lt;24)返回的的即是(0,16777216)之间的浮点数,使用~~去除浮点数的小数部分，再通过toString(16)就转化为十六进制的颜色值了 效果图 原文链接:https://gist.github.com/addyosmani/fd3999ea7fce242756b1 2、一行能装B的JS代码 1(!(~+[])+&#123;&#125;)[--[~+&quot;&quot;][+[]]*[~+[]]+~~!+[]]+(&#123;&#125;+[])[[~!+[]]*~+[]] 上面一行神奇的代码，执行效果却出人意料，请看下图: 源码解读 主要涉及到的知识点是JS运算的优先级以及JS的类型转换补充知识:~按位取反运算，进行类型转换，转换成数字，作用是取负然后减1，会自动去掉小数位~~位运算符，进行类型转换，转换成数字，等同于Math.floor()，将浮点数变成整数首先我们看(!(~+[])+{})+[] =&gt; +&quot;&quot; =&gt; 0~+[] =&gt; -1!(~+[]) =&gt; false(!(~+[])+{}) =&gt; &quot;false[object Object]&quot;接着看[--[~+&quot;&quot;][+[]]*[~+[]]+~~!+[]][+[]] =&gt; [0][~+&quot;&quot;] =&gt; [~0] =&gt; [-1][~+&quot;&quot;][+[]] =&gt; [-1][0]=&gt;-1--[~+&quot;&quot;][+[]] =&gt; -2[~+[]] =&gt; [-1]--[~+&quot;&quot;][+[]]*[~+[]] =&gt; -2*[-1] =&gt; 2~~!+[] =&gt; ~~!0 =&gt; ~~true =&gt; 1[--[~+&quot;&quot;][+[]]*[~+[]]+~~!+[]] =&gt; [2+1] =&gt; [3]这样左侧(!(~+[])+{})[--[~+&quot;&quot;][+[]]*[~+[]]+~~!+[]] =&gt; &quot;false[object Object]&quot;[3] =&gt; &quot;s&quot;再看右侧({}+[])[[~!+[]]*~+[]]({}+[]) =&gt; &quot;[object Object]&quot;[~!+[]] =&gt; [~!0] =&gt; [~true] =&gt; [-2]~+[] =&gt; -1[[~!+[]]*~+[]] =&gt; [[-2]*-1] =&gt; [2]({}+[])[[~!+[]]*~+[]] =&gt; &quot;[object Object]&quot;[2] =&gt; &quot;b&quot; 代码皆来源于网络，非原创，此页专为收罗网上遇到的优秀代码并加以解读","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"Ubuntu16.04搭建LAMP环境","slug":"ubuntu-lamp","date":"2016-08-20T16:00:00.000Z","updated":"2016-11-20T11:08:41.402Z","comments":true,"path":"2016/08/21/ubuntu-lamp/","link":"","permalink":"https://blog.luckyw.cn/2016/08/21/ubuntu-lamp/","excerpt":"LAMP简介 L:Linux操作系统A:Apache网页服务器M:Mysql数据库管理系统P:Php脚本语言 注:以下开始进行的是分步安装，如果你想一步安装请跳过，拉到页面底部，当然你得首先安装好自己的Linux系统 安装Linux服务器 如果你自己装过虚拟机或者有更好的安装技巧可跳过，这只是博主自己安装的方法此安装方式操作的是Ubuntu16.04下通过VirtualBox虚拟机管理软件安装Deepin 15.3，其它系统基本类似，安装步骤如下: 首先从深度系统官网下载镜像文件iso，深度官网，一个很不错的debian衍生版本，而且还是国产，必须得支持啊 选择新建，名字随便取，类型选择linux，版本选择Debian(64 bit)，其它直接下一步，最后点击创建即可 选择刚才新建的虚拟机，点击设置，在显示项把显存大小拉到最大，接着选择存储项，点击控制器下的碟片图标，在右侧属性栏中分配光驱的右侧的碟片图标点击出现下拉菜单，选择选择一个虚拟光盘文件……，此时选择你下载好的镜像文件iso，选择网络项，连接方式选择桥接网卡，点击确定按钮提交你的修改 安装系统:选择新建的虚拟机，点击菜单栏的启动按钮，这时系统的安装就开始了，系统如何安装我就不赘述了，也是一步一步下一步，最后出现安装成功，提示重启的信息时，把步骤2中刚才加载的镜像文件从虚拟机移出虚拟盘，重新启动虚拟机，此时系统安装完成 上一张安装好的美图:","text":"LAMP简介 L:Linux操作系统A:Apache网页服务器M:Mysql数据库管理系统P:Php脚本语言 注:以下开始进行的是分步安装，如果你想一步安装请跳过，拉到页面底部，当然你得首先安装好自己的Linux系统 安装Linux服务器 如果你自己装过虚拟机或者有更好的安装技巧可跳过，这只是博主自己安装的方法此安装方式操作的是Ubuntu16.04下通过VirtualBox虚拟机管理软件安装Deepin 15.3，其它系统基本类似，安装步骤如下: 首先从深度系统官网下载镜像文件iso，深度官网，一个很不错的debian衍生版本，而且还是国产，必须得支持啊 选择新建，名字随便取，类型选择linux，版本选择Debian(64 bit)，其它直接下一步，最后点击创建即可 选择刚才新建的虚拟机，点击设置，在显示项把显存大小拉到最大，接着选择存储项，点击控制器下的碟片图标，在右侧属性栏中分配光驱的右侧的碟片图标点击出现下拉菜单，选择选择一个虚拟光盘文件……，此时选择你下载好的镜像文件iso，选择网络项，连接方式选择桥接网卡，点击确定按钮提交你的修改 安装系统:选择新建的虚拟机，点击菜单栏的启动按钮，这时系统的安装就开始了，系统如何安装我就不赘述了，也是一步一步下一步，最后出现安装成功，提示重启的信息时，把步骤2中刚才加载的镜像文件从虚拟机移出虚拟盘，重新启动虚拟机，此时系统安装完成 上一张安装好的美图: 配置SSH 12$ sudo apt install ssh //安装ssh服务$ sudo service ssh restart //重启ssh服务 这时我们可以通过主机打开终端连接虚拟机系统进行接下来软件的安装，连接虚拟机代码如下，接着输入你设置的用户密码:123$ ssh username@ip_address//username为你的虚拟机的用户名//ip_address为你的虚拟机的ip，ubuntu用户可通过右上角标题栏的网络连接，选择连接信息可以找到 安装Apache 安装代码:1$ sudo apt install apache2 我们可以在终端输入apache2 -v查看apache是否安装成功安装成功之后，浏览器打开 http://localhost 之后可以看到apache成功安装的输出信息了，如下图:apache的默认目录为/var/www/，我们可以修改为我们自己的文件目录，方便操作更改默认目录:12345678910sudo vim /etc/apache2/apache2.conf将&lt;Directory /var/www/&gt;修改为&lt;Directory &apos;你的目录&apos;&gt;sudo vim /etc/apache2/sites-available/000-default.conf将DocumentRoot /var/www/修改为DocumentRoot &apos;你的目录&apos;启用 mod_rewrite 模块sudo a2enmod rewrite重启apache服务sudo service apache2 restart 安装Php 因为Ubuntu16.04默认php版本就是php7，如果想安装php5的朋友，请自行谷歌，安装代码如下:12$ sudo apt install php //安装php$ sudo service apache2 restart //重启apache服务 我们通过在终端输入php -v查看php是否安装成功接着我们查看libphp7.0.so是否成功加载，输入cat /etc/apache2/mods-enabled/php7.0.load，加载成功如下图所示:如果找不到该文件的话，我们需要执行下面这行命令安装:1sudo apt install libapache2-mod-php7.0 我们在刚才修改的默认目录下新建一个info.php文件，写入以下代码:12&lt;?phpphpinfo(); 浏览器打开 http://localhost/info.php 查看php信息是否成功输出效果图如下:Ubuntu的php环境默认是不报错的，但我们处于开发模式时希望能有错误信息显示12345671、修改php配置文件php.inisudo gedit /etc/php/7.0/apache2/php.ini把 display_errors = Off 改为 display_errors = On把 error_reporting = xxx 改为 error_reporting = E_ALL | E_STRICT2、重启apachesudo service apache2 restart 安装Mysql 安装代码:12$ sudo apt install mysql-server //安装过程需要输入mysql管理员密码，重复输入即可$ sudo apt install php-mysql //为php安装mysql的扩展 Mysql数据库访问，终端输入:1$ mysql -hlocalhost -uroot -p -h:主机，省略则默认localhost-u:用户名，默认账户为root-p:密码，建议不直接输入在-p之后show databases; :显示数据库use somedb; :选择使用某个数据库show tables; :显示数据表 启动、重启、停止Mysql的命令:1sudo service mysql start/restart/stop 安装phpmyadmin1sudo apt install phpmyadmin 根据提示设置phpmyadmin root账户密码，然后重启apache服务，打开 http://localhost/phpmyadmin 查看是否安装成功Mysql可视化界面 MySQL Workbench我们测试下是否可以成功连接到mysql，在修改的目录下新建mysql.php文件，代码如下:1234567&lt;?php$conn = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;yourpassword&quot;);if($conn)&#123; echo &quot;suceesss&quot;;&#125;else&#123; echo &quot;fail&quot;;&#125; 在浏览器输入 http://localhost/mysql.php 可以发现输出了success，至少我是这样，如果你不是，那google会是你的好帮手 套件安装 tasksel方式安装首先我们需要安装tasksel1$ sudo apt install tasksel 接着我们通过tasksel安装LAMP套件，方便省事，没上面那么复杂，有两种方式安装:12$ tasksel //之后会进入选择界面，选择lamp-server确定即可$ tasksel install lamp-server //直接安装 apt-get方式安装1sudo apt install lamp-server^ 注:别忘了最后这个符号^，否则终端会报无法定位软件包的错误提示","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/tags/Ubuntu/"},{"name":"LAMP","slug":"LAMP","permalink":"https://blog.luckyw.cn/tags/LAMP/"}],"keywords":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}]},{"title":"美女图片站建站总结","slug":"mm","date":"2016-08-13T16:00:00.000Z","updated":"2016-12-11T08:14:43.565Z","comments":true,"path":"2016/08/14/mm/","link":"","permalink":"https://blog.luckyw.cn/2016/08/14/mm/","excerpt":"俗话说的好，不爱美女的程序员不是一个好司机！mm网:https://mm.luckyw.cn/妹子图:https://mzt.luckyw.cn/煎蛋美女:https://jd.luckyw.cn/ 这几天一直在菜鸟教程学习php和mysql，想总结一下自己的学习成果，so这个mm图片站也就这么自然而然地出来了，主要使用了图片瀑布流、ajax加载数据，php页面静态化、图片分页等方法进行实现 2016-10-12 更新 瀑布流加载方式已改为采用jquery插件waterfall，以及接口链接已修改 图片瀑布流 我这里分为两种瀑布流方法，第一种方式(首页静态化页面index.html):先获取所有的图片盒子boxes，每个图片盒子的宽度box_w，文档的宽度W，从而得到列数num，然后设置容器$(&#39;#imgBox&#39;)的宽度为列数 × 每个图片盒子的宽度。然后定义一个数组arr存储每列的高度，对所有图片盒子进行遍历，如果此时索引小于列数，则把这个图片盒子的高度添加到盒子中，如果此时索引大于列数，那么先获取数组arr中高度最短minH的那一列的索引minIndex，然后定义图片盒子在容器中的位置，因为我的容器imgBox已经定义了position:relative，设置图片盒子为position:absolute则相对于容器进行绝对定位，并设置图片盒子的left和top值，之后再把数组中最低高度那一列的值加上这个图片盒子的高度，此时即实现了图片瀑布流效果，随页面滚动触发ajax加载数据，之后一个一个把图片盒子添加到容器中去12345678910111213141516171819202122232425262728293031function waterfall() &#123; var boxes = $(&apos;.box&apos;); var box_w = boxes.eq(0).outerWidth(true); var W = document.body.clientWidth || document.documentElement.clientWidth; var num = Math.floor(W / box_w); //5 $(&apos;#imgBox&apos;).width(num * box_w); $(&apos;.w&apos;).width(num * box_w); var arr = []; boxes.each(function(index, ele) &#123; var h = $(ele).outerHeight(true); if (index &lt; num) &#123; arr.push(h); &#125; else &#123; var minH = Math.min.apply(null, arr); var minIndex = getMinIndex(arr, minH); $(ele).css(&#123; &apos;position&apos;: &apos;absolute&apos;, &apos;left&apos;: box_w * minIndex, &apos;top&apos;: minH &#125;); arr[minIndex] += h; &#125; &#125;);&#125;function getMinIndex(arr, h) &#123; for (var i in arr) &#123; if (arr[i] == h) &#123; return i; &#125; &#125;&#125;","text":"俗话说的好，不爱美女的程序员不是一个好司机！mm网:https://mm.luckyw.cn/妹子图:https://mzt.luckyw.cn/煎蛋美女:https://jd.luckyw.cn/ 这几天一直在菜鸟教程学习php和mysql，想总结一下自己的学习成果，so这个mm图片站也就这么自然而然地出来了，主要使用了图片瀑布流、ajax加载数据，php页面静态化、图片分页等方法进行实现 2016-10-12 更新 瀑布流加载方式已改为采用jquery插件waterfall，以及接口链接已修改 图片瀑布流 我这里分为两种瀑布流方法，第一种方式(首页静态化页面index.html):先获取所有的图片盒子boxes，每个图片盒子的宽度box_w，文档的宽度W，从而得到列数num，然后设置容器$(&#39;#imgBox&#39;)的宽度为列数 × 每个图片盒子的宽度。然后定义一个数组arr存储每列的高度，对所有图片盒子进行遍历，如果此时索引小于列数，则把这个图片盒子的高度添加到盒子中，如果此时索引大于列数，那么先获取数组arr中高度最短minH的那一列的索引minIndex，然后定义图片盒子在容器中的位置，因为我的容器imgBox已经定义了position:relative，设置图片盒子为position:absolute则相对于容器进行绝对定位，并设置图片盒子的left和top值，之后再把数组中最低高度那一列的值加上这个图片盒子的高度，此时即实现了图片瀑布流效果，随页面滚动触发ajax加载数据，之后一个一个把图片盒子添加到容器中去12345678910111213141516171819202122232425262728293031function waterfall() &#123; var boxes = $(&apos;.box&apos;); var box_w = boxes.eq(0).outerWidth(true); var W = document.body.clientWidth || document.documentElement.clientWidth; var num = Math.floor(W / box_w); //5 $(&apos;#imgBox&apos;).width(num * box_w); $(&apos;.w&apos;).width(num * box_w); var arr = []; boxes.each(function(index, ele) &#123; var h = $(ele).outerHeight(true); if (index &lt; num) &#123; arr.push(h); &#125; else &#123; var minH = Math.min.apply(null, arr); var minIndex = getMinIndex(arr, minH); $(ele).css(&#123; &apos;position&apos;: &apos;absolute&apos;, &apos;left&apos;: box_w * minIndex, &apos;top&apos;: minH &#125;); arr[minIndex] += h; &#125; &#125;);&#125;function getMinIndex(arr, h) &#123; for (var i in arr) &#123; if (arr[i] == h) &#123; return i; &#125; &#125;&#125; 第二种方式(图片分页):基本和上面差不多，也是获取所有的图片盒子boxes，每个图片盒子的宽度box_w，文档的宽度W，从而得到列数num，然后设置容器$(&#39;#imgBox&#39;)的宽度为列数 × 每个图片盒子的宽度。不过不同的是，我这里采用定义num个列div盒子，设置它的宽为图片盒子的宽度box_w，display为inline-block，然后添加到容器中去，之后把所有的图片盒子从dom中删去然后一个一个地追加到最短的那一列中去 ajax加载数据 我这里是采用python从网上抓取图片链接，然后保存到mysql数据库中，然后设计一个接口访问这些数据，接口链接:https://luckyw.cn/api/load_img.php?start=0&amp;num=10当页面滚动时触发ajax加载数据的方法，此时ajax通过接口请求数据，然后把一个一个的图片盒子添加到容器中去，再应用图片瀑布流即达到了瀑布流加载图片的效果，ajax请求图片数据的代码如下:1234567891011121314151617181920212223242526272829303132/** * ajax请求图片数据 * @param s:开始位置 * @param n:每页数 */function ajax(s, n) &#123; $.ajax(&#123; url: &apos;http://luckyw.cn/api/load_img.php?start=&apos; + s + &apos;&amp;num=&apos; + n, method: &apos;GET&apos;, dataType: &quot;json&quot;, success: function(data) &#123; var imgs = data.list; for (var i in imgs) &#123; var box = $(&apos;&lt;div&gt;&apos;).addClass(&apos;box&apos;); var a = $(&apos;&lt;a&gt;&apos;).attr(&#123; &apos;href&apos;: imgs[i][&apos;src&apos;], &apos;target&apos;: &apos;_blank&apos; &#125;).addClass(&apos;item&apos;); var img = $(&apos;&lt;img&gt;&apos;).attr(&apos;src&apos;, imgs[i][&apos;src&apos;]); a.append(img); box.append(a); $(&apos;#imgBox&apos;).append(box); &#125; start += num; loading = false; waterfall(); &#125;, error: function(err) &#123; if (err) console.log(err); &#125; &#125;);&#125; php页面静态化 这里我只简单说下原理:是利用了php的缓存机制output_buffering，然后把使用file_put_contents把缓存写到文件中去，从而实现页面静态化，关键代码如下:12345678//index.php文件ob_start();//如果`php.ini`没有打开缓存，这里打开缓存require_once (&apos;temp.php&apos;); //加载模板文件if(file_put_contents(&apos;index.html&apos;,ob_get_clean()))&#123;//把缓存写入到文件中并清空缓存 header(&quot;location: index.html&quot;);//这里是实现页面跳转到静态文件&#125;else&#123; echo &apos;error&apos;;&#125; 之后我们每次访问index.php文件就会生成并跳转到index.html静态化文件了 图片分页 这里基本和接口差不多类似，接口是返回数据，而这里是根据url地址后面所跟的参数查找到数据，并把数据用盒子包装起来直接添加到容器中去，关键的是分页的实现，理清逻辑很好理解，在此我就不详述了，简单看下代码:123456789101112131415161718192021222324252627282930313233343536373839$start = 1;$end = $totalPage;$showPageNum = 5;$pageOffset = ($showPageNum-1)/2;$page_navigation = &apos;&apos;;if($page&gt;1)&#123; $page_navigation.=&quot;&lt;a href=&apos;&quot;.$_SERVER[&apos;PHP_SELF&apos;].&quot;&apos;&gt;首页&lt;/a&gt;&quot;; $page_navigation.=&quot;&lt;a href=&apos;&quot;.$_SERVER[&apos;PHP_SELF&apos;].&quot;?page=&quot;.($page-1).&quot;&apos;&gt;&lt;上一页&lt;/a&gt;&quot;;&#125;if($totalPage&gt;$showPageNum)&#123; if($page&gt;$pageOffset+1)&#123; $page_navigation .= &apos;...&apos;; &#125; if($page&gt;$pageOffset)&#123; $start = $page-$pageOffset; $end = $totalPage&gt;$page+$pageOffset?$page+$pageOffset:$totalPage; &#125;else&#123; $start = 1; $end = $showPageNum; &#125; if($page+$pageOffset&gt;$totalPage)&#123; $start = $start - ($page+$pageOffset-$end); &#125;&#125;for($i=$start;$i&lt;=$end;$i++)&#123; if($i==$page)&#123; $page_navigation.=&quot;&lt;span class=&apos;active&apos;&gt;$i&lt;/span&gt;&quot;; &#125;else&#123; $page_navigation.=&quot;&lt;a href=&apos;&quot;.$_SERVER[&apos;PHP_SELF&apos;].&quot;?page=&quot;.$i.&quot;&apos;&gt;$i&lt;/a&gt;&quot;; &#125;&#125;if($totalPage&gt;$showPageNum&amp;&amp;$totalPage&gt;$page+$pageOffset)&#123; $page_navigation.=&apos;...&apos;;&#125;if($page&lt;$totalPage)&#123; $page_navigation.=&quot;&lt;a href=&apos;&quot;.$_SERVER[&apos;PHP_SELF&apos;].&quot;?page=&quot;.($page+1).&quot;&apos;&gt;下一页&amp;gt;&lt;/a&gt;&quot;; $page_navigation.=&quot;&lt;a href=&apos;&quot;.$_SERVER[&apos;PHP_SELF&apos;].&quot;?page=&quot;.$totalPage.&quot;&apos;&gt;尾页&lt;/a&gt;&quot;;&#125;$page_navigation.=&quot;共有&#123;$totalPage&#125;页&quot;;","categories":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/categories/Php/"}],"tags":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/tags/Php/"}],"keywords":[{"name":"Php","slug":"Php","permalink":"https://blog.luckyw.cn/categories/Php/"}]},{"title":"安装Ubuntu 16.04 LTS常用软件","slug":"ubuntu-software-list","date":"2016-08-06T16:00:00.000Z","updated":"2016-12-16T04:19:19.324Z","comments":true,"path":"2016/08/07/ubuntu-software-list/","link":"","permalink":"https://blog.luckyw.cn/2016/08/07/ubuntu-software-list/","excerpt":"Goole Chrome浏览器 Chrome浏览器是目前市面上最流行的web浏览器，而Ubuntu 16.04 LTS版本安装完成之后是没有Chrome浏览器的，只有FireFox浏览器，决定是否安装纯属个人偏好首先，我们先修改下hosts文件，以便我们可以访问google服务，点击打开此链接hosts文件，全选复制，然后打开终端，输入sudo gedit /etc/hosts，然后把里面的内容替换为刚才复制的内容，此时我们在火狐浏览器中打开此官方下载链接chrome，下载安装即可，安装完成之后也可以直接在应用商店下载安装你所需的应用，可参考Chrome插件分享 安装Numix主题及图标主题 直接上代码，打开终端:1234sudo add-apt-repository ppa:numix/ppa //添加numix的仓库源sudo apt update //更新软件源sudo apt install numix-gtk-theme //安装numix主题sudo apt install numix-icon-theme-circle //安装numix circle图标主题 Unity Tweak Tool numix主题安装完成之后，我们需要对其进行配置，默认Ubuntu的启动器是在左边的，我们一般习惯在下边，而Unity Tweak Tool可以很方便帮我们解决上述问题，打开软件中心搜索Unity Tweak Tool进行安装，安装完成之后在dash中打开，具体的配置我就不说了，so easy","text":"Goole Chrome浏览器 Chrome浏览器是目前市面上最流行的web浏览器，而Ubuntu 16.04 LTS版本安装完成之后是没有Chrome浏览器的，只有FireFox浏览器，决定是否安装纯属个人偏好首先，我们先修改下hosts文件，以便我们可以访问google服务，点击打开此链接hosts文件，全选复制，然后打开终端，输入sudo gedit /etc/hosts，然后把里面的内容替换为刚才复制的内容，此时我们在火狐浏览器中打开此官方下载链接chrome，下载安装即可，安装完成之后也可以直接在应用商店下载安装你所需的应用，可参考Chrome插件分享 安装Numix主题及图标主题 直接上代码，打开终端:1234sudo add-apt-repository ppa:numix/ppa //添加numix的仓库源sudo apt update //更新软件源sudo apt install numix-gtk-theme //安装numix主题sudo apt install numix-icon-theme-circle //安装numix circle图标主题 Unity Tweak Tool numix主题安装完成之后，我们需要对其进行配置，默认Ubuntu的启动器是在左边的，我们一般习惯在下边，而Unity Tweak Tool可以很方便帮我们解决上述问题，打开软件中心搜索Unity Tweak Tool进行安装，安装完成之后在dash中打开，具体的配置我就不说了，so easy 搜狗输入法 默认是没有安装搜狗输入法的，虽然Ubuntu Kylin有装，但是我建议不安装，搜狗输入法下载请点，下载安装完成之后如何发现不可用，那么请重启吧 网速监控 Github地址:https://github.com/fossfreedom/indicator-sysmonitor安装123sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitorsudo apt updatesudo apt install indicator-sysmonitor 安装完成之后输入indicator-sysmonitor &amp;回车，之后按Ctrl+C，继续输入exit退出控制台，这时此工具就在后台运行了开机启动鼠标左击标题栏该工具图标，弹出下拉菜单选择Preferences，勾选上Run on startup，此时该工具就会开机自动启动了，如下图所示:切换到Advanced选项，可以对要显示的信息的格式进行设置了，如:我想知道当前网络的上下行速度，就加上网速:{net}即可 网易云音乐 下载链接:http://music.163.com/#/download GIMP 图片编辑器 让我很诧异的是Ubuntu 16.04没有安装这个Linux上的PS，而优麒麟是有的，没办法如果你要处理图像的话还是老老实实从软件商店安装吧，功能实在太强大了 SS客户端 不多解释，FQ必备123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt updatesudo apt install shadowsocks-qt5 2016年8月28日 更新 Shutter 截图神器，虽然Ubuntu自带有截图工具gnome-screenshot,之所以称为神器，是因为它的功能更全，具备编辑图片的功能，比如可以加文字说明、加指示箭头，涂改隐私部分，安装的话软件商店直接搜索即可 Franz 如果你需要在Ubuntu上使用微信的话，可以使用electronic-wechat。但是我推荐使用的是Franz，它不仅支持微信，还支持Slack、Messenger、WhatsApp、Telegram、Skype、Hipchat、ChatWork、Flowdock、Hangouts、GroupMe、Rocket.chat、Mattermost、Grape、Gitter、TweetDeck、DingTalk、Steam Chat、Discord、MySMS、Inbox by Gmail、Gmail、Outlook.com、VK等等，是一个非常全面的汇集众多聊天软件的应用程序，非常适合需要多种服务的人群，而且Windows、Mac和Linux平台都支持使用。使用非常简单，只需要去官网下载安装包进行解压然后执行主程序文件，在程序中添加你所要的服务输入账户密码即可，之后再添加到Dash面板中方便使用 2016-11-16更新 系统负载指示器 1234sudo add-apt-repository ppa:indicator-multiload/stable-dailysudo apt updatesudo apt install indicator-multiloadindicator-multiload","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/tags/Ubuntu/"}],"keywords":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}]},{"title":"使用nodejs发送邮件","slug":"nodejs-mailer","date":"2016-08-04T16:00:00.000Z","updated":"2016-11-20T11:03:59.450Z","comments":true,"path":"2016/08/05/nodejs-mailer/","link":"","permalink":"https://blog.luckyw.cn/2016/08/05/nodejs-mailer/","excerpt":"最近一些天在学python，我觉得这门语言这门简单又很好玩，为什么不把这门语言当做程序员学语言的敲门砖了，而选择那么复杂的C语言。在学python的过程中，有学习到python有可以发送邮件的功能，我就在想node会不会也有发送邮件的模块工具了，果不其然，让我找到一个，也就是本文所要介绍到的nodemailer了，npm官方地址:https://www.npmjs.com/package/nodemailer python发送邮件简单实现 不多说，直接看代码:1234567891011121314151617181920212223#-*-coding:utf8-*-import smtplibfrom email.mime.text import MIMETextmail_host=&apos;smtp.126.com&apos; //设置主机，如果是QQ请换成smtp.qq.commail_user=&apos;xxxxxxxx@126.com&apos; //账户mail_pass = &apos;这里填入授权码，下面会说到&apos; //邮箱授权码，非密码me = &apos;Leo Angel&apos;+&apos;&lt;&apos;+mail_user+&apos;&gt;&apos; //发件人to = &apos;xxxxxxxxx@qq.com&apos; //收件人msg = MIMEText(&quot;Test&quot;,_subtype=&apos;plain&apos;,_charset=&apos;utf-8&apos;)msg[&apos;Subject&apos;] = &apos;Hello&apos; //主题msg[&apos;From&apos;] = me //发件人msg[&apos;To&apos;] = to //收件人try: server = smtplib.SMTP() //创建一个SMTP对象 server.connect(mail_host) //连接主机 server.login(mail_user,mail_pass) //登录账号 server.sendmail(me,to,msg.as_string()) //发送邮件 server.close() //关闭SMTP对象 print &apos;邮件发送成功&apos; //打印发送成功提示信息except Exception as e: print e //打印错误日志","text":"最近一些天在学python，我觉得这门语言这门简单又很好玩，为什么不把这门语言当做程序员学语言的敲门砖了，而选择那么复杂的C语言。在学python的过程中，有学习到python有可以发送邮件的功能，我就在想node会不会也有发送邮件的模块工具了，果不其然，让我找到一个，也就是本文所要介绍到的nodemailer了，npm官方地址:https://www.npmjs.com/package/nodemailer python发送邮件简单实现 不多说，直接看代码:1234567891011121314151617181920212223#-*-coding:utf8-*-import smtplibfrom email.mime.text import MIMETextmail_host=&apos;smtp.126.com&apos; //设置主机，如果是QQ请换成smtp.qq.commail_user=&apos;xxxxxxxx@126.com&apos; //账户mail_pass = &apos;这里填入授权码，下面会说到&apos; //邮箱授权码，非密码me = &apos;Leo Angel&apos;+&apos;&lt;&apos;+mail_user+&apos;&gt;&apos; //发件人to = &apos;xxxxxxxxx@qq.com&apos; //收件人msg = MIMEText(&quot;Test&quot;,_subtype=&apos;plain&apos;,_charset=&apos;utf-8&apos;)msg[&apos;Subject&apos;] = &apos;Hello&apos; //主题msg[&apos;From&apos;] = me //发件人msg[&apos;To&apos;] = to //收件人try: server = smtplib.SMTP() //创建一个SMTP对象 server.connect(mail_host) //连接主机 server.login(mail_user,mail_pass) //登录账号 server.sendmail(me,to,msg.as_string()) //发送邮件 server.close() //关闭SMTP对象 print &apos;邮件发送成功&apos; //打印发送成功提示信息except Exception as e: print e //打印错误日志 开启SMTP服务 我以QQ邮箱和126邮箱举例:QQ邮箱:首先打开你的QQ邮箱，点击设置，选择邮箱设置第二项帐户，鼠标下拉到POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务，开启第一项POP3/SMTP服务，如下图所示，开启成功后会生成授权码给你，对应代码的pass字段，选择填入即可126邮箱:同QQ邮箱基本一样，登陆之后点击设置下拉菜单POP3/SMTP/IMAP，勾选POP3/SMTP服务，成功之后会生成授权码，填入对应的pass字段 发送邮件代码如下: 首先创建项目文件夹，然后再里面打开终端输入npm install nodemailer --save安装nodemailer模块，新建app.js文件，输入以下代码，最后执行node app，成功之后到你收件人邮箱就可以发现收到了一条新信息123456789101112131415161718192021222324var mail = require(&apos;nodemailer&apos;);//引入nodemailer模块var transport = mail.createTransport(&#123; host:&apos;smtp.qq.com&apos;, //主机，如果是126邮箱，请换成smtp.126.com secureConnection:true, //使用安全连接 port:465, //STMP端口号 auth:&#123; user:&quot;xxxxxxxx@xx.com&quot;, //你的邮箱账号 pass:&quot;填对应邮箱的授权码&quot; //授权码 &#125;&#125;);var options =&#123; from:&apos;&quot;YOURNAME&quot; xxxxxxxx@xx.com&apos;,//YOURNAME将变为你邮件的名字 to:&quot;xxxxxxxx@126.com,xxxxxxxx@qq.com，xxxxxx@gmail.com&quot;,//收件人 subject:&apos;Hello&apos;, //主题 text:&quot;World&quot;, //正文 attachments:[&#123; //附件 filename:&quot;附加文件&quot;, //附件名字 path:&quot;./app.js&quot; //附件路径 &#125;]&#125;;transport.sendMail(options,function (err, res) &#123; if(err) console.log(err); else console.log(res);&#125;);","categories":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/tags/Node/"}],"keywords":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/categories/Node/"}]},{"title":"如何使requests通过socks代理工作","slug":"requests-socks-proxy","date":"2016-07-29T16:00:00.000Z","updated":"2016-11-20T11:06:46.978Z","comments":true,"path":"2016/07/30/requests-socks-proxy/","link":"","permalink":"https://blog.luckyw.cn/2016/07/30/requests-socks-proxy/","excerpt":"","text":"前言 鉴于国内的网络环境，想爬取一些被墙的网站，只能通过代理或其他方式，而我使用的是SS代理，SS使用的是socks5代理方式，而requests爬取网站内容的时候是不支持socks代理的，那么如何使requests通过socks代理工作？其实，我们发现在2016-04-29发布的requests 2.10.0版本中，提供了对socks代理工作的支持，前提是需要安装PySocks，安装代码如下:1$ pip install pysocks 用法 123456import requestsproxies = &#123; &apos;http&apos;:&apos;socks5://yourproxy:port&apos;, &apos;https&apos;:&apos;socks5://yourproxy:port&apos;&#125;requests.get(url,proxies=proxies)","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.luckyw.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.luckyw.cn/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://blog.luckyw.cn/categories/Python/"}]},{"title":"爬取并下载妹子图网站图片","slug":"mzitu","date":"2016-07-24T16:00:00.000Z","updated":"2016-11-20T11:03:21.898Z","comments":true,"path":"2016/07/25/mzitu/","link":"","permalink":"https://blog.luckyw.cn/2016/07/25/mzitu/","excerpt":"github地址 : https://github.com/leoyaojy/mzitu 主要分为三个版本: 单页版、单图版、全图版 运行环境 Ubuntu 16.04 Python 2.7.12 Pycharm 2016.2 使用方法 1git clone https://github.com/leoyaojy/mzitu.git 1cd mzitu 1python page.py | single.py | full.py","text":"github地址 : https://github.com/leoyaojy/mzitu 主要分为三个版本: 单页版、单图版、全图版 运行环境 Ubuntu 16.04 Python 2.7.12 Pycharm 2016.2 使用方法 1git clone https://github.com/leoyaojy/mzitu.git 1cd mzitu 1python page.py | single.py | full.py 单页版 主要是针对妹子图每一页的图片进行下载，比如:http://www.mzitu.com/page/1此类链接的图片进行下载，我在代码中设置的是获取前四页的内容，即代码:for i in range(1, 5),如果你想下载全站的图片，请修改5为对应的最大页码 + 1，测试效果如下图: 单图版 主要是针对妹子图每个套图的第一张图片进行下载，比如:http://www.mzitu.com/69627此类链接的图片进行下载，我在代码中设置的是获取前四页套图的第一张图片，即代码:for i in range(1, 5),如果你想下载全站的图片，请修改5为对应的最大页码 + 1，测试效果如下图: 全图版 主要是针对妹子图每个套图的全部图片进行下载，由于套图数量过多，我只设置下载第一页的所有套图，即代码:for i in range(1, 2),如果你想下载全站的图片，请修改2为对应的最大页码 + 1，测试效果如下图:","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.luckyw.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.luckyw.cn/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://blog.luckyw.cn/categories/Python/"}]},{"title":"CSS content属性介绍","slug":"css-content-intro","date":"2016-07-16T16:00:00.000Z","updated":"2016-11-20T09:35:19.114Z","comments":true,"path":"2016/07/17/css-content-intro/","link":"","permalink":"https://blog.luckyw.cn/2016/07/17/css-content-intro/","excerpt":"CSS中主要的伪元素有四个:before、after、first-letter、first-line在before、after伪元素选择器中，常用来清除浮动，有一个content属性，能够实现页面中的内容插入 纯文本插入 效果如下:代码如下:12345678910/*css*/h1:after&#123; content: &quot; World&quot;&#125;h2:before&#123; content: &quot;Leo &quot;&#125;&lt;!-- html --&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;h2&gt;Angel&lt;/h2&gt;","text":"CSS中主要的伪元素有四个:before、after、first-letter、first-line在before、after伪元素选择器中，常用来清除浮动，有一个content属性，能够实现页面中的内容插入 纯文本插入 效果如下:代码如下:12345678910/*css*/h1:after&#123; content: &quot; World&quot;&#125;h2:before&#123; content: &quot;Leo &quot;&#125;&lt;!-- html --&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;h2&gt;Angel&lt;/h2&gt; 插入文字符号 可以使用content属性的open-quote属性值和close-quote属性值在字符串两边添加诸如括号、单引号、双引号之类的嵌套文字符号。open-quote用于添加开始的文字符号，close-quote用于添加结束的文字符号，效果如下:代码如下:12345678910111213141516/*css*/h1&#123; quotes: &quot;(&quot; &quot;)&quot;;&#125;h2&#123; quotes: &quot;[&quot; &quot;]&quot;;&#125;h1:before,h2:before&#123; content: open-quote;&#125;h1:after,h2:after&#123; content: close-quote;&#125;&lt;!-- html --&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;h2&gt;Leo Angel&lt;/h2&gt; 插入图片 content可以在元素前|后插入图片，效果如下:代码如下:123456/*css*/h3:before,h3:after&#123; content: url(&quot;http://localhost:4000/css/images/logo.jpg&quot;);&#125;&lt;!-- html --&gt;&lt;h3&gt;Picture&lt;/h3&gt; 插入元素的属性值 content属性可以直接利用attr获取元素的属性，将其插入到对应位置代码如下:123456/*css*/a:after&#123; content:attr(href);&#125;&lt;!-- html --&gt;&lt;a href=&quot;https://luckyw.cn&quot;&gt;Home&lt;/a&gt; 暂时介绍这么多，这些比较常用，以后有见到别的再整理到这里","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"CSS制作小三角","slug":"css-triangle","date":"2016-07-09T16:00:00.000Z","updated":"2016-11-20T10:45:45.923Z","comments":true,"path":"2016/07/10/css-triangle/","link":"","permalink":"https://blog.luckyw.cn/2016/07/10/css-triangle/","excerpt":"原理 CSS盒模型 盒模型 = Margin + Border + Padding + Content 上下左右边框交界处出呈现平滑的斜线. 利用这个特点, 通过设置不同的上下左右边框宽度或者颜色可以得到小三角, 小梯形等 调整宽度大小可以调节三角形形状","text":"原理 CSS盒模型 盒模型 = Margin + Border + Padding + Content 上下左右边框交界处出呈现平滑的斜线. 利用这个特点, 通过设置不同的上下左右边框宽度或者颜色可以得到小三角, 小梯形等 调整宽度大小可以调节三角形形状 示例1 通常情况下，我们设置盒子的宽高度及上下左右边框，会呈现四周红绿蓝灰，而且相邻交界处有平滑的斜线，如下图所示:代码如下:1234567.test&#123; width: 20px; height: 20px; border-width: 20px; border-color: #f00 #0f0 #00f #ccc; border-style: solid;&#125; 示例2 在上面基础上，把宽高都设为0，效果如下:代码如下:12345678910.test&#123; width: 0; height: 0; font-size:0; line-height:0; overflow:hidden; border-width: 20px; border-color: #f00 #0f0 #00f #ccc; border-style: solid;&#125; 之所以设置overflow，font-size，line-height是因为，在IE6会有默认的字体大小和行高，导致盒子呈现为被撑开的长矩形此时我们可以看到4个带颜色的三角形了，如果我们把4个颜色只保留一个颜色，其他三个颜色设为transparent，那一个小三角不就出来了嘛 示例3 把上右下边框颜色设为transparent之后效果如下:代码如下:12345678910.test&#123; width: 0; height: 0; font-size:0; line-height:0; overflow:hidden; border-width: 20px; border-color: transparent transparent transparent #ccc; border-style: solid;&#125; 但是，IE6不支持透明，so～～: 示例4 上个例子提到的IE兼容性怎么处理了？其实很简单，设置其他三条边边框样式border-style:dashed | dotted即可达到透明的效果，具体原因如下: IE6不支持transparent属性,而间接设置对应的透明边框的border-style属性为dotted或dashed即可解决这一问题,原因是在IE6下, 点线与虚线均以边框宽度为基准,点线长度必须是其宽度的3倍以上（height&gt;=border-width*3）,虚线宽长度必须是其宽度的5倍以上（height&gt;=border-width*5）,否则点线和虚线都不会出现 代码如下:12345678910.test &#123; width: 0; height: 0; font-size: 0; line-height: 0; overflow: hidden; border-width: 20px; border-color: transparent transparent transparent #ccc; border-style: dashed dashed dashed solid;&#125; 示例5 之前我们例子中小三角的斜边都是依赖于原来盒子的边，其实还有一种方法，让斜边在盒子的对角线上，如下:代码如下:12345678910.test &#123; width: 0; height: 0; font-size: 0; line-height: 0; overflow: hidden; border-width: 0 40px 40px 0; border-color: transparent red #ccc transparent; border-style: dashed solid solid dashed;&#125; 示例6 结合示例5的例子，我们可以通过构建多个这样类似的小三角做一个气泡聊天的效果:代码如下:123456789101112131415161718192021222324252627282930313233343536.test &#123; width: 400px; padding: 30px; margin-left: 60px; background-color: #369; color: #fff; font-family: &quot;DejaVu Sans Mono&quot;; position: relative;&#125;.test:before,.test:after &#123; content: &quot;&quot;; position: absolute; width: 0; height: 0; font-size: 0; line-height: 0; overflow: hidden;&#125;.test:before &#123; border-width: 20px; border-style: solid; border-color: #fff #369 #369 #fff; left: -40px; top: 40px;&#125;.test:after &#123; border-width: 10px 20px; border-style: dashed solid solid dashed; border-color: transparent #fff #fff transparent; left: -40px; top: 60px;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"http状态码汇总","slug":"http-status-code","date":"2016-07-03T16:00:00.000Z","updated":"2016-11-20T10:57:24.256Z","comments":true,"path":"2016/07/04/http-status-code/","link":"","permalink":"https://blog.luckyw.cn/2016/07/04/http-status-code/","excerpt":"1XX 信息 这一类型的状态码，代表请求已被接受，需要继续处理 状态码 状态文本 信息 100 Continue 客户端应当继续发送请求 101 Switching Protocols 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求 2XX 成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受 状态码 状态文本 信息 200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回 202 Accepted 服务器已接受请求，但尚未处理 203 Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝 204 No Content 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息 205 Reset Content 服务器成功处理了请求，且没有返回任何内容 206 Partial Content 服务器已经成功处理了部分GET请求","text":"1XX 信息 这一类型的状态码，代表请求已被接受，需要继续处理 状态码 状态文本 信息 100 Continue 客户端应当继续发送请求 101 Switching Protocols 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求 2XX 成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受 状态码 状态文本 信息 200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回 202 Accepted 服务器已接受请求，但尚未处理 203 Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝 204 No Content 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息 205 Reset Content 服务器成功处理了请求，且没有返回任何内容 206 Partial Content 服务器已经成功处理了部分GET请求 3XX 重定向 这类状态码代表需要客户端采取进一步的操作才能完成请求 状态码 状态文本 信息 300 Multiple Choices 请求的资源可在多处得到 301 Moved Permanently 本网页被永久性转移到另一个URL 302 Found 请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request 303 See Other 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源 304 Not Modified 自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用 305 Use Proxy 被请求的资源必须通过指定的代理才能被访问 306 Switch Proxy 在最新版的规范中，306状态码已经不再被使用 307 Temporary Redirect 请求的资源现在临时从不同的URI响应请求 4XX 客户端错误 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理 状态码 状态文本 信息 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 当前请求需要用户验证，该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息 402 Payment Required 该状态码是为了将来可能的需求而预留的 403 Forbidden 禁止访问，服务器收到请求，但是拒绝提供服务 404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现 405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源 406 Not Acceptable 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体 407 Proxy Authentication Required 与401响应类似，只不过客户端必须在代理服务器上进行身份验证 408 Request Timeout 请求超时，客户端没有在服务器预备等待的时间内完成一个请求的发送 409 Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成 410 Gone 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址 411 Length Required 服务器拒绝在没有定义Content-Length头的情况下接受请求 412 Precondition Failed 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个 413 Request Entity Too Large 请求的资源大于服务器允许的大小 414 Request-URI Too Long 请求的URI长度超过了服务器能够解释的长度 415 Unsupported Media Type 请求资源不支持请求项目格式 416 Requested Range Not Satisfiable 请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头 417 Expectation Failed 在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足 5XX 服务器错误 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理 状态码 状态文本 信息 500 Internal Server Error 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理 501 Not Implemented 服务器不支持当前请求所需要的某个功能 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应 503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求 504 Gateway Timeout 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应 505 HTTP Version Not Supported 服务器不支持，或者拒绝支持在请求中使用的HTTP版本","categories":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/tags/WEB/"}],"keywords":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}]},{"title":"常用正则表达式汇总","slug":"common-reg-expression","date":"2016-06-29T16:00:00.000Z","updated":"2016-11-20T09:24:22.506Z","comments":true,"path":"2016/06/30/common-reg-expression/","link":"","permalink":"https://blog.luckyw.cn/2016/06/30/common-reg-expression/","excerpt":"正则表达式是web开发必备的一项基本技能，熟练掌握使用正则表达式，能使你的开发效率得到大幅度的提升，尤其是在对网络爬虫爬取页面内容进行分析方面有巨大的作用，下面就来介绍一些常用的正则表达式，希望对大家能有所帮助","text":"正则表达式是web开发必备的一项基本技能，熟练掌握使用正则表达式，能使你的开发效率得到大幅度的提升，尤其是在对网络爬虫爬取页面内容进行分析方面有巨大的作用，下面就来介绍一些常用的正则表达式，希望对大家能有所帮助 校验数字 123456789101112数字：^\\d*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9]\\d*)+(\\.\\d&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+\\.\\d&#123;1,2&#125;$正数、负数、和小数：^(\\-)?\\d+(\\.\\d+)?$有两位小数的正实数：^\\d+\\.\\d&#123;2&#125;$有1~3位小数的正实数：^\\d+\\.\\d&#123;1,3&#125;$非零的正整数：^[1-9]\\d*$非零的负整数：^-[1-9]\\d*$ 校验字符的表达式 12345678910汉字：^[\\u4e00-\\u9fa5]+$英文和数字：^[A-Za-z0-9]+$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\\w+$中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 特殊需求表达式 1234567891011Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$国内手机号码：^1[34578]&#123;1&#125;\\d&#123;9&#125;帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z]\\w&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)IP地址：^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5]))&#123;3&#125;$","categories":[{"name":"REG","slug":"REG","permalink":"https://blog.luckyw.cn/categories/REG/"}],"tags":[{"name":"REG","slug":"REG","permalink":"https://blog.luckyw.cn/tags/REG/"}],"keywords":[{"name":"REG","slug":"REG","permalink":"https://blog.luckyw.cn/categories/REG/"}]},{"title":"前端冷知识课堂","slug":"webfront-dont-know","date":"2016-06-23T16:00:00.000Z","updated":"2016-11-20T11:52:21.765Z","comments":true,"path":"2016/06/24/webfront-dont-know/","link":"","permalink":"https://blog.luckyw.cn/2016/06/24/webfront-dont-know/","excerpt":"HTML篇 浏览器地址栏运行JS代码在浏览器地址栏可以直接运行JS代码，做法是以javascript:开头后跟要执行的语句。比如:1javascript:alert(&apos;alert from the address bar :)&apos;); 将以上代码贴到浏览器地址栏回车后执行，alert弹出一个窗口 需要注意的是如果是通过复制粘贴代码到浏览器地址栏的话，IE及Chrome会自动去掉代码开头的javascript:，所以需要手动添加起来才能正确执行，而Firefox中虽然不会自动去掉，但它根本就不支持在地址栏运行JS代码，so :( 浏览器地址栏运行HTML代码 在非IE内核的浏览器地址栏可以直接运行HTML代码，比如在地址栏输入以下代码然后回车运行，会出现指定的页面内容1data:text/html,&lt;h1&gt;Hello, world!&lt;/h1&gt; 效果如下: 浏览器变成编辑器 将以下代码贴到地址栏运行后浏览器变成了一个原始而简单的编辑器，跟windows记事本效果一样1data:text/html, &lt;html contenteditable&gt; 主要是因为HTML5中新加了contenteditable属性，当元素指定了该属性后，元素的内容成为可编辑状态。举一反三，将以下代码在控制台执行后，整个页面变成可编辑状态，肆意玩耍吧1document.body.contentEditable=&apos;true&apos;;","text":"HTML篇 浏览器地址栏运行JS代码在浏览器地址栏可以直接运行JS代码，做法是以javascript:开头后跟要执行的语句。比如:1javascript:alert(&apos;alert from the address bar :)&apos;); 将以上代码贴到浏览器地址栏回车后执行，alert弹出一个窗口 需要注意的是如果是通过复制粘贴代码到浏览器地址栏的话，IE及Chrome会自动去掉代码开头的javascript:，所以需要手动添加起来才能正确执行，而Firefox中虽然不会自动去掉，但它根本就不支持在地址栏运行JS代码，so :( 浏览器地址栏运行HTML代码 在非IE内核的浏览器地址栏可以直接运行HTML代码，比如在地址栏输入以下代码然后回车运行，会出现指定的页面内容1data:text/html,&lt;h1&gt;Hello, world!&lt;/h1&gt; 效果如下: 浏览器变成编辑器 将以下代码贴到地址栏运行后浏览器变成了一个原始而简单的编辑器，跟windows记事本效果一样1data:text/html, &lt;html contenteditable&gt; 主要是因为HTML5中新加了contenteditable属性，当元素指定了该属性后，元素的内容成为可编辑状态。举一反三，将以下代码在控制台执行后，整个页面变成可编辑状态，肆意玩耍吧1document.body.contentEditable=&apos;true&apos;; 利用a标签自动解析URL 如果我们有从一个URL中提取域名、查询关键字、变量参数值等的需求，就需要写正则去对查询url进行获取，而浏览器却可以很方便地帮我们完成这一任务。JS代码里先创建一个a标签然后将需要解析的URL赋值给a的href属性，然后就可以很简单的得到我们想要的了123var a = document.createElement(&apos;a&apos;);a.href = &apos;https://blog.h5demo.xyz/2016/06/24/webfront-dont-know/&apos;;console.log(a.host); 效果如下:利用这一原理，稍微进行一下扩展，就可以获得一个解析URL各部分的通用方法123456789101112131415161718192021222324252627function parseURL(url) &#123; var a = document.createElement(&apos;a&apos;); a.href = url; return &#123; source: url, protocol: a.protocol.replace(&apos;:&apos;,&apos;&apos;), host: a.hostname, port: a.port, query: a.search, params: (function()&#123; var ret = &#123;&#125;, seg = a.search.replace(/^\\?/,&apos;&apos;).split(&apos;&amp;&apos;), len = seg.length, i = 0, s; for (;i&lt;len;i++) &#123; if (!seg[i]) &#123; continue; &#125; s = seg[i].split(&apos;=&apos;); ret[s[0]] = s[1]; &#125; return ret; &#125;)(), file: (a.pathname.match(/\\/([^\\/?#]+)$/i) || [,&apos;&apos;])[1], hash: a.hash.replace(&apos;#&apos;,&apos;&apos;), path: a.pathname.replace(/^([^\\/])/,&apos;/$1&apos;), relative: (a.href.match(/tps?:\\/\\/[^\\/]+(.+)/) || [,&apos;&apos;])[1], segments: a.pathname.replace(/^\\//,&apos;&apos;).split(&apos;/&apos;) &#125;;&#125; 效果如下: 页面拥有ID的元素会创建全局变量 在一个HTML页面中，所有设置了ID属性的元素会在JS的执行环境中创建对应的全局变量，这意味着document.getElementById显得多余了，但实际项目中还是该怎么写就怎么写，这样出错的概率就小的多，比如我的主页中有一个id为fancyBox的a元素，我们可以这么获取 加载CDN文件时，可以省掉HTTP前缀 现在很流行的CDN即从专门的服务器加载一些通用的JS和CSS文件，出于安全考虑有的CDN服务器使用HTTPS方式连接，而有的是传统的HTTP，其实我们在使用时可以忽略掉这个1&lt;script src=&quot;//cdn.domain.com/path/of/script.js&quot;&gt;&lt;/script&gt; 利用script标签保存任意信息 将script标签设置为type=&#39;text&#39;，然后就可以在里面保存任意信息，之后可以在JS代码中很方便地获取1234&lt;script type=&quot;text&quot; id=&quot;template&quot;&gt; &lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/script&gt;var text = document.getElementById(&apos;template&apos;).innerHTML CSS篇 CSS恶作剧 相信你看了以下代码，应该知道接下来会发生什么 :)123*&#123; cursor: none!important;&#125; 简单的文字模糊效果 以下两行简单的CSS代码可达到将文字模糊化的效果，有点像使用PS的滤镜，it’s awesome！1234p &#123; color: transparent; text-shadow: #111 0 0 5px;&#125; 效果图: 多重边框 利用重复指定box-shadow来达到多个边框的效果123456div &#123; box-shadow: 0 0 0 6px rgba(0, 0, 0, 0.2), 0 0 0 12px rgba(0, 0, 0, 0.2), 0 0 0 18px rgba(0, 0, 0, 0.2), 0 0 0 24px rgba(0, 0, 0, 0.2); height: 200px; margin: 50px auto; width: 400px&#125; 效果图: 实时编辑CSS 通过设置style标签的display:block样式可以让页面的style标签显示出来，并且加上contentEditable属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现的,不过此技巧在IE下无效12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;style style=&quot;display:block&quot; contentEditable&gt; body &#123; color: red &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt; CSS中也可以做简单运算 通过CSS中的calc方法可以进行一些简单的运算，从而达到动态指定元素样式的目的123.container&#123; width: calc(100% - 50px);&#125; 注:减号前后有两个空格 JS篇 生成随机字符串 利用Math.random和toString生成随机字符串，这里的技巧是利用了toString方法可以接收一个基数作为参数的原理，这个基数取值为2到36，如果不指定，默认基数是10，表示十进制效果图: 整数的操作 JS中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升,|0和~~是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的parseInt、Math.round要高12var foo = (13.14 / 5.20) | 0;//结果为2var bar = ~~(13.14 / 5.20);//结果为2 注意:请谨慎使用，具体原因请参考快速（但危险）的取整方法顺便说句，!!将一个值方便快速转化为布尔值!!window===true 重写原生方法以实现新功能 下面的代码通过重写alert让它可以记录弹窗的次数123456789(function() &#123; var oldAlert = window.alert, count = 0; window.alert = function(a) &#123; count++; oldAlert(a + &quot;\\n 天啊！你已经弹窗&quot; + count + &quot; 次了，别再弹了，ok？&quot;); &#125;;&#125;)();alert(&quot;Hello World&quot;); console恶作剧 Chrome的console.log是支持对文字添加样式的，甚至图片都可以，我们可以重写掉默认的log方法，把将要log的文字应用CSS的模糊效果，这样当有人试图调用console.log()的时候，log出来的是模糊不清的文字1234var _log = console.log;console.log = function() &#123; _log.call(console, &apos;%c&apos; + [].slice.call(arguments).join(&apos; &apos;), &apos;color:transparent;text-shadow:0 0 2px rgba(0,0,0,.5);&apos;);&#125;; 效果图: 不声明第三个变量的值交换 交换两个变量值的常规做法，那就是声明一个中间变量来暂存,而不声明第三个变量的值交换的方法如下:1var a=1,b=2;a=[b,b=a][0]; JS一切皆对象 JS的世界，一切皆对象。除了null和undefined，其他基本类型数字、字符串和布尔值都有对应有包装对象。对象的一个特征是你可以在它身上直接调用方法，对于数字基本类型，当试图在其身上调用toString方法会失败，但用括号括起来后再调用就不会失败了，内部实现是用相应的包装对象将基本类型转为对象。所以(1).toString()相当于new Number(1).toString()。因此，你的确可以把基本类型数字、字符串、布尔等当对象使用，只是需要注意语法要得体。同时我们知道，JS中数字是不分浮点型和整型的，所有数字其实均是浮点类型，只是把小数点省略了而以，比如你看到的1可以写成1.，这也就是为什么当你试图1.toString()时会报错，所以正确的写法应该是这样：1..toString()，或者如上面所述加上括号，这里括号的作用是纠正JS解析器，不要把1后面的点当成小数点。内部实现如上面所述，是将1.用包装对象转成对象再调用方法 If语句的变形 当你需要写一个if语句的时候，不妨尝试用JS中的逻辑运算符来代替1234567var day=(new Date).getDay()===0;//传统if语句if (day) &#123; alert(&apos;Today is Sunday!&apos;);&#125;;//运用逻辑与代替ifday&amp;&amp;alert(&apos;Today is Sunday!&apos;); 比如上面的代码，首先得到今天的日期，如果是星期天，则弹窗，否则什么也不做。我们知道逻辑操作存在短路的情况，对于逻辑与表达式，只有两者都真才结果才为真，如果前面的day变量被判断为假了，那么对于整个与表达式来说结果就是假，所以就不会继续去执行后面的alert了，如果前面day为真，则还要继续执行后面的代码来确定整个表达式的真假。利用这点达到了if的效果。对于传统的if语句，如果执行体代码超过了1条语句，则需要加花括号，而利用逗号表达式，可以执行任意条代码而不用加花括号1if(conditoin) alert(1),alert(2),console.log(3); 上面if语句中，如果条件成立则执行三个操作，但我们不需要用花括号将这三句代码括起来。当然，这是不推荐的，这里是冷知识课堂:) 禁止别人以iframe加载你的页面 1if (window.location != window.parent.location) window.parent.location = window.location; console.table Chrome党的console方法，可以将JS关联数组以表格形式输出到浏览器控制台，效果很赞，界面美观12var data = [&#123;&apos;水果名&apos;: &apos;苹果&apos;, &apos;数量&apos;: 20&#125;, &#123;&apos;水果名&apos;: &apos;梨子&apos;, &apos;数量&apos;: 40&#125;];console.table(data); 效果图:","categories":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/tags/WEB/"}],"keywords":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}]},{"title":"在ubuntu上安装最新稳定版本的node及npm","slug":"ubuntu-install-node","date":"2016-06-14T16:00:00.000Z","updated":"2016-11-20T11:07:52.658Z","comments":true,"path":"2016/06/15/ubuntu-install-node/","link":"","permalink":"https://blog.luckyw.cn/2016/06/15/ubuntu-install-node/","excerpt":"背景 通过ubuntu官方apt安装工具安装的node是最新LTS版本的，而本人是个有点强迫症的人，喜欢追求新的东西，也就是想方设法想要去安装最新版本的node，所以本文也就产生了，附上ubuntu安装node和npm的命令行命令:12sudo apt install nodejs-legacysudo apt install npm 最新版本安装方法 1、安装npm1sudo apt install npm 2、升级npm为最新版本1sudo npm install npm@latest -g 此时通过npm -v可以发现npm版本号为最新版本3.10.3;","text":"背景 通过ubuntu官方apt安装工具安装的node是最新LTS版本的，而本人是个有点强迫症的人，喜欢追求新的东西，也就是想方设法想要去安装最新版本的node，所以本文也就产生了，附上ubuntu安装node和npm的命令行命令:12sudo apt install nodejs-legacysudo apt install npm 最新版本安装方法 1、安装npm1sudo apt install npm 2、升级npm为最新版本1sudo npm install npm@latest -g 此时通过npm -v可以发现npm版本号为最新版本3.10.3;3、安装用于安装nodejs的模块n1sudo npm install -g n 4、然后通过n模块安装指定版本的nodejs，n模块更多介绍请参考官方文档123456//安装官方最新版本sudo n latest//安装官方稳定版本sudo n stable//安装官方最新LTS版本sudo n lts 我们通过安装稳定版本的nodejs，然后通过node -v可以发现node安装成功，并且版本号为v6.2.0稳定版本","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/tags/Ubuntu/"},{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/tags/Node/"}],"keywords":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}]},{"title":"Grub Rescue解决办法","slug":"grub-rescue-solve","date":"2016-06-09T16:00:00.000Z","updated":"2016-11-20T10:55:42.309Z","comments":true,"path":"2016/06/10/grub-rescue-solve/","link":"","permalink":"https://blog.luckyw.cn/2016/06/10/grub-rescue-solve/","excerpt":"问题原因 自己装的是win10和ubuntu 16.04双系统，经常对ubuntu瞎整弄得系统不成样子，这时没办法只能重新安装，而此时每次重启都发现系统自动进入了grub rescue模式，需要输入命令才能进入系统，而重启之后发现这个问题还是没有解决，还是要输入命令才能进去 解决办法 1、先使用ls命令，找到ubuntu安装分区1grub rescue&gt;ls 会罗列出所有的磁盘分区信息，比方说我的是1(hd0),(hd0,msdos1),(hd0,msdos5),(hd0,msdos6),(hd0,msdos7),(hd0,msdos8),(hd0,msdos9),(hd0,msdos10),(hd0,msdos11)","text":"问题原因 自己装的是win10和ubuntu 16.04双系统，经常对ubuntu瞎整弄得系统不成样子，这时没办法只能重新安装，而此时每次重启都发现系统自动进入了grub rescue模式，需要输入命令才能进入系统，而重启之后发现这个问题还是没有解决，还是要输入命令才能进去 解决办法 1、先使用ls命令，找到ubuntu安装分区1grub rescue&gt;ls 会罗列出所有的磁盘分区信息，比方说我的是1(hd0),(hd0,msdos1),(hd0,msdos5),(hd0,msdos6),(hd0,msdos7),(hd0,msdos8),(hd0,msdos9),(hd0,msdos10),(hd0,msdos11) 2、然后依次输入命令，看是否有file not find报错信息，如果有文件信息输出，则说明ubuntu安装分区就是这个盘，比如我的安装路径就是(hd0,msdos8)，也就是我的boot分区12//第一种无boot分区grub rescue&gt;ls (hd0,msdosX)/boot/grub 或者12//第二种单独boot分区grub rescue&gt;ls (hd0,msdosX)/grub 注意：如果你安装前设置了boot单独分区，则采用第二种方式，否则就采用第一种3、调用以下命令，同样分为无boot单独分区和boot单独分区两种方式:12345//第一种无boot分区grub rescue&gt;set root=(hd0,msdos8)grub rescue&gt;set prefix=(hd0,msdos8)/boot/grubgrub rescue&gt;insmod normalgrub rescue&gt;normal 或者12345//第二种单独boot分区grub rescue&gt;set root=(hd0,msdos8)grub rescue&gt;set prefix=(hd0,msdos8)/grubgrub rescue&gt;insmod normalgrub rescue&gt;normal 此时发现可以进入系统，但重启还是发现问题依旧存在4、在ubuntu下，ctrl+shift+t打开命令行窗口，执行以下命令12sudo update-grubsudo grub-install /dev/sda 5、重启下看是否已经恢复了grub的启动菜单注:sudo gedit /boot/grub/grub.cfg可以修改grub的引导菜单","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/tags/Ubuntu/"}],"keywords":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}]},{"title":"解决ubuntu下sublime无法输入中文问题","slug":"ubuntu-sublime-chinese-resolve","date":"2016-06-04T16:00:00.000Z","updated":"2016-11-20T11:09:23.538Z","comments":true,"path":"2016/06/05/ubuntu-sublime-chinese-resolve/","link":"","permalink":"https://blog.luckyw.cn/2016/06/05/ubuntu-sublime-chinese-resolve/","excerpt":"系统环境 系统:Ubuntu 16.04优麒麟 (应该大多数linux系统都试用)输入法:小企鹅输入法 fcitx 4.2.9.1Sublime Text版本:Sublime Text 3 Build 3114 解决办法1、保存以下代码到sublime-imfix.c(位于～目录)1234567891011121314151617#include &lt;gtk/gtkimcontext.h&gt;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) klass-&gt;set_client_window (context, window); g_object_set_data(G_OBJECT(context),&quot;window&quot;,window); if(!GDK_IS_WINDOW (window)) return; int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) gtk_im_context_focus_in(context);&#125;","text":"系统环境 系统:Ubuntu 16.04优麒麟 (应该大多数linux系统都试用)输入法:小企鹅输入法 fcitx 4.2.9.1Sublime Text版本:Sublime Text 3 Build 3114 解决办法1、保存以下代码到sublime-imfix.c(位于～目录)1234567891011121314151617#include &lt;gtk/gtkimcontext.h&gt;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) klass-&gt;set_client_window (context, window); g_object_set_data(G_OBJECT(context),&quot;window&quot;,window); if(!GDK_IS_WINDOW (window)) return; int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) gtk_im_context_focus_in(context);&#125; 2、安装 C/C++ 的编译环境和 gtk libgtk2.0-dev12sudo apt-get install build-essentialsudo apt-get install libgtk2.0-dev 3、编译成共享库libsublime-imfix.so1gcc -shared -o libsublime-imfix.so sublime-imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC 4、设置LD_PRELOAD并启动Sublime1LD_PRELOAD=./libsublime-imfix.so subl 5、移动共享库到/opt/sublime_text目录下1sudo mv libsublime-imfix.so /opt/sublime_text 6、管理员权限打开/usr/share/applications/sublime_text.desktop并修改对应的Exec值1234567891011121314[Desktop Entry][...]Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text %F[...][Desktop Action Window][...]Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text -n[...][Desktop Action Document][...]Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file[...] 7、管理员权限打开并修改/usr/bin/subl文件123#!/bin/shexport LD_PRELOAD=/opt/sublime_text/libsublime-imfix.soexec /opt/sublime_text/sublime_text &quot;$@&quot; There are no packages available for installation 解决办法 修改hosts打开终端执行以下命令1sudo echo &quot;50.116.34.243 sublime.wbond.net&quot; &gt;&gt; /etc/hosts 其他系统类似，在对应的hosts文件里加上这么一行即可:50.116.34.243 sublime.wbond.net 注册码 1. Sublime Text 3.x(Bulid 309X 之前版本)适用于3065 / 3083 等低于 309x 的版本 —– BEGIN LICENSE —–Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523—— END LICENSE —— 或者 —– BEGIN LICENSE —–K-20Single User LicenseEA7E-9401293A099EC1 C0B5C7C5 33EBF0CF BE82FE3BEAC2164A 4F8EC954 4E87F1E5 7E4E85D6C5605DE6 DAB003B4 D60CA4D0 77CB15333C47F579 FB3E8476 EB3AA9A7 68C43CD98C60B563 80FE367D 8CAD14B3 54FB7A9F4123FFC4 D63312BA 141AF702 F6BBA254B094B9C0 FAA4B04C 06CC9AFC FD41267182E3AEE0 0F0FAAA7 8FA773C9 383A9E18—— END LICENSE —— 或者 —– BEGIN LICENSE —–J2TeaM2 User LicenseEA7E-94028245CB0D8F 09100037 7D1056EB A1DDC1A239C102C5 DF8D0BF0 FC3B1A94 4F2892B40AEE61BA 65758D3B 2EED551F A3E3478CC1C0E04E CA4E4541 1FC1A2C1 3F5FB6DBCFDA1551 51B05B5D 2D3C8CFE FA8B4285051750E3 22D1422A 7AE3A8A1 3B4188AC346372DA 37AA8ABA 6EB30E41 781BC81FB5CA66E3 A09DBD3A 3FE85BBD 69893DBD—— END LICENSE —— 2. Sublime Text 3.X(Bulid 309x之后版本)适用于 3103 等高于 309x 的版本 —– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE —— 或者 —– BEGIN LICENSE —–Free Communities Consultoria em Informática LtdaSingle User LicenseEA7E-801302C154C122 4EFA4415 F1AAEBCC 315F3A7D2580735A 7955AA57 850ABD88 72A1DDD88D2CE060 CF980C29 890D74F2 53131895281E324E 98EA1FEF 7FF69A12 17CA7784490862AF 833E133D FD22141D D8C89B944C10A4D2 24693D70 AE37C18F 72EF0BE51ED60704 651BC71F 16CA1B77 496A0B19463EDFF9 6BEB1861 CA5BAD96 89D0118E—— END LICENSE —— 或者 —– BEGIN LICENSE —–Nicolas HennionSingle User LicenseEA7E-8660758A01AA83 1D668D24 4484AEBC 3B04512C827B0DE5 69E9B07A A39ACCC0 F95F5410729D5639 4C37CECB B2522FB3 8D37FDC172899363 BBA441AC A5F47F08 6CD3B3FECEFB3783 B2E1BA96 71AAF7B4 AFB61B1D0CC513E7 52FF2333 9F726D2C CDE53B4A810C0D4F E1F419A3 CDA0832B 8440565A35BF00F6 4CA9F869 ED10E245 469C233E—— END LICENSE —— 或者 —– BEGIN LICENSE —–Anthony SansoneSingle User LicenseEA7E-87856328B9A648 42B99D8A F2E3E9E0 16DE076EE218B3DC F3606379 C33C1526 E8B58964B2CB3F63 BDF901BE D31424D2 082891B5F7058694 55FA46D8 EFC11878 0868F093B17CAFE7 63A78881 86B78E38 0F146238BAE22DBB D4EC71A1 0EC2E701 C7F9C6485CF29CA3 1CB14285 19A46991 E9A9867614FD4777 2D8A0AB6 A444EE0D CA009B54—— END LICENSE —— 或者 —– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE —— 或者 —– BEGIN LICENSE —–Peter HallidaySingle User LicenseEA7E-8559883997BFF0 2856413A 7A555954 67069B7806D8CE12 63EAF079 AD039757 79E16D13C555AD90 465CBE53 10F6DFC4 D3A3C611411106F8 0CFEB15F 0A7BB891 111F5ED2C6AA8429 77913528 FA6291A9 B88D4550F1D6AB13 BF9153BC 91B4DFFE D296CFE0C1D8EB22 13D5F14E 75A699EC 49EDDC23D89D0F9B D240B10A A3712467 09DE7870—— END LICENSE —— 或者 —– BEGIN LICENSE —–Fred ZirdungSingle User LicenseEA7E-8446726089C0EC 22936E1A 1EADEBE2 B8654BBA5C98FFA6 C0FD1599 0364779B 071C74FBEEFE9EAB 92B3D867 CD1B32FE D190269F6FC08F8F 8D24191D 32828465 942CE58EAECE5307 08B62229 D788560A 6E0AAC4B48A2D9EE 24FD8CAA 07BEBDF2 28EA86D4CCB96084 6C34CAD2 E8A04F39 3B5A3CBC3B668BB7 C94D0B4B 847D6D7F 4BC07375—— END LICENSE —— 或者 —– BEGIN LICENSE —–WixelSingle User LicenseEA7E-848235103D2969 8700C7ED 8173CF61 537000C0EB3C7ECB 5E750F17 6B42B67C A190090B7669164F C6F371A8 5A1D88D5 BDD0DA70C065892B 7CC1BB2B 1C8B8C7C F08E77897C2A5241 35F86328 4C8F70D9 C023D7C211245C36 59A730DB 72BDB9A7 D5B2030490E90E72 9F08CA25 73F49C20 179D938E5BC8BEDA 13457A69 39E6265F 233767F9—— END LICENSE —— 或者 —– BEGIN LICENSE —–Daniel RusselSingle User LicenseEA7E-9174209327EC62 44020C2A 45172A68 12FE13F11D22245B 680892EE F551F8EB C183D0328B4EDB4B 479CB7E4 07E42EDD A780021D56BADF42 AC05238B 023B47B1 EBA1B7DE6DF9A383 159F32AE 04EBE100 1278B1D252E81B60 C68AA2E8 F84A20BE FE7990EB5D44E4B6 16369263 1DDAACBC 280FF19E86CF4319 0B8615A8 4FF0512E B123B8EC—— END LICENSE —— 或者 —– BEGIN LICENSE —–Peter ErikssonSingle User LicenseEA7E-8900688E107C71 3100D6FC 2AC805BF 9E627C7772E710D7 43392469 D06A2F5B F9304FBDF5AB4DB2 7A95F172 FE68E300 42745819E94AB2DF C1893094 ECABADC8 71FEE76420224821 3EABF931 745AF882 87AD0A4B33C6E377 0210D712 CD2B1178 82601542C7FD8098 F45D2824 BC7DFB38 F1EBD38AD7A3AFE0 96F938EA 2D90BD72 9E34CDF0—— END LICENSE —— 或者 —– BEGIN LICENSE —–Ryan ClarkSingle User LicenseEA7E-8124792158A7DE B690A7A3 8EC04710 006A5EEB34E77CA3 9C82C81F 0DB6371B 79704E6F93F36655 B031503A 03257CCC 01B20F60D304FA8D B1B4F0AF 8A76C7BA 0FA94D5556D46BCE 5237A341 CD837F30 4D60772D349B1179 A996F826 90CDB73C 24D41245FD032C30 AD5E7241 4EAA66ED 167D91FB55896B16 EA125C81 F550AF6B A6820916—— END LICENSE —— 我的配置文件 1234567891011121314151617&#123; &quot;color_scheme&quot;: &quot;Packages/Material Theme/schemes/Material-Theme-Darker.tmTheme&quot;, &quot;theme&quot;: &quot;Material-Theme-Darker.sublime-theme&quot;, &quot;auto_find_in_selection&quot;: true, //在选定范围搜索 &quot;bold_folder_labels&quot;: true, //加粗文件夹名称 &quot;font_size&quot;: 16, //字体大小 &quot;highlight_line&quot;: true, //高亮编辑行 &quot;save_on_focus_lost&quot;: true, //失焦自动保存 &quot;show_encoding&quot;: true, //显示文件编码 &quot;trim_trailing_white_space_on_save&quot;: true, //去除每行文本最后空格 &quot;highlight_modified_tabs&quot;: true, //文件修改，标签高亮显示 &quot;word_wrap&quot;: &quot;true&quot;, //自动换行 &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ]&#125;","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"https://blog.luckyw.cn/tags/Sublime/"}],"keywords":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}]},{"title":"Chrome Console命令","slug":"chrome-console","date":"2016-05-31T16:00:00.000Z","updated":"2016-11-20T09:23:54.044Z","comments":true,"path":"2016/06/01/chrome-console/","link":"","permalink":"https://blog.luckyw.cn/2016/06/01/chrome-console/","excerpt":"显示信息 1234console.log(&apos;log&apos;); //最常用console.info(&apos;info&apos;);console.error(&apos;error&apos;);console.warn(&apos;warn&apos;); 效果: 占位符 console上述的集中度支持printf的占位符格式，支持的占位符有:字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）1console.log(&quot;%d年%d月%d日&quot;,2016,6,1); 效果:","text":"显示信息 1234console.log(&apos;log&apos;); //最常用console.info(&apos;info&apos;);console.error(&apos;error&apos;);console.warn(&apos;warn&apos;); 效果: 占位符 console上述的集中度支持printf的占位符格式，支持的占位符有:字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）1console.log(&quot;%d年%d月%d日&quot;,2016,6,1); 效果: 信息分组 12345678console.group(&quot;第一组信息&quot;);console.log(&quot;第一组第一条:我的主页(http://h5demo.xyz)&quot;);console.log(&quot;第一组第二条:我的博客(http://blog.h5demo.xyz)&quot;);console.groupEnd();console.group(&quot;第二组信息&quot;);console.log(&quot;第二组第一条:Leo Angel&quot;);console.log(&quot;第二组第二条:前端工作者&quot;);console.groupEnd(); 效果: 查看对象的信息 console.dir()可以显示一个对象所有的属性和方法123456var info = &#123; index: &quot;http://h5demo.xyz&quot;, blog: &quot;http://blog.h5demo.xyz&quot;, info: &quot;前端爱好者欢迎你的加入&quot;&#125;;console.dir(info); 效果: 显示某个节点的内容 console.dirxml()用来显示网页的某个节点所包含的html/xml代码12var info = document.getElementById(&quot;info&quot;);console.dirxml(info) 效果: 判断变量是否是真 console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常1234var result = 1;console.assert(result);var year = 2016;console.assert(year == 2018); 1是非0值，是真；而第二个判断是假，在控制台显示错误信息效果: 追踪函数的调用轨迹 console.trace()用来追踪函数的调用轨迹1234567891011121314function add(a, b) &#123; console.trace(); return a + b;&#125;var x = add3(1, 1);function add3(a, b) &#123; return add2(a, b);&#125;function add2(a, b) &#123; return add1(a, b);&#125;function add1(a, b) &#123; return add(a, b);&#125; 效果: 计时功能 console.time()和console.timeEnd()，用来显示代码的运行时间12345console.time(&quot;计时器一&quot;);for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125;&#125;console.timeEnd(&quot;计时器一&quot;); 运行时间是8.745ms效果: console.profile()的性能分析 性能分析就是分析程序各个部分的运行时间，找出瓶颈所在，使用的方法是console.profile()12345678910111213141516function All() &#123; alert(11); for (var i = 0; i &lt; 10; i++) &#123; funcA(1000); &#125; funcB(10000);&#125;function funcA(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125;&#125;function funcB(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125;&#125;console.profile(&apos;性能分析器&apos;);All();console.profileEnd(); 效果: CSS样式 具体来说，是可以对输出到console控制台的文字进行CSS控制。格式如下：1console.log(&quot;%c需要输出的信息 &quot;, &quot;css 代码&quot;); 3D 文字渐变背景彩虹文字","categories":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/categories/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/tags/Chrome/"}],"keywords":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/categories/Chrome/"}]},{"title":"css常用代码大全","slug":"css-common-code","date":"2016-05-21T16:00:00.000Z","updated":"2016-11-20T09:34:57.968Z","comments":true,"path":"2016/05/22/css-common-code/","link":"","permalink":"https://blog.luckyw.cn/2016/05/22/css-common-code/","excerpt":"Css背景颜色透明 1234567.liter&#123; filter:progid:DXImageTransform.Microsoft.gradient(enabled=&apos;true&apos;,startColorstr=&apos;#4CDDDDDD&apos;, endColorstr=&apos;#4CDDDDDD&apos;);&#125;:root .liter &#123; filter:none; /*处理IE9浏览器中的滤镜效果*/ background-color:rgba(221,221,221,0.3);&#125; 图片垂直居中对齐 第一种：table-cell法123&lt;div class=&quot;test_box&quot;&gt; &lt;img src=&quot;book.jpg&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; 123456789101112131415.test_box &#123; display:table-cell ;width:200px; height:200px; vertical-align:middle; text-align:center; *float:left; *font-family:simsun; *font-size:200px; *line-height:1; border:1px solid #000000;&#125;.test_box img &#123; vertical-align:middle;&#125;","text":"Css背景颜色透明 1234567.liter&#123; filter:progid:DXImageTransform.Microsoft.gradient(enabled=&apos;true&apos;,startColorstr=&apos;#4CDDDDDD&apos;, endColorstr=&apos;#4CDDDDDD&apos;);&#125;:root .liter &#123; filter:none; /*处理IE9浏览器中的滤镜效果*/ background-color:rgba(221,221,221,0.3);&#125; 图片垂直居中对齐 第一种：table-cell法123&lt;div class=&quot;test_box&quot;&gt; &lt;img src=&quot;book.jpg&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; 123456789101112131415.test_box &#123; display:table-cell ;width:200px; height:200px; vertical-align:middle; text-align:center; *float:left; *font-family:simsun; *font-size:200px; *line-height:1; border:1px solid #000000;&#125;.test_box img &#123; vertical-align:middle;&#125; 第二种：span法 123456&lt;div class=&quot;test_box&quot;&gt; &lt;span class=&quot;hook&quot;&gt;&lt;/span&gt; &lt;a href=&quot;http://blog.linxz.de/css_book/&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;book.jpg&quot; alt=&quot;&quot; /&gt; &lt;/a&gt;&lt;/div&gt; 12345678910111213141516171819202122.test_box &#123; width:200px; height:200px; overflow:hidden; text-align:center; font-size:0; border:1px solid #000000;&#125;.test_box .hook &#123; display:inline-block; width:0; height:100%; overflow:hidden; margin-left:-1px; font-size:0; line-height:0; vertical-align:middle;&#125;.test_box img &#123; vertical-align:middle; border:0 none;&#125; css border制作小三角（兼容IE6） 123456789101112131415.triangle &#123; display:inline-block; width:0; height:0; overflow:hidden; line-height:0; font-size:0; vertical-align:middle; border-right:7px solid #000fff; border-left:0 none; border-top:7px solid transparent; border-bottom:7px solid transparent; _color:#FF3FFF; _filter:chroma(color=#FF3FFF);&#125; CSS固定在底部 12345678910111213141516171819202122232425262728293031323334353637/*Sticky Footer Solution by Steve Hatcherhttp://stever.ca http://www.cssstickyfooter.com*/* &#123;margin:0;padding:0;&#125;/* must declare 0 margins on everything, also for main layout components use padding, not vertical margins (top and bottom) to add spacing, else those margins get added to total height and your footer gets pushed down a bit more, creating vertical scroll bars in the browser */html, body &#123; height: 100%;&#125;#wrap &#123; min-height: 100%;&#125;#main &#123; overflow:auto; padding-bottom: 150px; /* must be same height as the footer */&#125;#footer &#123; position: relative; margin-top: -150px; /* negative value of footer height */ height: 150px; clear:both;&#125;/*Opera Fix*/body:before &#123;/* thanks to Maleika (Kohoutec)*/ content:&quot;&quot;; height:100%; float:left; width:0; margin-top:-32767px;/* thank you Erik J - negate effect of float*/&#125;/* IMPORTANT You also need to include this conditional style in the of your HTML file to feed this style to IE 6 and lower and 8 and higher.&lt;!--[if !IE 7]&gt;&lt;style type=&quot;text/css&quot;&gt; #wrap &#123;display:table;height:100%&#125;&lt;/style&gt;&lt; ![endif]--&gt;*/ 1234&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;main&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt; &lt;/div&gt; 纯粹的css固定在底部 123456789101112#footer &#123; position:fixed; left:0px; bottom:0px; height:32px; width:100%; background:#333;&#125; /* IE 6 */ *html #footer &#123; position:absolute; top:expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+&apos;px&apos;);&#125; 用CSS包裹内容很长的URL和文本 这个代码片段通过保证文本的包裹元素宽度适应内容的宽度，能够避免很长的文本超出内容区域12345678910pre &#123; white-space: pre; /* CSS 2.0 */ white-space: pre-wrap; /* CSS 2.1 */ white-space: pre-line; /* CSS 3.0 */ white-space: -pre-wrap; /* Opera 4-6 */ white-space: -o-pre-wrap; /* Opera 7 */ white-space: -moz-pre-wrap; /* Mozilla */ white-space: -hp-pre-wrap; /* HP Printers */ word-wrap: break-word; /* IE 5+ */&#125; 用css3创造3D文字 text-shadow属性能帮助你只用CSS创造3D文字12345678910111213p.threeD&#123; text-shadow: -1px 1px 0 #ddd, -2px 2px 0 #c8c8c8, -3px 3px 0 #ccc, -4px 4px 0 #b8b8b8, -4px 4px 0 #bbb, 0px 1px 1px rgba(0,0,0,.4), 0px 2px 2px rgba(0,0,0,.3), -1px 3px 3px rgba(0,0,0,.2), -1px 5px 5px rgba(0,0,0,.1), -2px 8px 8px rgba(0,0,0,.1), -2px 13px 13px rgba(0,0,0,.1) ;&#125; CSS透明度 1234567div&#123; opacity: .75; /* Standard: FF gt 1.5, Opera, Safari */ filter: alpha(opacity=75); /* IE lt 8 */ -ms-filter: &quot;alpha(opacity=75)&quot;; /* IE 8 */ -khtml-opacity: .75; /* Safari 1.x */ -moz-opacity: .75; /* FF lt 1.5, Netscape */&#125; 改变博客中默认选中文本的颜色 12345678::selection &#123; background: #ffb7b7; /* Safari */ color: #ffffff;&#125;::-moz-selection &#123; background: #ffb7b7; /* Firefox */ color: #ffffff;&#125; 多重背景图片 12345#multiple-images &#123; background: url(image_1.png) top left no-repeat, url(image_2.png) bottom left no-repeat, url(image_3.png) bottom right no-repeat;&#125; 多栏CSS3 使用css3来创建多栏，它可以自适应网页，不兼容IE123456789#columns-3 &#123; text-align: justify; -moz-column-count: 3; -moz-column-gap: 12px; -moz-column-rule: 1px solid #c4c8cc; -webkit-column-count: 3; -webkit-column-gap: 12px; -webkit-column-rule: 1px solid #c4c8cc;&#125; 文本溢出省略 123456789101112131415161718.textoverflow a &#123; display:block; width:120px; margin: 0px 0px 0px 3px; white-space: nowrap; overflow: hidden; float: left; -o-text-overflow: ellipsis; /* for Opera */ text-overflow: ellipsis; /* for IE */&#125;.textoverflow:after&#123; content: &quot;...&quot;;&#125;/* for Firefox */@media all and (min-width: 0px)&#123; .textoverflow:after&#123; content:&quot;&quot;; &#125;/* for Opera */&#125; 让IE9以下的版本支持HTML5,在项目中加入以下JS代码123456789101112// html5 shivif (!+[1,]) &#123; (function() &#123; var tags = [ &apos;article&apos;, &apos;aside&apos;, &apos;details&apos;, &apos;figcaption&apos;, &apos;figure&apos;, &apos;footer&apos;, &apos;header&apos;, &apos;hgroup&apos;, &apos;menu&apos;, &apos;nav&apos;, &apos;section&apos;, &apos;summary&apos;, &apos;time&apos;, &apos;mark&apos;, &apos;audio&apos;, &apos;video&apos;], i = 0, len = tags.length; for (; i &lt; len; i++) document.createElement(tags[i]); &#125;)();&#125; or1234//code from http://caibaojian.com/popular-css-snippets.html&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; PNG32透明（IE6） 主要用来兼容IE6，不建议使用，由于这个css代码比较耗内存12345.some_element &#123; background: url(image.png); _background: none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&apos;image.png&apos;, sizingMethod=&apos;crop&apos;);&#125; 转自:前端开发博客","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"慕课网视频解析下载","slug":"imooc-video-download","date":"2016-05-15T16:00:00.000Z","updated":"2016-12-07T04:52:13.447Z","comments":true,"path":"2016/05/16/imooc-video-download/","link":"","permalink":"https://blog.luckyw.cn/2016/05/16/imooc-video-download/","excerpt":"慕课网视频解析下载 慕课网视频解析地址 技术说明 采用Bootstrap构建页面，jQuery实现页面交互，输入课程号点击解析，ajax通过跨域中转获取慕课网对应链接的网页代码进行分析，提取相关课程信息，获取课程章节列表及课程类型(视频、练习、编程)。如果是视频，则通过慕课网视频链接的api接口获取json数据，然后我们可以选择视频的清晰度进行下载(L,M,H),右键另存为的方式进行下载。而如果是练习、编程，可以点击按钮直接跳转到慕课网进行学习","text":"慕课网视频解析下载 慕课网视频解析地址 技术说明 采用Bootstrap构建页面，jQuery实现页面交互，输入课程号点击解析，ajax通过跨域中转获取慕课网对应链接的网页代码进行分析，提取相关课程信息，获取课程章节列表及课程类型(视频、练习、编程)。如果是视频，则通过慕课网视频链接的api接口获取json数据，然后我们可以选择视频的清晰度进行下载(L,M,H),右键另存为的方式进行下载。而如果是练习、编程，可以点击按钮直接跳转到慕课网进行学习获取慕课网视频链接的api接口如下，只需把mid修改成对应的课程章节id即可：12345678910111213141516171819http://www.imooc.com/course/ajaxmediainfo/?mid=12141&amp;mode=flash&#123; &quot;result&quot;: 0, &quot;data&quot;: &#123; &quot;result&quot;: &#123; &quot;mid&quot;: 12141, &quot;mpath&quot;: [ &quot;http://v2.mukewang.com/9945a8fb-7d3d-4695-bbc1-3796d75c4ea8/L.mp4?auth_key=1472474579-0-0-d5c3b7d2e547f052804931fc2753d1c9&quot;, &quot;http://v2.mukewang.com/9945a8fb-7d3d-4695-bbc1-3796d75c4ea8/M.mp4?auth_key=1472474579-0-0-3aba0eecf96a927a64725fd7edbeea6f&quot;, &quot;http://v2.mukewang.com/9945a8fb-7d3d-4695-bbc1-3796d75c4ea8/H.mp4?auth_key=1472474579-0-0-7a748b0773253a26a51b5b00cc4d6257&quot; ], &quot;cpid&quot;: &quot;3261&quot;, &quot;name&quot;: &quot;课程内容和目标&quot;, &quot;time&quot;: 0, &quot;practise&quot;: [] &#125; &#125;, &quot;msg&quot;: &quot;成功&quot;&#125; 使用说明 在慕课网中选择需要解析的课程： http://www.imooc.com/course/list 查看浏览器地址栏，网址形如： http://www.imooc.com/learn/675 在当前页面输入框中输入数字 675 点击解析按钮进行解析 点击需要的视频清晰度 右键点击下载视频，弹出菜单中选择链接另存为进行下载","categories":[{"name":"慕课网","slug":"慕课网","permalink":"https://blog.luckyw.cn/categories/慕课网/"}],"tags":[{"name":"慕课网","slug":"慕课网","permalink":"https://blog.luckyw.cn/tags/慕课网/"}],"keywords":[{"name":"慕课网","slug":"慕课网","permalink":"https://blog.luckyw.cn/categories/慕课网/"}]},{"title":"解决Ubuntu下Webstorm系列问题","slug":"ubuntu-webstorm-problems","date":"2016-05-08T16:00:00.000Z","updated":"2016-11-20T11:09:44.134Z","comments":true,"path":"2016/05/09/ubuntu-webstorm-problems/","link":"","permalink":"https://blog.luckyw.cn/2016/05/09/ubuntu-webstorm-problems/","excerpt":"","text":"中文输入问题 解决办法：在Webstorm安装目录的bin目录下找到webstorm.sh，然后打开之后在前面加上如下代码：12export XMODIFIERS=@im=fcitxexport QT_IM_MODULE=fcitxubun 注册： License Server :http://idea.lanyus.com/http://15.idea.lanyus.com/http://121.42.190.89:1025http://idea.qinxi1992.cn/http://114.215.133.70:41017上面的已失效，下面几个暂时可用http://idea.imsxm.com/http://jetbrains.tencent.click注册码因注册码过长，所以，你懂得～～ 点击获取注册码 NodeJS代码提示 2016-8-18更新 每当编写Node代码时，总是没有代码提示，其他语言的基本都有，而众所周知为什么WebStorm这么流行的原因就在于它的代码提示功能相当强大，那为什么没有提示了？ 我们需要开启NodeJs代码提示，那么请点击File -&gt; Settings -&gt; Language &amp;&amp; FrameWork -&gt; Node.js and NPM -&gt; Enable即可，如下图所示: 或者更简单的方式就是鼠标点击Node的核心模块高亮处，按组合键Alt+Enter，弹出下拉菜单，最后敲Enter开启代码提示功能，如下图","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/tags/Ubuntu/"},{"name":"Webstorm","slug":"Webstorm","permalink":"https://blog.luckyw.cn/tags/Webstorm/"}],"keywords":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.luckyw.cn/categories/Ubuntu/"}]},{"title":"gulp构建前端自动化","slug":"node-gulp","date":"2016-05-07T16:00:00.000Z","updated":"2016-11-20T11:03:36.990Z","comments":true,"path":"2016/05/08/node-gulp/","link":"","permalink":"https://blog.luckyw.cn/2016/05/08/node-gulp/","excerpt":"目前最知名的构建工具： Gulp、Grunt、NPM + Webpack； grunt是前端工程化的先驱gulp更自然基于流的方式连接任务Webpack最年轻，擅长用于依赖管理，配置稍较复杂推荐使用Gulp，Gulp基于nodejs中stream，效率更好语法更自然,不需要编写复杂的配置文件 基础安装Gulp是基于Node.js的，需要要安装Node.js1、为了确保依赖环境正确，我们先执行几个简单的命令检查。12leo@leo-HP-Pavilion-dv4-Notebook-PC:~$ node -vv4.2.6 Node是一个基于Google V8引擎建立的一个解释器检测Node是否已经安装，如果正确安装的话你会看到所安装的Node的版本号2、接下来看看npm，它是node的包管理工具，可以利用它安装gulp所需的包12leo@leo-HP-Pavilion-dv4-Notebook-PC:~$ npm -v3.5.2 这同样能得到npm的版本号，装Node时已经自动安装了npm","text":"目前最知名的构建工具： Gulp、Grunt、NPM + Webpack； grunt是前端工程化的先驱gulp更自然基于流的方式连接任务Webpack最年轻，擅长用于依赖管理，配置稍较复杂推荐使用Gulp，Gulp基于nodejs中stream，效率更好语法更自然,不需要编写复杂的配置文件 基础安装Gulp是基于Node.js的，需要要安装Node.js1、为了确保依赖环境正确，我们先执行几个简单的命令检查。12leo@leo-HP-Pavilion-dv4-Notebook-PC:~$ node -vv4.2.6 Node是一个基于Google V8引擎建立的一个解释器检测Node是否已经安装，如果正确安装的话你会看到所安装的Node的版本号2、接下来看看npm，它是node的包管理工具，可以利用它安装gulp所需的包12leo@leo-HP-Pavilion-dv4-Notebook-PC:~$ npm -v3.5.2 这同样能得到npm的版本号，装Node时已经自动安装了npm3、开始安装Gulp123npm install -g gulpleo@leo-HP-Pavilion-dv4-Notebook-PC:~$ gulp -v[20:37:10] CLI version 3.9.1 得到gulp的版本号，确认安装成功4、切换到你的在项目根文件夹下，运行1npm install gulp --save-dev //将具体的gulp功能插件局部安装项目下 5、安装gulp功能插件依赖包1npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename--save-dev gulp功能模块的文件会放在项目所在的目录的./node_modules下6、我们目前先使用一些简单的功能: 检查Javascript 编译Sass文件 合并Javascript 压缩合并并重命名Javascript新建gulpfile.js配置文件放在项目根目录下，整个项目目录结构如下:123456789101112131415.├── .git 通过git进行版本控制,项目自动生成这个文件├── node_modules 组件包目录├── dist **发布环境**│ ├── css 样式文件(style.css style.min.css)│ ├── images 图片文件(压缩图片/合并后的图片)│ ├── index.html 静态页面文件(压缩html)│ └── js js文件(main.js main.min.js)├── gulpfile.js gulp配置文件├── package.json 依赖模块json文件,在项目目录下npm install会安装项目所有的依赖模块，简化项目的安装程序└── src **开发环境** ├── images 图片文件 ├── index.html 静态文件 ├── js js文件 └── sass sass文件 现在我们开始编写gulpfile.js文件以分配gulp执行任务，gulpfile.js内容如下:12345678910111213141516171819202122232425262728293031323334353637383940// 引入gulpvar gulp = require(&apos;gulp&apos;);// 引入组件var jshint = require(&apos;gulp-jshint&apos;);//检查jsvar sass = require(&apos;gulp-sass&apos;); //编译Sassvar concat = require(&apos;gulp-concat&apos;);//合并var uglify = require(&apos;gulp-uglify&apos;);//压缩JSvar rename = require(&apos;gulp-rename&apos;);//重命名// 检查js脚本的任务gulp.task(&apos;lint&apos;, function() &#123; gulp.src(&apos;./js/*.js&apos;) //可配置检查脚本的具体名字 .pipe(jshint()) .pipe(jshint.reporter(&apos;default&apos;));&#125;);// 编译Sassgulp.task(&apos;sass&apos;, function() &#123; gulp.src(&apos;./scss/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;./css&apos;));&#125;);// 合并，压缩js文件// 找到js/目录下的所有js文件，合并、重命名、压缩，最后将处理完成的js存放在dist/js/目录下gulp.task(&apos;scripts&apos;, function() &#123; gulp.src(&apos;./js/*.js&apos;) .pipe(concat(&apos;all.js&apos;)) .pipe(gulp.dest(&apos;./dist&apos;)) .pipe(rename(&apos;all.min.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(&apos;./dist&apos;)); console.log(&apos;gulp task is done&apos;);//自定义提醒信息&#125;);.... // 其他任务类似// 定义默认任务,执行gulp会自动执行的任务gulp.task(&apos;default&apos;, function()&#123; gulp.run(&apos;lint&apos;, &apos;sass&apos;, &apos;scripts&apos;); // 监听js文件变化，当文件发生变化后会自动执行任务 gulp.watch(&apos;./js/*.js&apos;, function()&#123; gulp.run(&apos;lint&apos;,&apos;scripts&apos;); &#125;);&#125;); 7、现在，回到命令行窗口，可以直接运行gulp任务12345gulp这将执行定义的default任务，就和以下的命令式同一个意思gulp default当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在单独运行sass任务：gulp sass 8、编译会显示Finished,如果你的JS有什么不好的地方它会提醒，避免一些不必要的错误，十分贴心常见提醒：123456789禁止在同一行声明多个变量请使用 ===/!==来比较true/false或者数值使用对象字面量替代new Array这种形式不要使用全局函数Switch语句必须带有default分支函数不应该有时候有返回值，有时候没有返回值。For循环必须使用大括号If语句必须使用大括号for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染 9、gulp的插件数量很多，可以根据自己的需要进行添加任务常用的gulp插件参考12345678910gulp-imagemin: 压缩图片gulp-ruby-sass: 支持sass，安装此版本需要安装rubygulp-minify-css: 压缩cssgulp-jshint: 检查jsgulp-uglify: 压缩jsgulp-concat: 合并文件gulp-rename: 重命名文件gulp-htmlmin: 压缩htmlgulp-clean: 清空文件夹gulp-livereload: 服务器控制客户端同步刷新（需配合chrome插件LiveReload及tiny-lr）","categories":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/categories/Node/"},{"name":"Gulp","slug":"Node/Gulp","permalink":"https://blog.luckyw.cn/categories/Node/Gulp/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/tags/Node/"},{"name":"Gulp","slug":"Gulp","permalink":"https://blog.luckyw.cn/tags/Gulp/"}],"keywords":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/categories/Node/"},{"name":"Gulp","slug":"Node/Gulp","permalink":"https://blog.luckyw.cn/categories/Node/Gulp/"}]},{"title":"Linux常用命令","slug":"linux-cmd","date":"2016-04-29T16:00:00.000Z","updated":"2016-12-21T03:20:48.528Z","comments":true,"path":"2016/04/30/linux-cmd/","link":"","permalink":"https://blog.luckyw.cn/2016/04/30/linux-cmd/","excerpt":"废了一点时间，装了两次Ubuntu才真正装好，因为装的是双系统，主系统是win10，刚入手Ubuntu还对命令不是很熟悉，所以首先学习下Linux下的常用命令。说实在话，Ubuntu好用的不是一丁点，现在基本都不怎么使用win10了 Terminal(终端)的使用技巧 Up键: 可以调出历史执行记录，快速执行命令Down键: 配合Up键选择历史执行记录执行命令history: 显示历史执行记录Home键: 移动光标到本行开头End键: 移动光标到本行末尾PaUp键: 向上翻页PaDn键: 向下翻页Ctrl+C组合键: 终止当前程序，某些程序也可以用q键退出Ctrl+L组合键: 清屏，也可以在终端输入clearCtrl+Shift+C组合键: 复制Ctrl+Shift+V组合键: 粘贴Tab键: 自动补全命令或文件名，省时准确 查看帮助说明 man/info/help 123man lsinfo lsls --help 下载工具 wget 1234567891011leo@leo-PC:~$ wget http://luckyw.cn/img/1.jpg--2016-4-29 20:30:36-- http://luckyw.cn/img/1.jpg正在解析主机 luckyw.cn (luckyw.cn)... 166.62.28.80正在连接 luckyw.cn (luckyw.cn)|166.62.28.80|:80... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度： 234838 (229K) [image/jpeg]正在保存至: “1.jpg”1.jpg 100%[===================&gt;] 229.33K 416KB/s in 0.6s2016-4-29 20:30:40 (416 KB/s) - 已保存 “1.jpg” [234838/234838]) 查看当前所在的工作目录的全路径 pwd 12leo@leo-PC:~$ pwd/home/leo","text":"废了一点时间，装了两次Ubuntu才真正装好，因为装的是双系统，主系统是win10，刚入手Ubuntu还对命令不是很熟悉，所以首先学习下Linux下的常用命令。说实在话，Ubuntu好用的不是一丁点，现在基本都不怎么使用win10了 Terminal(终端)的使用技巧 Up键: 可以调出历史执行记录，快速执行命令Down键: 配合Up键选择历史执行记录执行命令history: 显示历史执行记录Home键: 移动光标到本行开头End键: 移动光标到本行末尾PaUp键: 向上翻页PaDn键: 向下翻页Ctrl+C组合键: 终止当前程序，某些程序也可以用q键退出Ctrl+L组合键: 清屏，也可以在终端输入clearCtrl+Shift+C组合键: 复制Ctrl+Shift+V组合键: 粘贴Tab键: 自动补全命令或文件名，省时准确 查看帮助说明 man/info/help 123man lsinfo lsls --help 下载工具 wget 1234567891011leo@leo-PC:~$ wget http://luckyw.cn/img/1.jpg--2016-4-29 20:30:36-- http://luckyw.cn/img/1.jpg正在解析主机 luckyw.cn (luckyw.cn)... 166.62.28.80正在连接 luckyw.cn (luckyw.cn)|166.62.28.80|:80... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度： 234838 (229K) [image/jpeg]正在保存至: “1.jpg”1.jpg 100%[===================&gt;] 229.33K 416KB/s in 0.6s2016-4-29 20:30:40 (416 KB/s) - 已保存 “1.jpg” [234838/234838]) 查看当前所在的工作目录的全路径 pwd 12leo@leo-PC:~$ pwd/home/leo 查看当前系统的时间 date 1234567891011leo@leo-PC:~$ date2016年 04月 29日 星期五 20:39:49 CSTleo@leo-PC:~$ date +%Y-%m-%d2016-04-29leo@leo-PC:~$ date +%Y-%m-%d --date=&quot;-1 day&quot; //加减也可以 month | year2016-04-28leo@leo-PC:~$ sudo date -s &quot;2016-04-29 20:42:30&quot; //修改时间2016年 04月 29日 星期五 20:42:30 CST 查看当前登陆用户 who 123#who查看当前在线leo@leo-PC:~$ wholeo tty7 2016-04-29 19:52 (:0) 关机/重启 shutdown/reboot/poweroff 123456shutdown -h now //立即关机shutdown -h +10 //10分钟后关机shutdown -h 12:00:00 //定时关机(12点整)shutdown -r now //立即重启reboot //立即重启poweroff //关机 查看目录信息 ls123ls //列出当前目录下的子节点（不包括隐藏）信息ls -l //列出所有文件（不包括隐藏）的详细信息ls -al //列出所有文件（包括隐藏）的详细信息 注:Linux中以.开头的文件或文件夹均为隐藏文件或隐藏文件夹 切换工作目录 cd123456cd /home/leo //切换到用户主目录cd ~ //切换到用户主目录cd //返回用户主目录cd - //回退到上次所在的目录cd .. //回退到上次所在的目录cd /etc/ //切换到etc目录 创建文件夹 mkdir123mkdir aaa //当前目录下创建aaa目录，相对路径mkdir ~/bbb //在主目录下创建bbb目录，绝对路径mkdir -p aaa/bbb/ccc //级联创建目录 删除文件夹 rm/rmdir123456rmdir aaa //删除aaa目录rm a.txt //删除a.txt文件rm -i a.txt //删除a.txt文件前提示rm -r aaa //递归删除aaa目录及里面的文件及文件夹rm -rf aaa //强制删除aaa目录rm -d aaa //删除空文件夹 移动文件或文件夹 mv1234mv a.txt bbb.txt //将a.txt修改为b.txtmv aaa bbb //将aaa移动到bbb目录下，完成后为bbb/aaamv -i aaa bbb //在移动时，若文件已存在则提示mv test.text aaa/ //将test.text移动到aaa目录下 创建文件 touch123touch a.txt //创建a.txtecho &quot;hello world&quot; &gt; a.txt //将一条指令的输出结果写入到一个文件中，会覆盖原文件内容，如果指定的文件不存在，则会创建出来echo &quot;hello world&quot; &gt;&gt; a.txt //将一条指令的输出结果追加到一个文件中，不会覆盖原文件内容 拷贝 cp123cp a.txt ~ //将a.txt复制到主目录下cp aaa/* bbb //将aaa下所有文件(不包含子文件夹中的所有文件)复制到bbbcp -r aaa bbb //将aaa下所有文件(包含子文件夹中的所有文件)复制到bbb 查看文件内容 cat/more/less/tail/head1234567cat a.txt //只能展示最后布满屏幕的内容more a.txt //逐行显示内容more +100 a.txt //从100行开始显示less a.txt //上下滚动查看内容less +100 //从100行开始显示tail -10 a.txt //查看文件尾部的10行head -10 a.txt //查看文件前10行 查找命令 which/whereis 12which ls //查找可执行的命令所在的路径whereis ls //查找可执行的命令和帮助的位置 网络连通测试 ping 1234567891011leo@leo-PC:~$ ping luckyw.cnPING luckyw.cn (166.62.28.80) 56(84) bytes of data.64 bytes from ip-166-62-28-80.ip.secureserver.net (166.62.28.80): icmp_seq=1 ttl=45 time=107 ms64 bytes from ip-166-62-28-80.ip.secureserver.net (166.62.28.80): icmp_seq=2 ttl=45 time=112 ms64 bytes from ip-166-62-28-80.ip.secureserver.net (166.62.28.80): icmp_seq=3 ttl=45 time=110 ms64 bytes from ip-166-62-28-80.ip.secureserver.net (166.62.28.80): icmp_seq=4 ttl=45 time=108 ms^C--- luckyw.cn ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3003msrtt min/avg/max/mdev = 107.009/109.705/112.942/2.277 msping 166.62.28.80 返回匹配的项目，支持正则 grep 1grep hello a.txt //返回a.txt中包含hello的行 修改文件权限 chmod 从左至右用0-9这些数字来表示第0位确定文件类型，如果为d，则为目录，如果为-，表示为文件，如果为l，表示为链接第1-3位: 确定属主（该文件的所有者owner）拥有该文件的权限第4-6位: 确定属组（所有者的同组用户group）拥有该文件的权限第7-9位: 确定其他用户(others)拥有该文件的权限其中，第1、4、7位表示读权限，如果用r字符表示，则有读权限，权限分为4，如果用-字符表示，则没有读权限第2、5、8位表示写权限，如果用w字符表示，则有写权限，权限分为2，如果用-字符表示没有写权限第3、6、9位表示可执行权限，如果用x字符表示，则有执行权限，权限分为1，如果用-字符表示，则没有执行权限权限分举例:rwxrw-r--的权限分即为764123456chmod g-rw a.txt //为group增加可读可写权限chmod o-rw a.txt //为others增加可读可写权限chmod u+x a.txt //为user(owner)增加可执行权限chmod a-x a.txt //去除所有身份的可执行权限chmod 664 a.txt //a.txt的权限就会修改为rw-rw-r--chmod -R 770 aaa/ //将aaa目录下的所有文件统一修改权限为770，即rwxrwx--- 修改文件所有权 chown123chown leo aaa ## 改变所属用户chown :leo aaa ## 改变所属组chown leo:leo aaa/ ## 同时修改所属用户和所属组 添加一个用户 useradd 1useradd luckyw //添加一个名为luckyw的普通用户 修改用户密码 passwd 12passwd //不带参数更改当前用户密码passwd luckyw //更改luckyw用户密码 压缩处理 tar 参数解释:-c: 创建归档-x: 解压归档-v: 显示处理过程-f: 目标文件，其后必须紧跟目标文件-j: 调用bzip2进行解压缩-z: 调用gzip进行解压缩-t: 列出归档中的文件1234567tar -cvf leo.tar . //将当前目录所有文件归档，.表示当前目录tar -xvf leo.tar //将leo.tar解压到当前目录中tar -cvjf leo.tar.bz2 . //将当前目录所有文件用bzip2进行压缩tar -xvjf leo.tar.bz2 //将leo.tar.bz2用bzip2解压到当前目录tar -cvzf leo.tar.gz . //将当前目录所有文件用gzip进行压缩tar -xvzf filename.tar.gz //将leo.tar.gz用gzip解压到当前目录tar -tf leo.tar //查看leo.tar中的文件 了解更多请参考:Linux命令查询","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://blog.luckyw.cn/categories/Linux/"}]},{"title":"原生JS写Ajax的请求函数","slug":"js-prototype-ajax","date":"2016-04-23T16:00:00.000Z","updated":"2016-11-20T11:00:16.859Z","comments":true,"path":"2016/04/24/js-prototype-ajax/","link":"","permalink":"https://blog.luckyw.cn/2016/04/24/js-prototype-ajax/","excerpt":"JS原生ajax ajax:一种请求数据的方式，不需要刷新整个页面ajax的技术核心是XMLHttpRequest对象ajax请求过程:创建XMLHttpRequest对象、连接服务器、发送请求、接收响应数据下面简单封装一个函数，之后稍作解释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ajax(&#123; url: &quot;./TestXHR.aspx&quot;,//请求地址 type: &quot;POST&quot;,//请求方式 data: &#123;name: &quot;super&quot;, age: 20&#125;,//请求参数 dataType: &quot;json&quot;, success: function (response, xml) &#123; //此处放成功后执行的代码 &#125;, fail: function (status) &#123; //此处放失败后执行的代码 &#125;&#125;);function ajax(options) &#123; options = options || &#123;&#125;; options.type = (options.type || &quot;GET&quot;).toUpperCase(); options.dataType = options.dataType || &quot;json&quot;; var params = formatParams(options.data); //创建 - IE6 - 第一步 if (window.XMLHttpRequest) &#123; var xhr = new XMLHttpRequest(); &#125; else &#123;//IE6及其以下版本浏览器 var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125; //连接和发送 - 第二步 if (options.type == &quot;GET&quot;) &#123; xhr.open(&quot;GET&quot;, options.url + &quot;?&quot; + params, true); xhr.send(null); &#125; else if (options.type == &quot;POST&quot;) &#123; xhr.open(&quot;POST&quot;, options.url, true); //设置表单提交时的内容类型 xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(params); &#125; //接收 - 第三步 xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; var status = xhr.status; if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML); &#125; else &#123; options.fail &amp;&amp; options.fail(status); &#125; &#125; &#125;&#125;//格式化参数function formatParams(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(data[name])); &#125; arr.push((&quot;v=&quot; + Math.random()).replace(&quot;.&quot;, &quot;&quot;)); return arr.join(&quot;&amp;&quot;);&#125;","text":"JS原生ajax ajax:一种请求数据的方式，不需要刷新整个页面ajax的技术核心是XMLHttpRequest对象ajax请求过程:创建XMLHttpRequest对象、连接服务器、发送请求、接收响应数据下面简单封装一个函数，之后稍作解释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ajax(&#123; url: &quot;./TestXHR.aspx&quot;,//请求地址 type: &quot;POST&quot;,//请求方式 data: &#123;name: &quot;super&quot;, age: 20&#125;,//请求参数 dataType: &quot;json&quot;, success: function (response, xml) &#123; //此处放成功后执行的代码 &#125;, fail: function (status) &#123; //此处放失败后执行的代码 &#125;&#125;);function ajax(options) &#123; options = options || &#123;&#125;; options.type = (options.type || &quot;GET&quot;).toUpperCase(); options.dataType = options.dataType || &quot;json&quot;; var params = formatParams(options.data); //创建 - IE6 - 第一步 if (window.XMLHttpRequest) &#123; var xhr = new XMLHttpRequest(); &#125; else &#123;//IE6及其以下版本浏览器 var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125; //连接和发送 - 第二步 if (options.type == &quot;GET&quot;) &#123; xhr.open(&quot;GET&quot;, options.url + &quot;?&quot; + params, true); xhr.send(null); &#125; else if (options.type == &quot;POST&quot;) &#123; xhr.open(&quot;POST&quot;, options.url, true); //设置表单提交时的内容类型 xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(params); &#125; //接收 - 第三步 xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; var status = xhr.status; if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML); &#125; else &#123; options.fail &amp;&amp; options.fail(status); &#125; &#125; &#125;&#125;//格式化参数function formatParams(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(data[name])); &#125; arr.push((&quot;v=&quot; + Math.random()).replace(&quot;.&quot;, &quot;&quot;)); return arr.join(&quot;&amp;&quot;);&#125; 创建 IE7及其以上版本中支持原生的XHR对象，因此可以直接用:var oAjax = new XMLHttpRequest();IE6及其之前的版本中，XHR对象是通过MSXML库中的一个ActiveX对象实现的。有的书中细化了IE中此类对象的三种不同版本，即MSXML2.XMLHttp、MSXML2.XMLHttp.3.0和MSXML2.XMLHttp.6.0；个人感觉太麻烦，可以直接使用下面的语句创建： var oAjax=new ActiveXObject(’Microsoft.XMLHTTP’); 连接和发送 open()函数的三个参数：请求方式、请求地址、是否异步请求GET请求方式是通过URL参数将数据提交到服务器的，POST则是通过将数据作为send的参数提交到服务器POST请求中，在发送数据之前，要设置表单提交的内容类型提交到服务器的参数必须经过encodeURIComponent()方法进行编码，实际上在参数列表key=value的形式中，key和value都需要进行编码，因为会包含特殊字符。每次请求的时候都会在参数列表中拼入一个 “v=xx” 的字符串，这样是为了拒绝缓存，每次都直接请求到服务器上 encodeURI():用于整个URI的编码，不会对本身属于URI的特殊字符进行编码，如冒号、正斜杠、问号和井号；其对应的解码函数decodeURI()encodeURIComponent():用于对URI中的某一部分进行编码，会对它发现的任何非标准字符进行编码；其对应的解码函数decodeURIComponent()接收接收到响应后，响应的数据会自动填充XHR对象，相关属性如下 responseText:响应返回的主体内容，为字符串类型responseXML:如果响应的内容类型是text/xml或application/xml，这个属性中将保存着相应的xml数据，是XML对应的document类型status:响应的HTTP状态码statusText:HTTP状态文本 XHR对象的readyState属性表示请求/响应过程的当前活动阶段，这个属性的值如下: 0-未初始化，尚未调用open()方法1-启动，调用了open()方法，未调用send()方法2-发送，已经调用了send()方法，未接收到响应3-接收，已经接收到部分响应数据4-完成，已经接收到全部响应数据 只要readyState的值变化，就会调用readystatechange事件，为了逻辑上通顺，可以把readystatechange放到send之后，因为send时请求服务器，会进行网络通信，需要时间，在send之后指定readystatechange事件处理程序也是可以的在readystatechange事件中，先判断响应是否接收完成，然后判断服务器是否成功处理请求，xhr.status 是状态码，状态码以2开头的都是成功，304表示从缓存中获取，上面的代码在每次请求的时候都加入了随机数，所以不会从缓存中取值，故该状态不需判断。ajax请求是不能跨域的 JSONP JSONP是一种跨域请求方式。主要原理是利用了script标签可以跨域请求的特点，由其src属性发送请求到服务器，服务器返回js代码，网页端接受响应，然后就直接执行了，这和通过script标签引用外部文件的原理是一样的JSONP由两部分组成：回调函数和数据，回调函数一般是由网页端控制，作为参数发往服务器端，服务器端把该函数和数据拼成字符串返回比如网页端创建一个script标签，并给其src赋值为 http://www.example.com/jsonp/?callback=process， 此时网页端就发起一个请求。服务端将要返回的数据拼好最为函数的参数传入，服务端返回的数据格式类似process({‘name’:’superfiresun’})，网页端接收到了响应值，因为请求者是script，所以相当于直接调用process方法，并且传入了一个参数单看响应返回的数据，JSONP比ajax方式就多了一个回调函数1234567891011121314151617181920212223242526272829303132333435363738function jsonp(options) &#123; options = options || &#123;&#125;; if (!options.url || !options.callback) &#123; throw new Error(&quot;参数不合法&quot;); &#125; //创建 script 标签并加入到页面中 var callbackName = (&apos;jsonp_&apos; + Math.random()).replace(&quot;.&quot;, &quot;&quot;); var oHead = document.getElementsByTagName(&apos;head&apos;)[0]; options.data[options.callback] = callbackName; var params = formatParams(options.data); var oS = document.createElement(&apos;script&apos;); oHead.appendChild(oS); //创建jsonp回调函数 window[callbackName] = function (json) &#123; oHead.removeChild(oS); clearTimeout(oS.timer); window[callbackName] = null; options.success &amp;&amp; options.success(json); &#125;; //发送请求 oS.src = options.url + &apos;?&apos; + params; //超时处理 if (options.time) &#123; oS.timer = setTimeout(function () &#123; window[callbackName] = null; oHead.removeChild(oS); options.fail &amp;&amp; options.fail(&#123;message: &quot;超时&quot;&#125;); &#125;, time); &#125;&#125;;//格式化参数function formatParams(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(data[i])); &#125; return arr.join(&apos;&amp;&apos;);&#125; 因为script标签的src属性只在第一次设置的时候起作用，导致script标签没法重用，所以每次完成操作之后要移除 JSONP这种请求方式中，参数依旧需要编码 如果不设置超时，就无法得知此次请求是成功还是失败 模仿JQuery中的ready()事件 DOMContentLoaded事件在DOM加载完成之后立即执行，始终会在load之前执行IE9+、FF、Chrome、Safari3.1+和Opera9+都支持该事件对于不支持该事件的浏览器，可以使用如下代码：123setTimeout(function()&#123; // 代码块&#125;, 0) ; DOMContentLoaded事件只能通过DOM2级方式添加，即采用addEventListener()/attachEvent()方式添加才能够使用。事件对象不会提供任何额外信息readystatechange事件IE为DOM文档中的某些部分(区别于XHR对象的readystatechange事件)提供了该事件，这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。支持该事件的对象都有一个readyState属性，注意，不是 event事件对象。IE、Firefox4+和Opera支持该事件。readyState属性的值如下： uninitialized - 未初始化：对象存在但尚未初始化loading - 正在加载：对象正在加载数据loaded - 加载完毕，对象加载数据完毕interactive - 交互：可以操作对象了，但还没有完全加载complete - 完成：对象已经加载完成 并非所有的对象都会经历readyState的这几个阶段，如果这个阶段不适用某个对象，则该对象完全可能跳过该阶段，并没有规定哪个阶段适用于哪个对象。这意味着 readystatechange事件经常会少于4次，相对应的readyState属性值也不是连续的对于document而言，interactive和complete阶段会在于 DOMContentLoaded大致相同的时刻触发readystatechange事件load事件和readystatechange事件的触发顺序会因页面的外部资源的多少而变化，也就是说，readystatechange事件并不会一直在load事件之前执行。外部资源越多，对readystatechange事件就越有利interactive和complete的顺序也是不一致的，谁都有可能先执行，引用的外部资源越多，对交互阶段越有利。所以为了尽可能早的执行代码，两个状态要同时判断doScrollIE5.5+支持，当页面中有滚动条时，可以用 doScroll(&quot;right&quot;)/doScroll(&quot;down&quot;)等来移动滚动条，这个方法只有等DOM加载完成以后才能用，所以在IE低版本浏览器中可以通过这个属性判断DOM 结构是否加载完成。介绍这个属性主要是模仿jquery中的解决方案12345678910111213141516171819202122232425262728293031323334353637383940function ready(readyFn) &#123; //非IE浏览器 if (document.addEventListener) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, function () &#123; readyFn &amp;&amp; readyFn(); &#125;, false); &#125; else &#123; //方案1和2 哪个快用哪一个 var bReady = false; //方案1 document.attachEvent(&apos;onreadystatechange&apos;, function () &#123; if (bReady) &#123; return; &#125; if (document.readyState == &apos;complete&apos; || document.readyState == &quot;interactive&quot;) &#123; bReady = true; readyFn &amp;&amp; readyFn(); &#125; ; &#125;); //方案2 //jquery也会担心doScroll会在iframe内失效，此处是判断当前页是否被放在了iframe里 if (!window.frameElement) &#123; setTimeout(checkDoScroll, 1); &#125; function checkDoScroll() &#123; try &#123; document.documentElement.doScroll(&quot;left&quot;); if (bReady) &#123; return; &#125; bReady = true; readyFn &amp;&amp; readyFn(); &#125; catch (e) &#123; // 不断检查 doScroll 是否可用 - DOM结构是否加载完成 setTimeout(checkDoScroll, 1); &#125; &#125;; &#125;&#125;; 注：setTimeout(checkDoScroll, 1); 目的是让浏览器尽快执行 checkDoScroll函数，间隔时间设置为1ms，对当下的浏览器来说是不太可能的。每个浏览器都有自己默认的最小间隔时间，即使时间设置为最小间隔时间，也只是代表隔这些时间过去之后，javascript会把checkDoScroll加入到执行队列中，如果此时JavaScript进程空闲，则会立即执行该代码转：前端乱炖","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"常用Git命令清单","slug":"git-list-all","date":"2016-04-16T16:00:00.000Z","updated":"2016-11-20T10:51:04.332Z","comments":true,"path":"2016/04/17/git-list-all/","link":"","permalink":"https://blog.luckyw.cn/2016/04/17/git-list-all/","excerpt":"Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库 123456# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码$ git clone [url]","text":"Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库 123456# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码$ git clone [url] 配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）1234567# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件 123456789101112131415# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交 12345678910111213# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支 1234567891011121314151617181920212223242526272829# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签 123456789101112131415161718# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息 1234567891011121314151617181920212223242526272829303132333435363738394041# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步 12345678910111213141516# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销 12345678910111213141516171819202122# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他 12# 生成一个可供发布的压缩包$ git archive 附上:git常用命令速查表 转:常用 Git 命令清单——阮一峰","categories":[{"name":"GIT","slug":"GIT","permalink":"https://blog.luckyw.cn/categories/GIT/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"https://blog.luckyw.cn/tags/GIT/"}],"keywords":[{"name":"GIT","slug":"GIT","permalink":"https://blog.luckyw.cn/categories/GIT/"}]},{"title":"13个CSS高级技巧","slug":"css-advanced-skills","date":"2016-04-09T16:00:00.000Z","updated":"2016-11-20T09:24:37.223Z","comments":true,"path":"2016/04/10/css-advanced-skills/","link":"","permalink":"https://blog.luckyw.cn/2016/04/10/css-advanced-skills/","excerpt":"使用:not()在菜单上添加/取消边框 很多人会这样给导航添加边框，然后给最后一个取消掉：12345678/* add border */.nav li &#123; border-right: 1px solid #666;&#125;/* remove border */.nav li:last-child &#123; border-right: none;&#125; 其实，用CSS3的:not()可以简化为下面的代码：123.nav li:not(:last-child) &#123; border-right: 1px solid #666;&#125; 当然，你也可以使用.nav li + li甚至.nav li:first-child ~ li，但是使用:not()可以使意图更加明确所有主流浏览器均支持:not选择器，除了IE8及更早的版本","text":"使用:not()在菜单上添加/取消边框 很多人会这样给导航添加边框，然后给最后一个取消掉：12345678/* add border */.nav li &#123; border-right: 1px solid #666;&#125;/* remove border */.nav li:last-child &#123; border-right: none;&#125; 其实，用CSS3的:not()可以简化为下面的代码：123.nav li:not(:last-child) &#123; border-right: 1px solid #666;&#125; 当然，你也可以使用.nav li + li甚至.nav li:first-child ~ li，但是使用:not()可以使意图更加明确所有主流浏览器均支持:not选择器，除了IE8及更早的版本 给body添加line-height属性 你不需要为&lt;p&gt;、&lt;h*&gt;分别添加line-height属性，相反的，只需要添加到body上即可：123body &#123; line-height: 1;&#125; 这样，文本元素就可以很容易的从body继承该属性 垂直居中 可以垂直居中任何元素：1234567891011html, body &#123; height: 100%; margin: 0;&#125;body &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 注:flexbox在IE11下存在一些bug 使用逗号分割列表 使列表看起来像是用逗号分割的：123ul &gt; li:not(:last-child)::after &#123; content: &quot;,&quot;;&#125; 通过:not()伪类去掉最后一个元素后面的逗号 使用负的nth-child选取元素 使用负的nth-child在1到n之间选择元素：1234567li &#123; display: none;&#125;/* 选择第1到3个元素并显示它们 */li:nth-child(-n+3) &#123; display: block;&#125; 当然，如果你了解:not()的话，还可以这么做：123li:not(:nth-child(-n+3)) &#123; display: none;&#125; 使用SVG作icon图标 没什么理由不使用SVG作icon图标:123.logo &#123; background: url(&quot;logo.svg&quot;);&#125; SVG对于任何分辨率的缩放效果都很好，并且支持 IE9+所有浏览器，所以，放弃使用png、jpg、gif文件吧注：以下代码对于使用辅助设备上网的用户可以提升可访问性：123.no-svg .icon-only:after &#123; content: attr(aria-label);&#125; 优化显示文本 有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：12345html &#123; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;&#125; 注：请负责任地使用optimizeLegibility。此外IE/Edge不支持text-rendering 使用max-height实现纯CSS幻灯片 使用max-height与超出隐藏实现纯CSS的幻灯片：12345678.slider ul &#123; max-height: 0; overlow: hidden;&#125;.slider:hover ul &#123; max-height: 1000px; transition: .3s ease; /* animate to max-height */&#125; 继承box-sizing 让box-sizing继承自html：123456html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125; 这使得在插件或者其他组件中修改box-sizing属性变得更加容易 设置表格相同宽度 123.calendar &#123; table-layout: fixed;&#125; 使用Flexbox来避免Margin Hacks 在做多列布局的时候，可以通过Flexbox的space-between属性来避免nth-、first-、 last-child等hacks:1234567.list &#123; display: flex; justify-content: space-between;&#125;.list .person &#123; flex-basis: 23%;&#125; 这样，列之间的空白就会被均匀的填满 对空链接使用属性选择器 当&lt;a&gt;中没有文本而href不为空的时候，显示其链接：123a[href^=&quot;http&quot;]:empty::before &#123; content: attr(href);&#125; 文本溢出省略的处理方法单行文本溢出12345.inline&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文本溢出12345678.foo&#123; display: -webkit-box!important; overflow: hidden; text-overflow: ellipsis; word-break: break-all; -webkit-box-orient: vertical;/*方向*/ -webkit-line-clamp:4;/*显示多少行文本*/&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"前端知识资源整合","slug":"front-knowledge-collect","date":"2016-04-02T16:00:00.000Z","updated":"2016-11-20T10:48:19.392Z","comments":true,"path":"2016/04/03/front-knowledge-collect/","link":"","permalink":"https://blog.luckyw.cn/2016/04/03/front-knowledge-collect/","excerpt":"HTML:对Web标准的理解、浏览器内核差异、兼容性、hackCSS:布局、盒子模型、选择器优先级及使用、HTML5、CSS3、移动端适应JavaScript:数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、内存泄漏、事件机制、异步装载回调、模板引擎、Nodejs、JSON、ajax等其他:HTTP、安全、正则、优化、重构、响应式、移动端、团队协作、可维护、SEO、UED、架构、职业生涯 Cookie的优劣 cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的 优点:极高的扩展性和可用性 通过良好的编程，控制保存在cookie中的session对象的大小通过加密和安全传输技术SSL，减少cookie被破解的可能性只在cookie中存放不敏感数据，即使被盗也不会有重大损失控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie 缺点: Cookie数量和长度的限制:每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉安全性问题:如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了有些状态不可能保存在客户端:例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用","text":"HTML:对Web标准的理解、浏览器内核差异、兼容性、hackCSS:布局、盒子模型、选择器优先级及使用、HTML5、CSS3、移动端适应JavaScript:数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、内存泄漏、事件机制、异步装载回调、模板引擎、Nodejs、JSON、ajax等其他:HTTP、安全、正则、优化、重构、响应式、移动端、团队协作、可维护、SEO、UED、架构、职业生涯 Cookie的优劣 cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的 优点:极高的扩展性和可用性 通过良好的编程，控制保存在cookie中的session对象的大小通过加密和安全传输技术SSL，减少cookie被破解的可能性只在cookie中存放不敏感数据，即使被盗也不会有重大损失控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie 缺点: Cookie数量和长度的限制:每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉安全性问题:如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了有些状态不可能保存在客户端:例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用 浏览器本地存储 在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStoragehtml5中的Web Storage包括了两种存储方式:sessionStorage和localStoragesessionStorage用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 web storage和cookie的区别 Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用除此之外，Web Storage拥有setItem、getItem、removeItem、clear等方法，不像cookie需要前端开发者自己封装setCookie、getCookie但是Cookie也是不可以或缺的:Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storagelocalStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 CSS 相关问题 display:none和visibility:hidden的区别？ display:none：隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当它从来不存在visibility:hidden：隐藏对应的元素，但是在文档布局中仍保留原来的空间 CSS中 link 和@import 的区别是？ link属于HTML标签，而@import是CSS提供的;页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载import只在IE5以上才能识别，而link是HTML标签，无兼容问题 position的absolute与fixed共同点与不同点:共同点： 改变行内元素的呈现方式，display被置为block让元素脱离普通流，不占据空间默认会覆盖到非定位元素上 不同点： absolute的根元素是可以设置的，而fixed的根元素固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的 CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？CSS选择符: id选择器（#myid）类选择器（.myclassname）标签选择器（div, h1, p）相邻选择器（h1 + p）子选择器（ul &gt; li）后代选择器（li a）通配符选择器（*）属性选择器（a[rel = &quot;external&quot;]）伪类选择器（a:hover,li:nth-child） 可继承的样式： font-size font-family color, text-indent不可继承的样式：border padding margin width height优先级就近原则，同权重情况下样式定义最近者为准载入样式以最后载入的定位为准优先级为: !important &gt; id &gt; class &gt; tagimportant比内联优先级高,但内联比id要高 CSS3新增伪类举例： p:first-of-type 选择属于其父元素的首个p元素的每个p元素p:last-of-type 选择属于其父元素的最后p元素的每个p元素p:only-of-type 选择属于其父元素唯一的p元素的每个p元素p:only-child 选择属于其父元素的唯一子元素的每个p元素p:nth-child(2) 选择属于其父元素的第二个子元素的每个p元素:enabled :disabled 控制表单控件的禁用状态:checked 单选框或复选框被选中 列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？display: block 像块类元素一样显示inline 像行内元素类型一样显示inline-block 像行内元素一样显示，但其内容像块类元素一样显示list-item 象块类元素一样显示，并添加样式列表标记 absolute: 生成绝对定位的元素，相对于static定位以外的第一个祖先元素进行定位 fixed（老IE不支持）: 生成绝对定位的元素，相对于浏览器窗口进行定位 relative: 生成相对定位的元素，相对于其在普通流中的位置进行定位 static:默认值，没有定位，元素出现在正常的流中inherit:规定从父元素继承position属性的值 CSS3有哪些新特性？ CSS3实现圆角border-radius，阴影box-shadow，对文字加特效text-shadow，线性渐变gradient，旋转transformtransform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,平移,倾斜增加了更多的CSS选择器，多背景rgba在CSS3中唯一引入的伪元素是::selection媒体查询，多栏布局border-image 为什么要初始化CSS样式因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化最简单的初始化方法就是：1*&#123;padding: 0; margin: 0;&#125;（不建议） 解释下 CSS sprites，以及你要如何在页面或网站中使用它。CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的background-image，background-repeat，background-position的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个 html语义化 去掉或者丢失样式的时候能够让页面呈现出清晰的结构有利于SEO:和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化 Doctype作用? 严格模式与怪异模式如何区分？它们有何意义?&lt;!DOCTYPE&gt;声明位于文档中的最前面，处于&lt;html&gt;标签之前。告知浏览器以何种模式来解析渲染文档严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行在怪异模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作DOCTYPE不存在或格式不正确会导致文档以怪异模式呈现 常见兼容性问题？ png24位的图片在IE6浏览器上出现背景，解决方案是做成PNG8，也可以引用一段脚本处理 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一，但并不推荐 IE6双边距问题:在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin会加倍#box{ float:left; width:10px; margin:0 0 0 10px;}这种情况之下IE会产生向左20px的距离，解决方案是在float的标签样式控制中加入_display:inline,将其转化为行内属性。_这个符号只有ie6会识别 渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用\\9这一标记，将IE游览器从所有情况中分离出来。接着，再次使用+将IE8和IE7、IE6分离开来，这样IE8已经独立识别 123456.bb&#123; background-color:#f1ee18;/*所有识别*/ background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/&#125; IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性Firefox下,只能使用getAttribute()获取自定义属性解决方法:统一通过getAttribute()获取自定义属性 IE下,event对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性解决方法：条件注释，缺点是在IE浏览器下可能会增加额外的HTTP请求数 Chrome中文界面下默认会将小于12px的文本强制按照12px显示, 可通过加入CSS属性-webkit-text-size-adjust: none;解决 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了，解决方法是改变CSS属性的排列顺序(爱恨规则):L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。现在可以使用HTML5推荐的写法：&lt;doctype html&gt; 上下margin重合问题ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom 浮动元素引起的问题和解决办法 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留浮动元素引起的问题： 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决方法：使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：12.clearfix:after&#123;content: &quot;&quot;;display: block;height: 0;clear: both;visibility: hidden;&#125;.clearfix&#123;display: inline-block;&#125; /* for IE/Mac */ IE 8以下版本的浏览器中的盒模型有什么不同 IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框 DOM操作——怎样添加、移除、移动、复制、创建和查找节点。 1.创建新节点123createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 2.添加、移除、替换、插入1234appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点 3.查找123getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5现在已经不是SGML的子集，主要是关于图像、位置、存储、多任务等功能的增加。 拖拽释放API语义化更好的内容标签音频、视频API画布API地理API本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失sessionStorage的数据在浏览器关闭后自动删除表单控件，calendar、date、time、email、url、search新的技术webworker, websocket, Geolocation 移除的元素 纯表现的元素:basefont，big，center，font, s，strike，tt，u对可用性产生负面影响的元素:frame，frameset，noframes 支持HTML5新标签：IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架123&lt;!--[if lt IE 9]&lt;script src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]--&gt; 减少页面加载时间的方法 1.优化图片2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）3.优化CSS4.网址后加斜杠5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了6.减少http请求（合并文件，合并图片） null和undefined的区别？ null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN当声明的变量还未被初始化时，变量的默认值为undefinednull用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是: 1.变量被声明了，但没有赋值时，就等于undefined2.调用函数时，应该提供的参数没有提供，该参数等于undefined3.对象没有赋值的属性，该属性的值为undefined4.函数没有返回值时，默认返回undefined null表示”没有对象”，即该处不应该有值。典型用法是: 1.作为函数的参数，表示该函数的参数不是对象2.作为对象原型链的终点 new操作符具体干了什么呢? 1、创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型2、属性和方法被加入到this引用的对象中3、新创建的对象由this所引用，并且最后隐式的返回this 123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); JSON JSON是一种轻量级的数据交换格式它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小{‘age’:’12’, ‘name’:’back’} js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js 如何解决跨域问题? jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面jsonp的原理是动态插入script标签 documen.write和 innerHTML的区别 document.write只能重绘整个页面innerHTML可以重绘页面的一部分 什么叫优雅降级和渐进增强？优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效 渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用 http状态码有那些？分别代表是什么意思？ 100-199 用于指定客户端应相应的某些动作200-299 用于表示请求成功300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息400-499 用于指出客户端的错误 400 语义有误，当前请求无法被服务器理解 401 当前请求需要用户验证 403 服务器已经理解请求，但是拒绝执行它 500-599 用于支持服务器错误 503 – 服务不可用 ajax过程 创建XMLHttpRequest对象,也就是创建一个异步调用对象 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 设置响应HTTP请求状态变化的函数 发送HTTP请求 获取异步调用返回的数据 使用JavaScript和DOM实现局部刷新 请解释一下 JavaScript 的同源策略 同源策略指的是：协议、域名、端口相同，同源策略是一种安全协议指一段脚本只能读取来自同一来源的窗口和文档的属性 为什么要有同源限制？ 比如一个黑客程序，他利用iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名、密码就轻松到手了 什么是 “use strict”; ? 使用它的好处和坏处分别是什么？ ES5添加了第二种运行模式:严格模式。顾名思义，这种模式使得Javascript在更严格的条件下运行设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行速度 为未来新版本的Javascript做好铺垫 注：经过测试IE6、7、8、9均不支持严格模式缺点： 现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被合并后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节 GET和POST的区别，何时使用POST？ GET:一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符POST:一般用于修改服务器上的资源，对所发送的信息没有限制GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值然而，在以下情况中，请使用POST请求: 无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST没有数据量限制）发送包含未知字符的用户输入时，POST比GET更稳定也更可靠 eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 写一个通用的事件侦听器函数? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667luckyw.Event = &#123; readyEvent: function(fn) &#123; if (fn == null) &#123; fn = document; &#125; var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, addEvent: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&apos;on&apos; + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element[&apos;on&apos; + type] = handler; &#125; &#125;, removeEvent: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent(&apos;on&apos; + type, handler); &#125; else &#123; element[&apos;on&apos; + type] = null; &#125; &#125;, stopPropagation: function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, getEvent: function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125; &#125;; JavaScript原型，原型链？有什么特点？ 原型对象也是普通的对象，是对象一个自带隐式的__proto__属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链原型链是由一些用来继承和共享属性的对象组成的对象链 如何获取UA？ 123456function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent;&#125;","categories":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/tags/WEB/"}],"keywords":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}]},{"title":"Flexbox布局","slug":"css-flexbox","date":"2016-03-27T16:00:00.000Z","updated":"2016-11-20T10:43:05.897Z","comments":true,"path":"2016/03/28/css-flexbox/","link":"","permalink":"https://blog.luckyw.cn/2016/03/28/css-flexbox/","excerpt":"Flexbox Layout，W3C官方称为CSS弹性盒子布局，是在CSS3中定义的一种新的布局模式。Flexbox可以控制在容器内的子元素的对齐方式、排列方式以及排序顺序，即使其子元素的尺寸是未知或者动态的情况下。弹性容器的主要特点就是能够调整其子元素的宽度或者高度以使其能在不同分辨率的屏幕下能用最好的方式去填充可用空间Flex布局的主要思想是让容器能使其子元素的宽高（或其他属性）能够以最好的方式去填充可用空间（主要是去适应不同的设备跟分辨率）。一个Flex弹性盒子能让子元素填充可用空间或者为了阻止子元素超出区域而进行收缩Flexbox布局常用于小的应用程序组件之中，而CSS Grid布局模块将应用于大规模的布局之中下面就用codepen代码演示的方式来先简单介绍Flex属性的原理，不同的属性是怎么样使用以及如何影响控制元素的布局的: 基础知识 在开始这部分知识介绍之前，我们先来看上面的这张图，简单了解一下Flex布局的盒子模型以及相关的术语:flex盒子模型由容器flex container以及容器的直接子元素flex item组成以容器flex container定义，有主坐标main axis以及纵坐标cross axis，主坐标为默认横向，默认从左到右，纵坐标默认为纵向，默认从上到下（当布局排列方式变化的时候，main axis跟cross axis的方向也会跟着变化）子元素（flex item）在main axis方向的尺寸为main size，在cross axis方向的尺寸为cross size如果你想了解有关这方面更详细的信息，可以阅读W3C官方中有关于Flexbox模块的相关资料。","text":"Flexbox Layout，W3C官方称为CSS弹性盒子布局，是在CSS3中定义的一种新的布局模式。Flexbox可以控制在容器内的子元素的对齐方式、排列方式以及排序顺序，即使其子元素的尺寸是未知或者动态的情况下。弹性容器的主要特点就是能够调整其子元素的宽度或者高度以使其能在不同分辨率的屏幕下能用最好的方式去填充可用空间Flex布局的主要思想是让容器能使其子元素的宽高（或其他属性）能够以最好的方式去填充可用空间（主要是去适应不同的设备跟分辨率）。一个Flex弹性盒子能让子元素填充可用空间或者为了阻止子元素超出区域而进行收缩Flexbox布局常用于小的应用程序组件之中，而CSS Grid布局模块将应用于大规模的布局之中下面就用codepen代码演示的方式来先简单介绍Flex属性的原理，不同的属性是怎么样使用以及如何影响控制元素的布局的: 基础知识 在开始这部分知识介绍之前，我们先来看上面的这张图，简单了解一下Flex布局的盒子模型以及相关的术语:flex盒子模型由容器flex container以及容器的直接子元素flex item组成以容器flex container定义，有主坐标main axis以及纵坐标cross axis，主坐标为默认横向，默认从左到右，纵坐标默认为纵向，默认从上到下（当布局排列方式变化的时候，main axis跟cross axis的方向也会跟着变化）子元素（flex item）在main axis方向的尺寸为main size，在cross axis方向的尺寸为cross size如果你想了解有关这方面更详细的信息，可以阅读W3C官方中有关于Flexbox模块的相关资料。 使用方法（属性介绍） 这里我们将Flex盒子模型拆分为容器flex container和子项flex item来分别介绍其拥有的属性，以及使用codepen代码演示的方式来具体介绍flex布局的使用方法容器（flex container）：1.display：该属性定义定义了容器是以块状（flex）还是行内元素（inline-flex）的方式显示，改属性的设置能让其子项具有弹性上下文的属性:注:在使用flexbox弹性布局的时候此属性的设置很重要，必不可少 2.flex-direction:改属性主要决定子项flex item在容器内的排列方式：- row,表示flex items以横向且从左到右的方式排列- row-reverse,表示flex items以横向且从右到左的方式排列- column,表示flex items以纵向且从上到下的方式排列- column-reverse,表示flex items以纵向且从下到上的方式排列 3.flex-wrap默认情况下会让容器内的子项flex item保持在一行内，但你可以通过这个属性来设置让容器内的子项是否换行（/列），这个属性结合着flex-direction属性可以决定换行后新的一行或一列的排序方式这个属性对应属性值跟文本是否换行的属性值一致(但这里对应的是换行后新的一行跟上一行的排序方式): nowrap，表示容器内的子项flex items保持在一行或一列（当flex-direction为column或column-reverse的时候）不换行（/列） wrap，跟nowrap相反，表示flex items换行或换列，但以默认（左到右或上到下）的方式排列 wrap-reverse，表示flex items换行且反向排列（右到左或下到上） 4.flex-flow该属性是上面两个属性flex-direction和flex-wrap属性的简写形式：1flex-flow:flex-direction flex-wrap 5.justify-content这个属性定义了子项flex item在横轴方向的对齐方式，当flex item的尺寸在横轴方向都是不变的或者达到最大尺寸的情况下，用来分配额外剩余的可用空间，或者当flex item在横轴排布要超出容器的时候，进行压缩控制： flex-start(默认值)，子项在main轴开始方向对齐 flex-end,子项在main轴结尾方向对齐 center，子项在main轴居中对齐 space-between，子项始终保持在一行，main轴两端对齐 space-around，子项等间距对齐，但第一个元素距离容器左边的间隔是跟下一个元素间隔的二分之一，因为第一个元素右边有一个单元的间隔，第二个元素左边也有一个单元的间隔 注:这里的开始结尾方向，如果你设置的justify-content值为flex-start，但你的flex-direction值为row-reverse的话，因为子项是从右到左排列的，所以开始方向是在右边，所以flex-start的对齐方式应该是右对齐。flex-end的结尾方向也一样，受flex-direction值的影响。结合着flex-wrap属性的话，换行后的元素对齐方式跟第一行一致6.align-items 该属性定义了子项在纵轴方向的对齐方式，可以把它想象为justify-content在纵轴方向的定义： flex-start，子项在cross轴方向以开始方向对齐； flex-end，子项在cross轴方向以结尾方向对齐； center，子项在cross轴方向居中对齐（该属性值能很方便地让元素在容器内垂直居中对齐） baseline，子项在cross轴方向以其文本的基准线对齐 stretch（默认值），子项在cross轴方向填满整个容器（当固定尺寸的时候该属性不生效） 上面这个实例中的第一个跟第五个我用了column的排列方向来验证flex-direction值对align-items属性的影响 7.align-content该属性定义的是多行（/多列）的情况下，所有行/列在cross axis方向的对齐方式，跟justify-content（或align-items）对子项对齐方式的定义类似，不过justify-content（或align-items）是针对子项对齐，而该属性对应的是多行/多列的对齐方式 注:justify-content属性跟align-items属性的时候，我没有直接说justify-content是flex items在横轴方向的对齐方式，而是在main axis方向的对齐方向，也没有说align-items是flex items在纵轴方向的对齐方式（或align-content是对多行元素在纵轴方向的对齐方式），同样也是说是在cross axis方向的对齐方式。这是因为当flex-direction是row的时候，main axis是横向的，而当该值为cloumn的时候，main axis则是纵向的。所以justify-content和align-items以及align-content属性对flex items对齐方式的也同样受flex-direction值的影响。上面这个实例中的第五个我用了column的排列方向来验证flex-direction值对align-content属性的影响好了，到这为止，对容器属性的所有介绍就结束了，下边就是对子项属性的介绍了子项（flex item）：1）order该属性接收一个整数值（负数也生效），数值越小的子项排在越前： 2)flex-grow该属性定义了子项在有需要的时候进行尺寸扩展，接收一个无单位的数值作为比例（负数值无效），他决定了该子项占用多少容器内可用的空间。当所有的子项都是设置了该属性为1的时候，容器内剩余的可用空间就平分给每个子项，当某个子项的flex-grow值为2的时候，该子项就占用两倍于其他子项的可用空间。 3）flex-shrink该属性定义了该子项在必要时候的收缩属性，跟flex-grow的效果相反，使用方法一致，负数值无效 4）flex-basis定义该子项默认的初始尺寸，它可以是一个长度值也可以是一个关键词，跟width和height属性相同，用来指定子项初始的尺寸值。默认值为auto，但取值为auto的时候，有个待解决的问题: 5）flex该属性是flex-grow，flex-shrink，flex-basis三个值的简写形式，默认值为0 1 auto，其中第二三个属性flex-shrink和flex-basis值是可选的:6）align-self对比align-items属性，我们知道这个是针对某个子项在cross axis方向的对齐方式定义，该属性可以覆盖对容器上定义的align-items属性:注:在flexbox布局中，float,clear,vertical-align属性对子项均无效这里有个工具可以让大家能够可视化地去调试Flexbox的各个参数，以及生成对应的代码:简单调试Flexbox属性，以及生成相应的代码工具好了，终于对子项的所有属性也介绍完了，下边我们就将结合了简单的实例来看看flexbox具体能怎么用，有什么用？ Flexbox布局的简单应用 1、让一个元素在容器内完美居中： 在以前我们为了垂直居中用尽各种奇淫技巧的案例，当我们用flexbox布局的时候，简单的几行代码，实现了完美的居中，不管是在水平还是垂直方向，不管是在已知元素尺寸还是未知元素尺寸的情况下，简直就是”完美”。居中的这个在我们实际的需求中有个常见的场景就是在做移动端页面的时候，一个要求水平且垂直居中的浮层：2、实现一个简单的响应式导航栏 这个例子是大家可以在不同尺寸的屏幕下看到不同的布局方式，在大屏幕下是右对齐在容器的右方，在稍微小一点的屏幕的时候（比如平板），导航居中显示，在更小的屏幕（比如是手机），导航则是每个子项100%的宽度，一个项占一行的方式显示： 3、实现一个简单的页面布局方式 浏览器支持情况： 因为这个属性最早在2009年就被提出了，到现在为止经历了各种不同的版本，所以浏览器对不同版本的flexbox支持情况也不一样：1表示只支持旧的文档而且不支持wrapping2表示只支持2012的语法规范3表示不支持flex-wrap或flex-flow属性4表示由于有很多的bug而只是部分支持 关于Flexbox的一下bug或一些坑 关于flexbox在使用的时候，是否要注意一些东西，或者会遇到一些bug，可以参考下边的这些资料：https://github.com/philipwalton/flexbugs使用Flexbox碰到了什么样的坑？转自:TGideas","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"JS Window对象","slug":"js-window","date":"2016-03-19T16:00:00.000Z","updated":"2016-10-26T11:20:01.367Z","comments":true,"path":"2016/03/20/js-window/","link":"","permalink":"https://blog.luckyw.cn/2016/03/20/js-window/","excerpt":"Window 对象 Window对象表示浏览器中打开的窗口如果文档包含框架（&lt;frame&gt;或&lt;iframe&gt;标签），浏览器会为HTML文档创建一个window对象，并为每个框架创建一个额外的window对象注意:没有应用于window对象的公开标准，不过所有浏览器都支持该对象 Window 对象属性 属性 描述 closed 返回窗口是否已被关闭 defaultStatus 设置或返回窗口状态栏中的默认文本 document 对Document对象的只读引用 frames 返回窗口中所有命名的框架。该集合是Window对象的数组，每个Window对象在窗口中含有一个框 history 对History对象的只读引用 innerHeight 返回窗口的文档显示区的高度 innerWidth 返回窗口的文档显示区的宽度 length 设置或返回窗口中的框架数量 location 用于窗口或框架的Location对象 name 设置或返回窗口的名称 navigator 对Navigator对象的只读引用 opener 返回对创建此窗口的窗口的引用 outerHeight 返回窗口的外部高度，包含工具条与滚动条 outerWidth 返回窗口的外部宽度，包含工具条与滚动条 pageXOffset 设置或返回当前页面相对于窗口显示区左上角的X位置 pageYOffset 设置或返回当前页面相对于窗口显示区左上角的Y位置 parent 返回父窗口 screen 对Screen对象的只读引用 screenLeft 返回相对于屏幕窗口的x坐标 screenTop 返回相对于屏幕窗口的y坐标 screenX 返回相对于屏幕窗口的x坐标 screenY 返回相对于屏幕窗口的y坐标 self 返回对当前窗口的引用 status 设置窗口状态栏的文本 top 返回最顶层的父窗口","text":"Window 对象 Window对象表示浏览器中打开的窗口如果文档包含框架（&lt;frame&gt;或&lt;iframe&gt;标签），浏览器会为HTML文档创建一个window对象，并为每个框架创建一个额外的window对象注意:没有应用于window对象的公开标准，不过所有浏览器都支持该对象 Window 对象属性 属性 描述 closed 返回窗口是否已被关闭 defaultStatus 设置或返回窗口状态栏中的默认文本 document 对Document对象的只读引用 frames 返回窗口中所有命名的框架。该集合是Window对象的数组，每个Window对象在窗口中含有一个框 history 对History对象的只读引用 innerHeight 返回窗口的文档显示区的高度 innerWidth 返回窗口的文档显示区的宽度 length 设置或返回窗口中的框架数量 location 用于窗口或框架的Location对象 name 设置或返回窗口的名称 navigator 对Navigator对象的只读引用 opener 返回对创建此窗口的窗口的引用 outerHeight 返回窗口的外部高度，包含工具条与滚动条 outerWidth 返回窗口的外部宽度，包含工具条与滚动条 pageXOffset 设置或返回当前页面相对于窗口显示区左上角的X位置 pageYOffset 设置或返回当前页面相对于窗口显示区左上角的Y位置 parent 返回父窗口 screen 对Screen对象的只读引用 screenLeft 返回相对于屏幕窗口的x坐标 screenTop 返回相对于屏幕窗口的y坐标 screenX 返回相对于屏幕窗口的x坐标 screenY 返回相对于屏幕窗口的y坐标 self 返回对当前窗口的引用 status 设置窗口状态栏的文本 top 返回最顶层的父窗口 Window 对象方法 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框 blur() 把键盘焦点从顶层窗口移开 clearInterval() 取消由 setInterval() 设置的 timeout clearTimeout() 取消由 setTimeout() 方法设置的 timeout close() 关闭浏览器窗口 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 createPopup() 创建一个 pop-up 窗口 focus() 把键盘焦点给予一个窗口 moveBy() 可相对窗口的当前坐标把它移动指定的像素 moveTo() 把窗口的左上角移动到一个指定的坐标 open() 打开一个新的浏览器窗口或查找一个已命名的窗口 print() 打印当前窗口的内容 prompt() 显示可提示用户输入的对话框 resizeBy() 按照指定的像素调整窗口的大小 resizeTo() 把窗口的大小调整到指定的宽度和高度 scrollBy() 按照指定的像素值来滚动内容 scrollTo() 把内容滚动到指定的坐标 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 setTimeout() 在指定的毫秒数后调用函数或计算表达式","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"JS Navigator对象","slug":"js-navigator","date":"2016-03-14T16:00:00.000Z","updated":"2016-10-26T11:19:37.867Z","comments":true,"path":"2016/03/15/js-navigator/","link":"","permalink":"https://blog.luckyw.cn/2016/03/15/js-navigator/","excerpt":"Navigator 对象 Navigator对象包含有关浏览器的信息注意:没有应用于navigator对象的公开标准，不过所有浏览器都支持该对象 Navigator 对象属性 属性 说明 appCodeName 返回浏览器的代码名 appName 返回浏览器的名称 appVersion 返回浏览器的平台和版本信息 cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值 platform 返回运行浏览器的操作系统平台 userAgent 返回由客户机发送服务器的user-agent 头部的值","text":"Navigator 对象 Navigator对象包含有关浏览器的信息注意:没有应用于navigator对象的公开标准，不过所有浏览器都支持该对象 Navigator 对象属性 属性 说明 appCodeName 返回浏览器的代码名 appName 返回浏览器的名称 appVersion 返回浏览器的平台和版本信息 cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值 platform 返回运行浏览器的操作系统平台 userAgent 返回由客户机发送服务器的user-agent 头部的值 Navigator 对象方法 方法 描述 javaEnabled() 指定是否在浏览器中启用Java taintEnabled() 规定浏览器是否启用数据污点(data tainting)","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"JS数组操作汇总","slug":"js-array-usage","date":"2016-03-11T16:00:00.000Z","updated":"2016-10-26T11:18:54.026Z","comments":true,"path":"2016/03/12/js-array-usage/","link":"","permalink":"https://blog.luckyw.cn/2016/03/12/js-array-usage/","excerpt":"如何定义一个数组 定义数组有三种方法：1、常规方式:1234var names = new Array();names[0] = &quot;CSS&quot;;names[1] = &quot;JS&quot;;names[2] = &quot;PHP&quot;; 2、简洁方式:1var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;); 3、字面量方式:1var names = [&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;]; 如何访问数组元素 通过下标的方式访问，注意：下标以0开始。12var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;);alert(names[0]);//CSS","text":"如何定义一个数组 定义数组有三种方法：1、常规方式:1234var names = new Array();names[0] = &quot;CSS&quot;;names[1] = &quot;JS&quot;;names[2] = &quot;PHP&quot;; 2、简洁方式:1var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;); 3、字面量方式:1var names = [&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;]; 如何访问数组元素 通过下标的方式访问，注意：下标以0开始。12var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;);alert(names[0]);//CSS 如何添加数组元素 push()方法是往数组的尾部插入一个元素，并且返回新的数组长度：123var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;);alert(names.push(&quot;SEO&quot;));//4alert(names[3]);//SEO unshift()方法是往数组的头部插入一个元素，并且返回新的数组长度：123var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;);alert(names.unshift(&quot;SEO&quot;));//4alert(names[0]);//SEO splice()方法是往数组的指定位置插入一个元素，返回””：123var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;);alert(names.splice(1,0,&quot;SEO&quot;));//&quot;&quot;alert(names);//CSS,SEO,JS,PHP 在1的位置（也就是第2个），添加”SEO”，并且删除0个元素。 如何删除数组元素pop()方法是移除最后一个元素，并返回该元素值：123var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;);alert(names.pop());//PHPalert(names);//CSS,JS shift()方法是移除第一个元素，并返回该元素值：123var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;);alert(names.shift());//CSSalert(names);//JS,PHP splice()方法是移除指定位置、指定数量的元素：123var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;);names.splice(1,1)alert(names);//CSS,PHP 从下标为“1”的位置，删除一个元素，所以也就是JS被删除了。 如何截取数组 concat()把多个数组拼接成一个数组：123var firstname = new Array(&quot;CSS&quot;,&quot;JS&quot;);var lastnames = new Array(&quot;PHP&quot;,&quot;SEO&quot;);alert(firstname.concat(lastnames));//CSS,JS,PHP,SEO 如何拷贝数组 concat()与slice()都可以用来拷贝数组：123var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;,&quot;SEO&quot;);alert(names.slice());//CSS,JS,PHP,SEOalert(names.concat());//CSS,JS,PHP,SEO 如何为数组排序 reverse()方法用来反转数组：12var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;,&quot;SEO&quot;);alert(names.reverse());//SEO,PHP,JS,CSS sort()方法以A-Z排列数组：12var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;,&quot;SEO&quot;);alert(names.sort());//CSS,JS,PHP,SEO 如何将数组元素字符串化 join()方法返回数组元素连接在一起的字符串：12var names = new Array(&quot;CSS&quot;,&quot;JS&quot;,&quot;PHP&quot;,&quot;SEO&quot;);alert(names.join(&quot;_&quot;));//CSS_JS_PHP_SEO 上面的例子中，返回了以_隔开的字符串","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"JS数组对象","slug":"js-array","date":"2016-03-05T16:00:00.000Z","updated":"2016-10-26T11:18:45.318Z","comments":true,"path":"2016/03/06/js-array/","link":"","permalink":"https://blog.luckyw.cn/2016/03/06/js-array/","excerpt":"什么是数组? 数组对象是使用单独的变量名来存储一系列的值。如果你有一组数据（例如：车名字），存在单独变量如下所示：123var car1=&quot;Saab&quot;;var car2=&quot;Volvo&quot;;var car3=&quot;BMW&quot;; 然而，如果你想从中找出某一辆车？并且不是3辆，而是300辆呢？这将不是一件容易的事！最好的方法就是用数组。数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值。数组中的每个元素都有自己的的ID，以便它可以很容易地被访问到","text":"什么是数组? 数组对象是使用单独的变量名来存储一系列的值。如果你有一组数据（例如：车名字），存在单独变量如下所示：123var car1=&quot;Saab&quot;;var car2=&quot;Volvo&quot;;var car3=&quot;BMW&quot;; 然而，如果你想从中找出某一辆车？并且不是3辆，而是300辆呢？这将不是一件容易的事！最好的方法就是用数组。数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值。数组中的每个元素都有自己的的ID，以便它可以很容易地被访问到 Array 对象属性 方法 描述 concat() 连接两个或更多的数组，并返回结果 every() 检测数值元素的每个元素是否都符合条件 filter() 检测数值元素，并返回符合条件所有元素的数组 indexOf() 搜索数组中的元素，并返回它所在的位置 join() 把数组的所有元素放入一个字符串 lastIndexOf() 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索 map() 通过指定函数处理数组的每个元素，并返回处理后的数组 pop() 删除数组的最后一个元素并返回删除的元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reverse() 反转数组的元素顺序 shift() 删除并返回数组的第一个元素 slice() 选取数组的的一部分，并返回一个新数组 some() 检测数组元素中是否有元素符合指定条件 sort() 对数组的元素进行排序 splice() 从数组中添加或删除元素 toString() 把数组转换为字符串，并返回结果 unshift() 向数组的开头添加一个或更多元素，并返回新的长度 valueOf() 返回数组对象的原始值","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"总结下IE6的BUG及解决办法","slug":"ie6-bug","date":"2016-03-02T16:00:00.000Z","updated":"2016-10-26T11:17:57.637Z","comments":true,"path":"2016/03/03/ie6-bug/","link":"","permalink":"https://blog.luckyw.cn/2016/03/03/ie6-bug/","excerpt":"双倍边距问题 在IE6中，如果有两个并行的漂浮元素并且用了margin的话，会出现双倍margin值的问题 给漂浮元素设置样式display:inline 为IE6hack一下：margin-left:10px;_margin-left:5px; 在DOM结构允许的情况下，左边的用float:left，右边的用float:right; 固定定位fix position:fixed这个样式有时候作用很大，尤其是在有浮动栏的时候，但是IE6中并不支持固定定位 默认高度问题 在IE6中，如果我们设置一个空白的div，会发现这个div会有一个默认的高度，因为IE6中有一个默认的字体大小，大致在12-14px之间，IE6会认为这个层的高度不应该小于字体的行高，所以会出现这个问题。解决方法：font-size:0; 图片下方出现空白间隙 设置图片为块级元素：img{display:block;} 把父元素的字体大小设置为0：font-size:0 设置图片的垂直对齐方式：vertical-align:top","text":"双倍边距问题 在IE6中，如果有两个并行的漂浮元素并且用了margin的话，会出现双倍margin值的问题 给漂浮元素设置样式display:inline 为IE6hack一下：margin-left:10px;_margin-left:5px; 在DOM结构允许的情况下，左边的用float:left，右边的用float:right; 固定定位fix position:fixed这个样式有时候作用很大，尤其是在有浮动栏的时候，但是IE6中并不支持固定定位 默认高度问题 在IE6中，如果我们设置一个空白的div，会发现这个div会有一个默认的高度，因为IE6中有一个默认的字体大小，大致在12-14px之间，IE6会认为这个层的高度不应该小于字体的行高，所以会出现这个问题。解决方法：font-size:0; 图片下方出现空白间隙 设置图片为块级元素：img{display:block;} 把父元素的字体大小设置为0：font-size:0 设置图片的垂直对齐方式：vertical-align:top IE6中3像素问题 如果两个容器挨着，一个浮动，一个不浮动，在IE6中这两个容器之间就会有3像素的间隙，解决办法：给漂浮的容器添加样式_margin-right:-3px; 不支持背景透明的PNG 在IE6中背景透明的PNG是不能生效的，所以最好用矩形或者背景颜色 背景透明的PNG图片质量其实还是不错的，但是有时候我们为了方便，会为IE6用图片质量低一些的GIF图片： 1234.box&#123; background:url(&quot;bg.png&quot;); _background:url(&quot;bg.gif&quot;);&#125; 用滤镜来解决比上面的方法要好： 1234567.box&#123; width:12px; height:12px; background:url(&quot;bg.png&quot;); _background:transparent none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;bg.png&quot;)&#125; JS插件。如果仅仅是几个页面需要PNG背景透明的话，那么还是选择第2种方法为好，但是如果需要大范围使用的话，使用插件是不错的选择，插件的名称叫做DD_belated:DD_belatedPNG.fix(&#39;#box img&#39;);","categories":[{"name":"ie","slug":"ie","permalink":"https://blog.luckyw.cn/categories/ie/"}],"tags":[{"name":"ie","slug":"ie","permalink":"https://blog.luckyw.cn/tags/ie/"}],"keywords":[{"name":"ie","slug":"ie","permalink":"https://blog.luckyw.cn/categories/ie/"}]},{"title":"JS Document对象属性及方法","slug":"js-document","date":"2016-02-24T16:00:00.000Z","updated":"2016-10-26T11:19:12.418Z","comments":true,"path":"2016/02/25/js-document/","link":"","permalink":"https://blog.luckyw.cn/2016/02/25/js-document/","excerpt":"Document 对象 每个载入浏览器的HTML文档都会成为Document对象Document对象使我们可以从脚本中对HTML页面中的所有元素进行访问Document对象是Window对象的一部分，可通过window.document属性对其进行访问，也可以直接通过document对象访问 Document 对象集合 属性 描述 all[] 提供对文档中所有 HTML 元素的访问 anchors[] 返回对文档中所有 Anchor 对象的引用 applets 返回对文档中所有 Applet 对象的引用 forms[] 返回对文档中所有 Form 对象引用 images[] 返回对文档中所有 Image 对象引用 links[] 返回对文档中所有 Area 和 Link 对象引用","text":"Document 对象 每个载入浏览器的HTML文档都会成为Document对象Document对象使我们可以从脚本中对HTML页面中的所有元素进行访问Document对象是Window对象的一部分，可通过window.document属性对其进行访问，也可以直接通过document对象访问 Document 对象集合 属性 描述 all[] 提供对文档中所有 HTML 元素的访问 anchors[] 返回对文档中所有 Anchor 对象的引用 applets 返回对文档中所有 Applet 对象的引用 forms[] 返回对文档中所有 Form 对象引用 images[] 返回对文档中所有 Image 对象引用 links[] 返回对文档中所有 Area 和 Link 对象引用 Document 对象属性 属性 描述 body 提供对 元素的直接访问对于定义了框架集的文档，该属性引用最外层的 cookie 设置或返回与当前文档有关的所有cookie domain 返回当前文档的域名 lastModified 返回文档被最后修改的日期和时间 referrer 返回载入当前文档的文档的 URL title 返回当前文档的标题 URL 返回当前文档的 URL Document 对象方法 方法 描述 close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByName() 返回带有指定名称的对象集合 getElementsByTagName() 返回带有指定标签名的对象集合 open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出 write() 向文档写 HTML 表达式 或 JavaScript 代码 writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"JS Math对象属性及方法","slug":"js-math","date":"2016-02-19T16:00:00.000Z","updated":"2016-10-26T11:19:29.103Z","comments":true,"path":"2016/02/20/js-math/","link":"","permalink":"https://blog.luckyw.cn/2016/02/20/js-math/","excerpt":"Math对象 Math对象并不像Date和String那样是对象的类，因此没有构造函数Math()，像Math.sin()这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把Math作为对象使用就可以调用其所有属性和方法 属性 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718） LN2 返回 2 的自然对数（约等于0.693） LN10 返回 10 的自然对数（约等于2.302） LOG2E 返回以 2 为底的 e 的对数（约等于 1.414） LOG10E 返回以 10 为底的 e 的对数（约等于0.434） PI 返回圆周率（约等于3.14159） SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707） SQRT2 返回 2 的平方根（约等于 1.414）","text":"Math对象 Math对象并不像Date和String那样是对象的类，因此没有构造函数Math()，像Math.sin()这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把Math作为对象使用就可以调用其所有属性和方法 属性 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718） LN2 返回 2 的自然对数（约等于0.693） LN10 返回 10 的自然对数（约等于2.302） LOG2E 返回以 2 为底的 e 的对数（约等于 1.414） LOG10E 返回以 10 为底的 e 的对数（约等于0.434） PI 返回圆周率（约等于3.14159） SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707） SQRT2 返回 2 的平方根（约等于 1.414） 对象方法 方法 描述 abs(x) 返回x的绝对值 acos(x) 返回x的反余弦值 asin(x) 返回x的反正弦值 atan(x) 以介于-PI/2与PI/2弧度之间的数值来返回x的反正切值 atan2(y,x) 返回从x轴到点(x,y)的角度（介于-PI/2与PI/2弧度之间） ceil(x) 对x进行上取整 cos(x) 返回x的余弦 exp(x) 返回e的指数 floor(x) 对x进行下取整 log(x) 返回x的自然对数（底为e） max(x,y) 返回x和y中的最高值 min(x,y) 返回x和y中的最低值 pow(x,y) 返回x的y次幂 random() 返回0~1之间的随机数 round(x) 把x四舍五入为最接近的整数 sin(x) 返回x的正弦 sqrt(x) 返回x的平方根 tan(x) 返回x的正切 toSource() 返回该对象的源代码 valueOf() 返回Math对象的原始值","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"HTML5 Canvas属性和方法汇总","slug":"html5-canvas","date":"2016-02-14T16:00:00.000Z","updated":"2016-11-20T10:56:48.260Z","comments":true,"path":"2016/02/15/html5-canvas/","link":"","permalink":"https://blog.luckyw.cn/2016/02/15/html5-canvas/","excerpt":"基础知识 Canvas画布是html5新增标签元素，主要用于通过脚本(通常是javascript)来绘制图像，而canvas元素本身并没有绘制能力(它仅仅是图形的容器)，必须使用脚本来完成实际的绘图任务getContext()方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性详细Canvas API请参考: //demo.luckyw.cn/src/canvas-api/demo: 效果 链接地址 时钟一 //demo.luckyw.cn/src/canvas-clock/ 时钟二 //demo.luckyw.cn/src/canvas-clock2/ 时钟三 //demo.luckyw.cn/src/clock/ 酷炫粒子时钟 //demo.luckyw.cn/src/cool-clock/ 七彩酷炫粒子 //demo.luckyw.cn/src/dots-animate/ 图片模糊 //demo.luckyw.cn/src/blur-img/ 心形动画 //demo.luckyw.cn/src/canvas-heart/ 刮刮卡 //demo.luckyw.cn/src/clip-card/ 图片橡皮擦 //demo.luckyw.cn/src/clip-img/ 彩色球沿轨迹运动 //demo.luckyw.cn/src/color-ball-canvas/ 图像处理 //demo.luckyw.cn/src/image-process/ 手写字 //demo.luckyw.cn/src/learn-to-write-a-word/ 浏览器支持 IE9、Firefox、Opera、Chrome以及Safari均支持canvas及其属性和方法。注释：IE8以及更早的版本不支持canvas元素 颜色、样式和阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 方法 描述 createLinearGradient() 创建线性渐变（用在画布内容上） createPattern() 在指定的方向上重复指定的元素 createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置","text":"基础知识 Canvas画布是html5新增标签元素，主要用于通过脚本(通常是javascript)来绘制图像，而canvas元素本身并没有绘制能力(它仅仅是图形的容器)，必须使用脚本来完成实际的绘图任务getContext()方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性详细Canvas API请参考: //demo.luckyw.cn/src/canvas-api/demo: 效果 链接地址 时钟一 //demo.luckyw.cn/src/canvas-clock/ 时钟二 //demo.luckyw.cn/src/canvas-clock2/ 时钟三 //demo.luckyw.cn/src/clock/ 酷炫粒子时钟 //demo.luckyw.cn/src/cool-clock/ 七彩酷炫粒子 //demo.luckyw.cn/src/dots-animate/ 图片模糊 //demo.luckyw.cn/src/blur-img/ 心形动画 //demo.luckyw.cn/src/canvas-heart/ 刮刮卡 //demo.luckyw.cn/src/clip-card/ 图片橡皮擦 //demo.luckyw.cn/src/clip-img/ 彩色球沿轨迹运动 //demo.luckyw.cn/src/color-ball-canvas/ 图像处理 //demo.luckyw.cn/src/image-process/ 手写字 //demo.luckyw.cn/src/learn-to-write-a-word/ 浏览器支持 IE9、Firefox、Opera、Chrome以及Safari均支持canvas及其属性和方法。注释：IE8以及更早的版本不支持canvas元素 颜色、样式和阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 方法 描述 createLinearGradient() 创建线性渐变（用在画布内容上） createPattern() 在指定的方向上重复指定的元素 createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置 线条样式 属性 描述 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 矩形 方法 描述 rect() 创建矩形 fillRect() 绘制“被填充”的矩形 strokeRect() 绘制矩形（无填充） clearRect() 在给定的矩形内清除指定的像素 路径 方法 描述 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 moveTo() 把路径移动到画布中的指定点，不创建线条 closePath() 创建从当前点回到起始点的路径 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 转换 方法 描述 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 文本 属性 描述 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 方法 描述 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 图像绘制 方法 描述 drawImage() 向画布上绘制图像、画布或视频 像素操作 属性 描述 width 返回 ImageData 对象的宽度 height 返回 ImageData 对象的高度 data 返回一个对象，其包含指定的 ImageData 对象的图像数据 方法 描述 createImageData() 创建新的、空白的 ImageData 对象 getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 合成 属性 描述 globalAlpha 设置或返回绘图的当前 alpha 或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 其他 方法 描述 save() 保存当前环境的状态 restore() 返回之前保存过的路径状态和属性 createEvent() getContext() toDataURL()","categories":[{"name":"Html5","slug":"Html5","permalink":"https://blog.luckyw.cn/categories/Html5/"}],"tags":[{"name":"Html5","slug":"Html5","permalink":"https://blog.luckyw.cn/tags/Html5/"}],"keywords":[{"name":"Html5","slug":"Html5","permalink":"https://blog.luckyw.cn/categories/Html5/"}]},{"title":"getComputedStyle与currentStyle获取样式","slug":"get-style","date":"2016-02-09T16:00:00.000Z","updated":"2016-11-20T10:48:52.631Z","comments":true,"path":"2016/02/10/get-style/","link":"","permalink":"https://blog.luckyw.cn/2016/02/10/get-style/","excerpt":"CSS的样式分为三类： 内嵌样式：是写在标签里面的，内嵌样式只对所在的标签有效内部样式：是写在HTML里面的，内部样式只对所在的网页有效外部样式表：如果很多网页需要用到同样的样式，将样式写在一个以.css为后缀的CSS文件里，然后在每个需要用到这些样式的网页里引用这个CSS文件 getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值，返回的是一个CSS样式声明对象，只读currentStyle是IE浏览器的一个属性 基础知识 众所周知，用document.getElementById(&#39;element&#39;).style.xxx可以获取element的xxx样式信息，可是它获取的只能是DOM元素内嵌样式style属性里的样式规则，对于使用外部样式表或内部样式设置的元素，就获取不到样式信息了DOM标准里有个全局方法getComputedStyle，可以获取到当前对象样式信息，如：getComputedStyle(obj,null).paddingLeft，就能获取到对象的左内边距。但是IE不支持此方法，IE中获取样式的方法是currentStyle，不同于全局方法getComputedStyle，它是作为DOM元素属性存在的，如：obj.currentStyle.paddingLeft，在IE中就获取到对象的左内边距了，兼容性的写法如下：","text":"CSS的样式分为三类： 内嵌样式：是写在标签里面的，内嵌样式只对所在的标签有效内部样式：是写在HTML里面的，内部样式只对所在的网页有效外部样式表：如果很多网页需要用到同样的样式，将样式写在一个以.css为后缀的CSS文件里，然后在每个需要用到这些样式的网页里引用这个CSS文件 getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值，返回的是一个CSS样式声明对象，只读currentStyle是IE浏览器的一个属性 基础知识 众所周知，用document.getElementById(&#39;element&#39;).style.xxx可以获取element的xxx样式信息，可是它获取的只能是DOM元素内嵌样式style属性里的样式规则，对于使用外部样式表或内部样式设置的元素，就获取不到样式信息了DOM标准里有个全局方法getComputedStyle，可以获取到当前对象样式信息，如：getComputedStyle(obj,null).paddingLeft，就能获取到对象的左内边距。但是IE不支持此方法，IE中获取样式的方法是currentStyle，不同于全局方法getComputedStyle，它是作为DOM元素属性存在的，如：obj.currentStyle.paddingLeft，在IE中就获取到对象的左内边距了，兼容性的写法如下：1return obj.currentStyle?obj.currentStyle.paddingLeft:getComputedStyle(obj,null).paddingLeft; getComputedStyle第二个参数表示的是:after、:before之类的伪类，如果不用伪类的话设置为null即可。注意的是:Gecko 2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1)之前，第二个参数“伪类”是必需的（如果不是伪类，设置为null），不过现在嘛，不是必需参数了这样，就能在IE及FF中返回对象的当前样式信息了特别注意一点：如果要获取当前对象的颜色信息，IE返回的是16进制值，如:#ffffff，而其他浏览器返回的是rgb值，如:rgb(255,255,255)下面是一个简单的小示例:123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;getComputedStyle与currentStyle获取样式&lt;/title&gt; &lt;style&gt; #box&#123; width: 300px; height: 300px; border: 1px solid darkcyan; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; function getStyle(obj,attr) &#123; if(obj.currentStyle)&#123; return obj.currentStyle[attr]; &#125;else&#123; return getComputedStyle(obj,false)[attr]; &#125; &#125; window.onload = function()&#123; var box = document.getElementById(&apos;box&apos;); alert(getStyle(box,&apos;height&apos;)); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 兼容性 getComputedStyle:FireFox、Opera、Safari、Chrome均支持currentStyle:仅IE支持","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"关于Google的10个搜索技巧(译)","slug":"google-10search-tips","date":"2016-02-04T16:00:00.000Z","updated":"2016-11-20T10:55:23.609Z","comments":true,"path":"2016/02/05/google-10search-tips/","link":"","permalink":"https://blog.luckyw.cn/2016/02/05/google-10search-tips/","excerpt":"准确搜索 最简单、有效的准确搜索方式是在关键词上加上双引号，在这种情况下，搜索引擎只会反馈和关键词完全吻合的搜索结果。比方说在搜索Joe Bloggs的时候，在没有给关键词加上双引号的情况，搜索引擎会显示所有分别和Joe以及Bloggs相关的信息，但这些显然并不是我们想要的结果。但在加上双引号后，搜索引擎则仅会在页面上反馈和Joe Bloggs相吻合的信息准确搜索在排除常见但相近度偏低的信息时非常有用，可以为用户省去再度对结果进行筛选的麻烦 排除关键词 如果在进行准确搜索时没有找到自己想要的结果，用户可以对包含特定词汇的信息进行排除，仅需使用减号即可例如在搜索Joe Bloggs-jeans时，你所得到的结果反馈是不包含jeans字眼的Joe Bloggs条目 用「Either OR」（或）逻辑进行搜索 在默认搜索下，搜索引擎会反馈所有和查询词汇相关的结果，但通过使用OR逻辑，你可以得到和两个关键词分别相关的结果，而不仅仅是和两个关键词都同时相关的结果。巧妙使用OR搜索可以让你在未能确定哪个关键词对于搜索结果起决定作用时依然可以确保搜索结果的准确性","text":"准确搜索 最简单、有效的准确搜索方式是在关键词上加上双引号，在这种情况下，搜索引擎只会反馈和关键词完全吻合的搜索结果。比方说在搜索Joe Bloggs的时候，在没有给关键词加上双引号的情况，搜索引擎会显示所有分别和Joe以及Bloggs相关的信息，但这些显然并不是我们想要的结果。但在加上双引号后，搜索引擎则仅会在页面上反馈和Joe Bloggs相吻合的信息准确搜索在排除常见但相近度偏低的信息时非常有用，可以为用户省去再度对结果进行筛选的麻烦 排除关键词 如果在进行准确搜索时没有找到自己想要的结果，用户可以对包含特定词汇的信息进行排除，仅需使用减号即可例如在搜索Joe Bloggs-jeans时，你所得到的结果反馈是不包含jeans字眼的Joe Bloggs条目 用「Either OR」（或）逻辑进行搜索 在默认搜索下，搜索引擎会反馈所有和查询词汇相关的结果，但通过使用OR逻辑，你可以得到和两个关键词分别相关的结果，而不仅仅是和两个关键词都同时相关的结果。巧妙使用OR搜索可以让你在未能确定哪个关键词对于搜索结果起决定作用时依然可以确保搜索结果的准确性 同义词搜索 有时候对不太确切的关键词进行搜索反而会显得更加合适。在未能准确判断关键词的情况下，你可以通过同义词进行搜索如果你在搜索引擎输入plumbing ~university，你所得到的反馈结果会包含plumbing universities和plumbing colleges等相似条目 在站内进行搜索 绝大部分网站的搜索功能都有所欠缺，因此，更好的方法是通过Google等搜索引擎对站内的信息进行搜索你只需要在搜索引擎上输入site:theguardian.com加上关键词，搜索引擎就会反馈网站theguardian.com内和关键词相关的所有条目。如果再结合准确搜索功能，这项功能将会变得更加强大 善用星号 正如拼图游戏Scrabble的空白方块一样，在搜索引擎中，我们可以用星号填补关键词中的缺失部分，不论缺失的是一连串单词的其中一个还是一个单词的某一部分。此外，当你希望搜索一篇确定性偏低的文章时，也可以使用星号填补缺失部分例如，如果你在搜索引擎中输入architect*，你所得到的反馈结果将会是所有包含 architect、architectural、architecture、architected、architecting 以及其他所有以architect作为开头的词汇的条目 在两个数值之间进行搜索 在寻找问题的答案时，一个很好的方法是在一定范围内寻找和关键词相关的资讯。例如想要找出1920至1950年间的英国首相，直接在搜索引擎中输入英国首相 1920.. 1950即可得出想要的结果记住，数值之间的符号是两个英文句号加一个空格键 在网页标题、链接和主体中搜索关键词 有时你或许会遇上找出所有和关键词相关的所有网页标题、链接和网页主体的需求，在这个时候你需要使用的是限定词inurl:（供在url链接中搜索使用）、intext:（供在网页主体中搜索使用）以及intitle:（供在网页标题中搜索使用）例如，在搜索引擎中输入intitle: 评测会得到所有和关键词评测相关的网页标题 搜索相关网站 相关的限定词可用于搜索相关网站时使用。例如，你仅需在搜索引擎中输入related:theguardian.com即可得到所有和theguardian.com相关的网站反馈结果 搜索技能的组合使用 你可以对上述所有搜索技能进行组合运用，以便按照自己的意愿缩小或者扩展搜索范围。尽管有些技能或许并不常用，但准确搜索和站内搜索这些技能的使用范围还是相当广泛的随着Google等搜索引擎对于用户自然语言的理解程度与日俱增，这些搜索技能可以派上用场的情况或许将会变得越来越少，至少这是所有搜索引擎共同追求的目标。但是在当下，掌握这些搜索技能还是非常必要的 原文 http://www.theguardian.com/technology/2016/jan/15/how-to-use-search-like-a-pro-10-tips-and-tricks-for-google-and-beyond","categories":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/categories/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/tags/Chrome/"}],"keywords":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/categories/Chrome/"}]},{"title":"JQuery中$.ajax()方法参数详解","slug":"jquery-ajax-method","date":"2016-01-29T16:00:00.000Z","updated":"2016-10-26T11:18:09.989Z","comments":true,"path":"2016/01/30/jquery-ajax-method/","link":"","permalink":"https://blog.luckyw.cn/2016/01/30/jquery-ajax-method/","excerpt":"url: String，发送请求的地址，默认为当前页地址type: String，请求方式，默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持timeout: Number，设置请求超时时间(毫秒)async:Boolean，默认值为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行cache:Boolean，默认为true（当dataType为script时，默认为false）。设置为false将不会从浏览器缓存中加载请求信息data:Object或String，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。对象必须为key/value格式，例如{foo1:&quot;bar1&quot;,foo2:&quot;bar2&quot;}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[&quot;bar1&quot;,&quot;bar2&quot;]}转换为&amp;foo=bar1&amp;foo=bar2dataType: String，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递可用的类型如下： xml:返回XML文档，可用JQuery处理。 html:返回纯文本HTML信息，包含的script标签会在插入DOM时执行。 script:返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求 json:返回JSON数据。 jsonp:JSONP格式。使用JSONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个?为正确的函数名，以执行回调函数 text:返回纯文本字符串","text":"url: String，发送请求的地址，默认为当前页地址type: String，请求方式，默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持timeout: Number，设置请求超时时间(毫秒)async:Boolean，默认值为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行cache:Boolean，默认为true（当dataType为script时，默认为false）。设置为false将不会从浏览器缓存中加载请求信息data:Object或String，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。对象必须为key/value格式，例如{foo1:&quot;bar1&quot;,foo2:&quot;bar2&quot;}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[&quot;bar1&quot;,&quot;bar2&quot;]}转换为&amp;foo=bar1&amp;foo=bar2dataType: String，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递可用的类型如下： xml:返回XML文档，可用JQuery处理。 html:返回纯文本HTML信息，包含的script标签会在插入DOM时执行。 script:返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求 json:返回JSON数据。 jsonp:JSONP格式。使用JSONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个?为正确的函数名，以执行回调函数 text:返回纯文本字符串 beforeSend:Function，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数123function(XMLHttpRequest)&#123; this; //调用本次ajax请求时传递的options参数&#125; complete:Function，请求完成后调用的回调函数（请求成功或失败时均调用）参数：XMLHttpRequest对象和一个描述成功请求类型的字符串123function(XMLHttpRequest, textStatus)&#123; this; //调用本次ajax请求时传递的options参数&#125; success:Function，请求成功后调用的回调函数，有两个参数:(1)由服务器返回，并根据dataType参数进行处理后的数据(2)描述状态的字符串1234function(data, textStatus)&#123; //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数&#125; error:Function，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)ajax事件函数如下：1234function(XMLHttpRequest, textStatus, errorThrown)&#123; //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数&#125; contentType:String，当发送信息至服务器时，内容编码类型默认为application/x-www-form-urlencoded。该默认值适合大多数应用场合dataFilter:Function，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理1234function(data, type)&#123; //返回处理后的数据 return data;&#125; global:Boolean，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件ifModified:Boolean，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息jsonp:String，在一个jsonp请求中重写回调函数的名字。该值用来替代在callback=?这种GET或POST请求中URL参数里的callback部分，例如{jsonp:&#39;onJsonPLoad&#39;}会导致将onJsonPLoad=?传给服务器username:String，用于响应HTTP访问认证请求的用户名password:String，用于响应HTTP访问认证请求的密码processData:Boolean，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型application/x-www-form-urlencoded。如果要发送DOM信息或者其他不希望转换的信息，请设置为falsescriptCharset:String类型的参数，只有当请求时dataType为jsonp或者script，并且type是GET时才会用于强制修改字符集。通常在本地和远程的内容编码不同时使用案例代码：123456789101112131415161718$(function()&#123; $(&apos;#send&apos;).click(function()&#123; $.ajax(&#123; type: &quot;GET&quot;, url: &quot;test.json&quot;, data: &#123;username:$(&quot;#username&quot;).val(), content:$(&quot;#content&quot;).val()&#125;, dataType: &quot;json&quot;, success: function(data)&#123; $(&apos;#resText&apos;).empty(); //清空resText里面的所有内容 var html = &apos;&apos;; $.each(data, function(commentIndex, comment)&#123; html += &apos;&lt;div class=&quot;comment&quot;&gt;&lt;h6&gt;&apos; + comment[&apos;username&apos;] + &apos;:&lt;/h6&gt;&lt;p class=&quot;para&quot;&apos; + comment[&apos;content&apos;] + &apos;&lt;/p&gt;&lt;/div&gt;&apos;; &#125;); $(&apos;#resText&apos;).html(html); &#125; &#125;); &#125;);&#125;); 顺便说一下$.each()函数:$.each()函数不同于JQuery对象的each()方法，它是一个全局函数，不操作JQuery对象，而是以一个数组或者对象作为第1个参数，以一个回调函数作为第2个参数。回调函数拥有两个参数:第1个为对象的成员或数组的索引，第2个为对应变量或内容","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://blog.luckyw.cn/categories/JQuery/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://blog.luckyw.cn/tags/JQuery/"}],"keywords":[{"name":"JQuery","slug":"JQuery","permalink":"https://blog.luckyw.cn/categories/JQuery/"}]},{"title":"建站：Node+MongoDb+Express简单实例","slug":"node-mongodb-express","date":"2016-01-23T16:00:00.000Z","updated":"2016-11-20T11:04:34.578Z","comments":true,"path":"2016/01/24/node-mongodb-express/","link":"","permalink":"https://blog.luckyw.cn/2016/01/24/node-mongodb-express/","excerpt":"安装Node以及Express 前往官网https://nodejs.org 下载安装NodeJs,跟常规的软件安装类似，安装成功测试代码:1$ node -v 成功如下图所示：当前显示我的NodeJs版本是5.10.0，安装Node的同时，系统会自带NPM工具，我们可以利用NPM下载我们所需的强大的node开源框架——Express，安装命令如下:1npm install -g express 其中-g是表示全局安装，如果不写是本地安装安装完最新版的express之后，需要再安装:express-generator1npm install -g express-generator 同上安装成功后我们可以通过如下命令查看是否安装成功1express -V 成功如图所示：Tips:注意是大写的V","text":"安装Node以及Express 前往官网https://nodejs.org 下载安装NodeJs,跟常规的软件安装类似，安装成功测试代码:1$ node -v 成功如下图所示：当前显示我的NodeJs版本是5.10.0，安装Node的同时，系统会自带NPM工具，我们可以利用NPM下载我们所需的强大的node开源框架——Express，安装命令如下:1npm install -g express 其中-g是表示全局安装，如果不写是本地安装安装完最新版的express之后，需要再安装:express-generator1npm install -g express-generator 同上安装成功后我们可以通过如下命令查看是否安装成功1express -V 成功如图所示：Tips:注意是大写的V 创建项目 我们通过命令行工具在E盘下用express创建一个项目，名字叫demo，用的模板引擎是ejs。代码如下:1express -e demo Tips: -e表示使用的是ejs模板，如果不写表示使用默认的jade模板如图所示：然后再在命令行中输入：12cd demo //进入到刚才创建的demo项目中npm install //读取根目录中的package.json文件然后安装项目所依赖的包 项目文件夹如下图： node_modules 项目中依赖的包public 公共资源目录routes 路由配置views 视图文件夹app.js 项目的入口文件 然后通过命令行启动运行项目1node app 温馨提示: 在module.exports = app语句之前添加app.listen(3000) Ctrl + C终止运行 接下来我们可以在浏览器地址栏里敲入http://127.0.0.1:3000/ 或者 http://localhost:3000 创建数据库 mongodb的安装 2016-5-5更新Ubuntu下安装请参考官方文档 在官网https://www.mongodb.com/ 上下载对应系统的安装包，因为我系统是win10的，所以选择下载window系统对应的msi文件，如图，下载完成后可按常规软件方法进行安装，不过我把安装目录改在C盘根目录下，新建一个mongodb文件夹，安装在此文件夹下，方便在命令行中调用命令然后在此文件夹中创建data文件夹，在data文件夹中创建db文件夹，接着我们以管理员身份运行命令行工具，输入以下命令安装mongod服务：1mongod --dbpath &quot;C:\\mongodb\\data\\db&quot; --logpath &quot;C:\\mongodb\\data\\mongo.log&quot; --install --serviceName &quot;MongoDB&quot; 删除此服务，以管理员身份运行以下代码：1mongod --remove --serviceName &quot;MongoDB&quot; 接着我们在命令行窗口输入services.msc命令启动mongodb服务在CMD中输入mongo，这样就可以使用了，如下图:接着设计我们所需要的数据库，在刚打开的mongodb数据库中输入：1234use demo //创建demo数据库db.createCollection(“users”) //创建数据表usersdb.users.insert(&#123;“name”:“admin”,“password”:“123456”&#125;) //给数据表users添加一条数据db.users.find() //查询数据表users中所有的数据 下图是运行上面代码的效果图：在项目根目录下创建model文件夹，在里面创建model.js文件，js代码如下：12345678var mongoose = require(&apos;mongoose&apos;);var db = mongoose.connect(&apos;mongodb://localhost/demo&apos;);//连接数据库var Schema = mongoose.Schema; //创建模型var userScheMa = new Schema(&#123; name: String, password: String&#125;); //定义了一个新的模型，但是此模式还未和users表有关联exports.user = db.model(&apos;users&apos;, userScheMa); //与users表关联 在views文件夹下创建视图文件 我们上面用express创建的项目视图文件的后缀名是ejs，我们一般习惯使用html后缀名。所以我们通过以下代码进行实现，在app.js入口文件中进行修改原代码：app.set(&#39;view engine&#39;, &#39;ejs&#39;);替换成:app.set(&#39;view engine&#39;, &#39;html&#39;);然后再通过app.engine()方法注册模板引擎的后缀名app.engine(&#39;.html&#39;,require(&#39;ejs&#39;).__express);创建登录页面login.html代码：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;登录页&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;p&gt;Welcome to&lt;/p&gt; &lt;form action=&quot;userCenter&quot; method=&quot;post&quot;&gt; &lt;p&gt; &lt;span&gt;name:&lt;/span&gt; &lt;br&gt; &lt;input id=&quot;name&quot; name=&quot;name&quot; type=&quot;text&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;password:&lt;/span&gt; &lt;br&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; index.html代码：123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;p&gt;Welcome to&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;login&quot;&gt;登陆&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; userCenter.html代码：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;用户中心&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;p&gt;你已经成功登陆&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 路由配置 routes目录下的index.js代码：12345678910111213141516171819202122232425262728293031var express = require(&apos;express&apos;);var router = express.Router();var user = require(&quot;../model/model&quot;).user;/* GET home page. */router.get(&apos;/&apos;, function(req, res, next) &#123; res.render(&apos;index&apos;, &#123; title: &apos;首页&apos; &#125;);&#125;);router.get(&quot;/login&quot;,function(req,res)&#123; res.render(&quot;login&quot;,&#123;title:&quot;登陆&quot;&#125;)&#125;)router.post(&quot;/userCenter&quot;,function(req,res)&#123; var query = &#123; name:req.body.name, password:req.body.password &#125;; (function()&#123; user.count(query,function(err,doc)&#123; if(doc==1)&#123; console.log(query.name +&quot;：登陆成功&quot; + new Date()); res.render(&quot;userCenter&quot;,&#123;title:&quot;用户中心&quot;&#125;) &#125;else&#123; console.log(query.name+&quot;:登陆失败&quot;+new Date()); res.redirect(&quot;/&quot;); &#125; &#125;) &#125;)(query);&#125;)module.exports = router;","categories":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/categories/Node/"},{"name":"MongoDb","slug":"Node/MongoDb","permalink":"https://blog.luckyw.cn/categories/Node/MongoDb/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/tags/Node/"},{"name":"MongoDb","slug":"MongoDb","permalink":"https://blog.luckyw.cn/tags/MongoDb/"}],"keywords":[{"name":"Node","slug":"Node","permalink":"https://blog.luckyw.cn/categories/Node/"},{"name":"MongoDb","slug":"Node/MongoDb","permalink":"https://blog.luckyw.cn/categories/Node/MongoDb/"}]},{"title":"jQuery小技巧(译文)","slug":"jquery-tips","date":"2016-01-14T16:00:00.000Z","updated":"2016-10-26T11:18:17.766Z","comments":true,"path":"2016/01/15/jquery-tips/","link":"","permalink":"https://blog.luckyw.cn/2016/01/15/jquery-tips/","excerpt":"回到顶部按钮 利用jQuery里的animate和scrollTop方法，你便不需要使用插件创建简单的滚动到顶部动画1234$(&apos;.top&apos;).click(function (e) &#123; e.preventDefault(); $(&apos;html, body&apos;).animate(&#123;scrollTop: 0&#125;, 800);&#125;); 通过scrollTop的值来改变你想要滚动到的位置其实你就是做了:在接下来的800毫秒中让页面滚动，直到它滚动到文档的顶部 图片预加载 如果你的网页使用了很多隐藏图片文件（例如：鼠标悬停展示的图片），那么图片的预加载是有意义的:123456$.preloadImages = function () &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; $(&apos;&lt;img&gt;&apos;).attr(&apos;src&apos;, arguments[i]); &#125;&#125;;$.preloadImages(&apos;img/hover-on.png&apos;, &apos;img/hover-off.png&apos;); 判断图片是否加载完 有时候你可能需要检查图像是否已经加载完成，以便于可以继续执行相应的js代码:123$(&apos;img&apos;).load(function () &#123; console.log(&apos;image load successful&apos;);&#125;); 你还可以检查一个特定的图片是否加载完并且被带有id或者class的&lt;img&gt;标签代替。","text":"回到顶部按钮 利用jQuery里的animate和scrollTop方法，你便不需要使用插件创建简单的滚动到顶部动画1234$(&apos;.top&apos;).click(function (e) &#123; e.preventDefault(); $(&apos;html, body&apos;).animate(&#123;scrollTop: 0&#125;, 800);&#125;); 通过scrollTop的值来改变你想要滚动到的位置其实你就是做了:在接下来的800毫秒中让页面滚动，直到它滚动到文档的顶部 图片预加载 如果你的网页使用了很多隐藏图片文件（例如：鼠标悬停展示的图片），那么图片的预加载是有意义的:123456$.preloadImages = function () &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; $(&apos;&lt;img&gt;&apos;).attr(&apos;src&apos;, arguments[i]); &#125;&#125;;$.preloadImages(&apos;img/hover-on.png&apos;, &apos;img/hover-off.png&apos;); 判断图片是否加载完 有时候你可能需要检查图像是否已经加载完成，以便于可以继续执行相应的js代码:123$(&apos;img&apos;).load(function () &#123; console.log(&apos;image load successful&apos;);&#125;); 你还可以检查一个特定的图片是否加载完并且被带有id或者class的&lt;img&gt;标签代替。 自动修补破损图像 如果你碰巧发现在你的网站上发现破损的图像链接，一个个去替代他们是痛苦的。这个简单的代码可以节省很多的麻烦:12345$(&apos;img&apos;).on(&apos;error&apos;, function () &#123; if(!$(this).hasClass(&apos;broken-image&apos;)) &#123; $(this).prop(&apos;src&apos;, &apos;img/broken.png&apos;).addClass(&apos;broken-image&apos;); &#125;&#125;); 即使你没有任何断开的链接，加入这代码也不会有任何影响 Hover切换class类 比方说，当用户将鼠标悬停在你页面上的元素时，你想改变其视觉效果。当用户鼠标悬停在元素上，你可以在该元素上添加一个class类，当鼠标停止悬停事件时移除此class类:123456$(&apos;.btn&apos;).hover(function () &#123; $(this).addClass(&apos;hover&apos;); &#125;, function () &#123; $(this).removeClass(&apos;hover&apos;) &#125;&#125;); 如果你想要一个更简单的方式使用toggleClass方法，则仅仅需要添加必要的CSS:123$(&apos;.btn&apos;).hover(function () &#123; $(this).toggleClass(&apos;hover&apos;);&#125;); 禁用输入 有时你可能需要用表单的提交按钮或者某个输入框直到用户执行了某个动作（比如：检查“我已阅读条款”复选框）。在你的输入框上设置disabled属性，然后当你需要的时候启用该属性:1$(&apos;input[type=&quot;submit&quot;]&apos;).prop(&apos;disabled&apos;, true); 你需要做的只是需要在输入框上再次运行prop方法，但设置的被禁用值是false:1$(&apos;input[type=&quot;submit&quot;]&apos;).prop(&apos;disabled&apos;, false); 停止正在加载的链接 有时你不想链接到特定的网页或者重新载入页面；你可能想让他们做一些其他事情，如触发一些其他的脚本，这是防止违约行动的技巧:123$(&apos;a.no-link&apos;).click(function (e) &#123; e.preventDefault();&#125;); toggle fade/slide 滑动和淡入/淡出是我们在jQuery中经常大量使用的动画。你可能仅仅想在用户做某些点击事件的时候显示一个元素，这时候需要淡入/淡出或者滑动方法。但是如果你需要那个元素在你第一次点击的时候出现，在第二次点击的时候消失，代码如下：12345678// Fade$(&apos;.btn&apos;).click(function () &#123; $(&apos;.element&apos;).fadeToggle(&apos;slow&apos;);&#125;);// Toggle$(&apos;.btn&apos;).click(function () &#123; $(&apos;.element&apos;).slideToggle(&apos;slow&apos;);&#125;); 简单的手风琴 这是个简单快速的方法创建一个手风琴：123456789/ Close all panels$(&apos;#accordion&apos;).find(&apos;.content&apos;).hide();// Accordion$(&apos;#accordion&apos;).find(&apos;.accordion-header&apos;).click(function () &#123; var next = $(this).next(); next.slideToggle(&apos;fast&apos;); $(&apos;.content&apos;).not(next).slideUp(&apos;fast&apos;); return false;&#125;); 通过添加这个脚本，你需要做的则是必要的HTML操作在你的页面上。 使两个DIV同等高度 有时你会想要两个div有相同的高度，无论他们都有什么内容：1$(&apos;.div&apos;).css(&apos;min-height&apos;, $(&apos;.main-div&apos;).height()); 这个例子设置了div的最小高度，这意味着它的高度只可以比这个设置的高度大而不能小。然而，一个更灵活的方法是循环的一组元素，并设置将最高元素的高度作为高度:12345678var $columns = $(&apos;.column&apos;);var height = 0;$columns.each(function () &#123; if ($(this).height() &gt; height) &#123; height = $(this).height(); &#125;&#125;);$columns.height(height); 如果你想要所有的列有相同的高度：1234var $rows = $(&apos;.same-height-columns&apos;);$rows.each(function () &#123; $(this).find(&apos;.column&apos;).height($(this).height());&#125;); 在浏览器标签/新窗口打开外部链接 在新的浏览器标签或窗口中打开外部链接，并确保在同一个标签或窗口中打开的是同一个源的链接:123$(&apos;a[href^=&quot;http&quot;]&apos;).attr(&apos;target&apos;, &apos;_blank&apos;);$(&apos;a[href^=&quot;//&quot;]&apos;).attr(&apos;target&apos;, &apos;_blank&apos;);$(&apos;a[href^=&quot;&apos; + window.location.origin + &apos;&quot;]&apos;).attr(&apos;target&apos;, &apos;_self&apos;); 备注：window.location.origin在IE10不工作 根据文本获取元素 通过jQuery中的contains()选择器，你能找到一个元素内的文本内容。如果文本不存在，则这个元素将被隐藏:12var search = $(&apos;#search&apos;).val();$(&apos;div:not(:contains(&quot;&apos; + search + &apos;&quot;))&apos;).hide(); 可见变化的触发 当用户不再聚焦或者重新聚焦一个标签时触发javascript脚本:1234567$(document).on(&apos;visibilitychange&apos;, function (e) &#123; if (e.target.visibilityState === &quot;visible&quot;) &#123; console.log(&apos;Tab is now in view!&apos;); &#125; else if (e.target.visibilityState === &quot;hidden&quot;) &#123; console.log(&apos;Tab is now hidden!&apos;); &#125;&#125;); Ajax调用错误处理 当一个Ajax调用返回一个404或500的错误时，将执行该错误处理。如果该处理未定义，则其他jQuery代码便可能不会执行了。定义一个全局Ajax错误处理程序:123$(document).ajaxError(function (e, xhr, settings, error) &#123; console.log(error);&#125;); 链式操作 jQuery允许通过链式操作来减轻反复查询DOM和创建多个jQuery对象的过程。比如下面是你的方法调用:123$(&apos;#elem&apos;).show();$(&apos;#elem&apos;).html(&apos;bla&apos;);$(&apos;#elem&apos;).otherStuff(); 这代码可以通过链式大大的提高：1$(&apos;#elem&apos;).show().html(&apos;bla&apos;).otherStuff(); 另一个方法是在一个可变的元素缓存（$作为前置）：1234var $elem = $(&apos;#elem&apos;);$elem.hide();$elem.html(&apos;bla&apos;);$elem.otherStuff(); 链式和jQuery缓存方法是最好的做法，导致更短、更快的代码原文地址：https://github.com/AllThingsSmitty/jquery-tips-everyone-should-know#back-to-top-button","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://blog.luckyw.cn/categories/JQuery/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://blog.luckyw.cn/tags/JQuery/"}],"keywords":[{"name":"JQuery","slug":"JQuery","permalink":"https://blog.luckyw.cn/categories/JQuery/"}]},{"title":"Chrome插件分享","slug":"chrome-plugin","date":"2016-01-07T16:00:00.000Z","updated":"2016-10-29T06:34:02.619Z","comments":true,"path":"2016/01/08/chrome-plugin/","link":"","permalink":"https://blog.luckyw.cn/2016/01/08/chrome-plugin/","excerpt":"uBlock Origin 一款高效的网络请求过滤工具，占用极低的内存和CPU，用于过滤垃圾广告 Chrono下载管理器 比原生Chrome下载管理器有更多的功能，支持断点续传 User-Agent Switcher for Chrome 能将Chrome伪装成各种不同的浏览器 Prism Pretty 一个Chrome扩展用于格式化/突出/预览HTML、JS、CSS、Markdown代码，堪称神器 右键搜 通过它可以直接进行图片搜索及百度翻译等功能 谷歌翻译 翻译神器，在此不赘述 WEB前端助手 : FeHelper 前端开发必备插件，包含一些前端实用的工具,如字符串编解码、代码美化、JSON格式化查看、二维码生成器、编码规范检测、栅格规范检测、网页性能检测等 PostMan 一款功能强大的网页调试与发送网页HTTP请求的Chrome插件","text":"uBlock Origin 一款高效的网络请求过滤工具，占用极低的内存和CPU，用于过滤垃圾广告 Chrono下载管理器 比原生Chrome下载管理器有更多的功能，支持断点续传 User-Agent Switcher for Chrome 能将Chrome伪装成各种不同的浏览器 Prism Pretty 一个Chrome扩展用于格式化/突出/预览HTML、JS、CSS、Markdown代码，堪称神器 右键搜 通过它可以直接进行图片搜索及百度翻译等功能 谷歌翻译 翻译神器，在此不赘述 WEB前端助手 : FeHelper 前端开发必备插件，包含一些前端实用的工具,如字符串编解码、代码美化、JSON格式化查看、二维码生成器、编码规范检测、栅格规范检测、网页性能检测等 PostMan 一款功能强大的网页调试与发送网页HTTP请求的Chrome插件 Flash Video Downloader 流行的视频下载插件，能下载最流行的媒体格式包括Flash视频 新浪微博图床 图床神器 Capture Page 捕捉网页截图，编辑并将它们保存为PDF、JPEG、GIF、PNG或BMP；上传，打印，在Photoshop中打开，复制到剪贴板或电子邮件 远方 小巧精美的新扩展页插件，有上万张精美的背景图片，同时提供可配置的搜索框，天气预报，时钟等功能 Window Resizer Window Resizer扩展，允许你快速调整模拟浏览器窗口。点击菜单栏上的图标会产生一个可自定义窗口的下拉菜单 AngularJS Batarang 支持Chrome的AngularJS WebInspector扩展 Octotree Octotree是国外程序员Buu Nguyen做的一个Chrome插件。安装之后，浏览托管在Github上的项目，可看到左侧的树形结构，更方便查看代码特性： 像IDE那样方便地浏览代码 支持快速浏览 支持热键切换代码树 支持私有仓库 2016-8-18更新 阅读模式 只显示页面的主要内容栏，而且会对页面的内容进行美化，而侧边栏将会被隐藏，注意如果点击主要内容栏之外将自动退出阅读模式 Chrome Sniffer Plus 可显示当前网页使用的各种技术 GetAll 新浪微博照片批量获取工具 见文知意附上可以访问谷歌商店的hosts文件，修改之后免FQ访问谷歌服务HOSTS","categories":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/categories/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/tags/Chrome/"}],"keywords":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.luckyw.cn/categories/Chrome/"}]},{"title":"前端学习资料工具整理","slug":"front-study-tools","date":"2016-01-01T16:00:00.000Z","updated":"2016-10-26T11:16:32.280Z","comments":true,"path":"2016/01/02/front-study-tools/","link":"","permalink":"https://blog.luckyw.cn/2016/01/02/front-study-tools/","excerpt":"教程类网站： 菜鸟教程：http://www.runoob.com/CSS88:http://www.css88.com/前端网：http://www.w3cfuns.com/前端导航网：http://jsdig.com/W3CPLUS:http://www.w3cplus.com/码农网：http://www.codeceo.com/开源中国：http://www.oschina.net/WP菜鸟教程：http://www.wpnoob.cn/网络技术：http://googlo.me/webMozilla开发者网络：https://developer.mozilla.org/zh-CN/ 视频学习类网站： 慕课网：http://www.imooc.com/极客学院：http://www.jikexueyuan.com/极客标签：http://www.gbtags.com/","text":"教程类网站： 菜鸟教程：http://www.runoob.com/CSS88:http://www.css88.com/前端网：http://www.w3cfuns.com/前端导航网：http://jsdig.com/W3CPLUS:http://www.w3cplus.com/码农网：http://www.codeceo.com/开源中国：http://www.oschina.net/WP菜鸟教程：http://www.wpnoob.cn/网络技术：http://googlo.me/webMozilla开发者网络：https://developer.mozilla.org/zh-CN/ 视频学习类网站： 慕课网：http://www.imooc.com/极客学院：http://www.jikexueyuan.com/极客标签：http://www.gbtags.com/ HTML5篇 HTML5资源教程：http://www.html5tricks.com/ CSS篇： CSS参考手册：http://css.doyoe.com/AnimateCss：http://daneden.github.io/animate.css/FontAwesome：http://fontawesome.io/CSS Shake：http://elrumordelaluz.github.io/csshake/Animatable：http://leaverou.github.io/animatable/OOCSS：http://oocss.org/ResetCSS：http://meyerweb.com/eric/tools/css/reset/index.htmlNormalizeCss：https://necolas.github.io/normalize.css/ Jquery篇： JqueryAPI官方版：http://api.jquery.com/JqueryAPICHM版：http://jquery.cuishifeng.cn/Layer：http://layer.layui.com/Jquery插件库：http://www.jq22.com/dowebok：http://www.dowebok.com/ Angular篇 Angular官方文档：https://docs.angularjs.org/apiMobile Angular UI 中文网：http://www.angularui.cn/ Ionic篇 Ionic官网：http://ionicframework.com/Ionic中文网：http://www.ionic.wang/Ionic中文网:http://ionic-china.com/Ionic图标：http://ionicons.com/ 工具篇： JetBrains：http://www.jetbrains.com/Sublime Text：http://www.sublimetext.com/MyEclipse中文网:http://www.myeclipsecn.com/HBuilder：http://www.dcloud.io/ 在线编辑器 CodePen:http://codepen.io/RunJS：http://runjs.cn/在线工具：http://tool.lu/ 技术博客 淘宝FED：http://taobaofed.org/360奇舞团：http://www.75team.com/TGideas：http://tgideas.qq.com/百度FEX：http://fex.baidu.com/腾讯全端 AlloyTeam：http://www.alloyteam.com/","categories":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/tags/WEB/"}],"keywords":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}]},{"title":"移动WEB前端开发资源整合","slug":"mobile-web-front-source","date":"2015-12-24T16:00:00.000Z","updated":"2016-11-20T11:55:34.545Z","comments":true,"path":"2015/12/25/mobile-web-front-source/","link":"","permalink":"https://blog.luckyw.cn/2015/12/25/mobile-web-front-source/","excerpt":"meta篇 视窗宽度 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; 其中 width=device-width 是设置视窗宽度为设备视窗宽度，还可以设置固定宽度，例如： width=640 则是设置640px的固定宽度initial-scale=1.0：设置初始缩放比例为1.0minimum-scale=1.0 和 maximum-scale=1.0 ：最小缩放比例和最大缩放比例user-scalable=no ：禁止用户自由缩放，user-scalable 默认值为yes提示：上面那个是带全部参数的，一般设置了user-scalable=no就不需要再使用minimum-scale=1.0和maximum-scale=1.0来强制禁止缩放了1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;/&gt; 自动识别格式 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt; content里面的参数:telephone=no:禁止浏览器自动识别手机号码email=no:禁止浏览器自动识别Emailaddress=no:禁止浏览器自动识别地址date=no:禁止浏览器自动识别日期","text":"meta篇 视窗宽度 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt; 其中 width=device-width 是设置视窗宽度为设备视窗宽度，还可以设置固定宽度，例如： width=640 则是设置640px的固定宽度initial-scale=1.0：设置初始缩放比例为1.0minimum-scale=1.0 和 maximum-scale=1.0 ：最小缩放比例和最大缩放比例user-scalable=no ：禁止用户自由缩放，user-scalable 默认值为yes提示：上面那个是带全部参数的，一般设置了user-scalable=no就不需要再使用minimum-scale=1.0和maximum-scale=1.0来强制禁止缩放了1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;/&gt; 自动识别格式 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt; content里面的参数:telephone=no:禁止浏览器自动识别手机号码email=no:禁止浏览器自动识别Emailaddress=no:禁止浏览器自动识别地址date=no:禁止浏览器自动识别日期 完整模板 12345&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;/&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;/&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;address=no&quot;/&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;date=no&quot;/&gt; CSS篇 123456789101112131415161718192021222324252627282930313233343536body &#123; font-family: &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, sans-serif; /*使用无衬线字体*/&#125;a, img &#123; -webkit-touch-callout: none; /*禁止长按链接与图片弹出菜单*/&#125;html, body &#123; -webkit-user-select: none; /*禁止选中文本*/ user-select: none;&#125;button,input,optgroup,select,textarea &#123; -webkit-appearance:none; /*去掉webkit默认的表单样式*/&#125;a,button,input,optgroup,select,textarea &#123; -webkit-tap-highlight-color:rgba(0,0,0,0); /*去掉a、input和button点击时的蓝色外边框和灰色半透明背景*/&#125;input::-webkit-input-placeholder &#123; color:#ccc; /*修改webkit中input的planceholder样式*/&#125;input:focus::-webkit-input-placeholder &#123; color:#f00; /*修改webkit中focus状态下input的planceholder样式*/&#125;body &#123; -webkit-text-size-adjust: 100%!important; /*禁止IOS调整字体大小*/&#125;input::-webkit-input-speech-button &#123; display: none; /*隐藏Android的语音输入按钮*/&#125; Flex基础篇 这里假设flex容器为.box，子元素为.item具体可参考实例demo 定义容器为flex布局 12345678910.box&#123; display: -webkit-flex; /*webkit*/ display: flex;&#125;/*行内flex*/.box&#123; display: -webkit-inline-flex; /*webkit*/ display:inline-flex;&#125; 容器样式 12345678910111213141516171819.box&#123; flex-direction: row | row-reverse | column | column-reverse; /*主轴方向：左到右（默认） | 右到左 | 上到下 | 下到上*/ flex-wrap: nowrap | wrap | wrap-reverse; /*换行：不换行（默认） | 换行 | 换行并第一行在下方*/ flex-flow: &lt;flex-direction&gt; | &lt;flex-wrap&gt;; /*主轴方向和换行简写*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /*多主轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布*/&#125; 子元素样式 12345678910111213141516171819.item&#123; order: &lt;integer&gt;; /*排序：数值越小，越排前，默认为0*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: &lt;length&gt; | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125; 小技巧篇 自定义苹果图标 在网站文件根目录放一个apple-touch-icon.png文件，苹果设备保存网站为书签或桌面快捷方式时，就会使用这个文件作为图标，文件尺寸建议为:180px × 180px 自定义favicon 1&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; mce_href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; 定义浏览器点击行为123&lt;a href=&quot;tel:10086&quot;&gt;打电话给:10086&lt;/a&gt;&lt;a href=&quot;sms:10086&quot;&gt;发短信给:10086&lt;/a&gt;&lt;a href=&quot;mailto:luckywgm@gmail.com&quot;&gt;发送邮件给我&lt;/a&gt; 定义上传文件类型和格式 1&lt;input type=file accept=&quot;image/*&quot;&gt; 上面的文件上传框中，accept可以限制上传文件的类型，参数为 image/*是所有图片类型，点击会弹出图库，也可以指定图片格式，参数设置成 image/png 则可以限制图片类型为png；参数如果为 video/* 则是选择视频的意思；accept还可以设置多个文件格式，语法为accept=&quot;image/gif, image/jpeg&quot; 使用box-shadow改变(挡住)表单自动填充后的黄色 123input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill&#123; box-shadow:inset 0 0 0 1000px #fff;&#125; 用CSS实现省略号文字截断 123white-space: nowrap;text-overflow: ellipsis;overflow: hidden; 使用border绘制小三角 原理是：上下和左右的边框对接其实是个斜角，利用这个特性，使其中一边的边框透明，另外一边写成想要的颜色并隐藏对边，就可以变成小箭头形状。1234width: 0;border-style: solid;border-color: transparent #efefef;border-width: 10px 10px 10px 0; //左箭头 Tootip写法：12&lt;!--html--&gt;&lt;div class=&quot;box&quot;&gt;Hello World&lt;/div&gt; 123456789101112131415161718192021222324/*--css--*/.box&#123; position: relative; padding: 0 20px; width: 100px; height: 80px; border-radius: 8px; background: #efefef; font-size: 18px; line-height: 80px;&#125;.box:after&#123; position: absolute; top: 50%; left: -15px; z-index: 1; display: block; margin-top: -15px; width: 0; border-color: transparent #efefef; border-style: solid; border-width: 15px 15px 15px 0; content: &quot;&quot;;&#125;","categories":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/tags/WEB/"}],"keywords":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}]},{"title":"JavaScript 开发的45个经典技巧","slug":"js-45-tips","date":"2015-12-19T16:00:00.000Z","updated":"2016-11-20T10:59:12.871Z","comments":true,"path":"2015/12/20/js-45-tips/","link":"","permalink":"https://blog.luckyw.cn/2015/12/20/js-45-tips/","excerpt":"JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（PhoneGap、Appcelerator）、服务器端开发（Node.js、Wakanda）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用本文中的示例代码，通过了在Google Chrome最新版上的测试 首次为变量赋值时务必使用var关键字 变量没有声明而直接赋值的话，默认会作为一个新的全局变量，要尽量避免使用全局变量 使用===取代== ==和!=操作符会在需要的情况下自动转换数据类型。但===和!==不会，它们会同时比较值和数据类型，这也使得它们要比==和!=快。12345678[10] === 10 // is false[10] == 10 // is true&apos;10&apos; == 10 // is true&apos;10&apos; === 10 // is false [] == 0 // is true [] === 0 // is false &apos;&apos; == false // is true but true == &quot;a&quot; is false &apos;&apos; === false // is false underfined、null、0、false、NaN、空字符串的逻辑结果均为false 行尾使用分号 实践中最好还是使用分号，忘了写也没事，大部分情况下JavaScript解释器都会自动添加 使用对象构造器 12345function Person(firstName, lastName)&#123; this.firstName = firstName; this.lastName = lastName;&#125;var Saad = new Person(&quot;Saad&quot;, &quot;Mousliki&quot;);","text":"JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（PhoneGap、Appcelerator）、服务器端开发（Node.js、Wakanda）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用本文中的示例代码，通过了在Google Chrome最新版上的测试 首次为变量赋值时务必使用var关键字 变量没有声明而直接赋值的话，默认会作为一个新的全局变量，要尽量避免使用全局变量 使用===取代== ==和!=操作符会在需要的情况下自动转换数据类型。但===和!==不会，它们会同时比较值和数据类型，这也使得它们要比==和!=快。12345678[10] === 10 // is false[10] == 10 // is true&apos;10&apos; == 10 // is true&apos;10&apos; === 10 // is false [] == 0 // is true [] === 0 // is false &apos;&apos; == false // is true but true == &quot;a&quot; is false &apos;&apos; === false // is false underfined、null、0、false、NaN、空字符串的逻辑结果均为false 行尾使用分号 实践中最好还是使用分号，忘了写也没事，大部分情况下JavaScript解释器都会自动添加 使用对象构造器 12345function Person(firstName, lastName)&#123; this.firstName = firstName; this.lastName = lastName;&#125;var Saad = new Person(&quot;Saad&quot;, &quot;Mousliki&quot;); 小心使用typeof、instanceof和contructor typeof:JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，typeof null也会返回object，大多数的对象类型（数组Array、时间Date等）也会返回object contructor:内部原型属性，可以通过代码重写 instanceof:JavaScript操作符，会在原型链中的构造器中搜索，找到则返回true，否则返回false 1234var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];typeof arr; // 返回 &quot;object&quot;arr instanceof Array // truearr.constructor(); //[] 使用自调用函数 函数在创建之后直接自动执行，通常称之为自调用匿名函数或直接调用函数表达式,格式如下：1234567(function()&#123; // 置于此处的代码将自动执行&#125;)();(function(a,b)&#123; var result = a+b; return result;&#125;)(10,20) 从数组中随机获取成员 12var items = [12, 548 , &apos;a&apos; , 2 , 5478 , &apos;foo&apos; , 8852, , &apos;Doe&apos; , 2145 , 119];var randomItem = items[Math.floor(Math.random() * items.length)]; 获取指定范围内的随机数 12这个功能在生成测试用的假数据时特别有数，比如介于指定范围内的随机数var x = Math.floor(Math.random() * (max - min + 1)) + min; 生成从0到指定值的数字数组 12var numbersArray = [] , max = 100;for( var i=1; numbersArray.push(i++) &lt; max;); // numbers = [1,2,3 ... 100] 生成随机的字母数字字符串 12345function generateRandomAlphaNum(len) &#123; var rdmString = &quot;&quot;; for( ; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len);&#125; 打乱数字数组的顺序 12var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];numbers = numbers.sort(function()&#123; return Math.random() - 0.5&#125;); 这里使用了JavaScript内置的数组排序函数，更好的办法是用专门的代码来实现 字符串去空格 Java、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，可以通过下面的代码来为String对象函数一个trim函数：1String.prototype.trim = function()&#123;return this.replace(/^\\s+|\\s+$/g, &quot;&quot;);&#125;; 新的JavaScript引擎已经有了trim()的原生实现 数组之间追加 123var array1 = [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458];var array2 = [&quot;Doe&quot; , 555 , 100];Array.prototype.push.apply(array1, array2); 对象转换为数组 1var argArray = Array.prototype.slice.call(arguments); 验证是否是数字 123function isNumber(n)&#123; return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#125; 验证是否是数组 123function isArray(obj)&#123; return Object.prototype.toString.call(obj) === &apos;[object Array]&apos; ;&#125; 但如果toString()方法被重写过得话，就行不通了。也可以使用下面的方法：1Array.isArray(obj); // its a new Array method 如果在浏览器中没有使用iframe，还可以用instanceof，但如果上下文太复杂，也有可能出错1234567var myFrame = document.createElement(&apos;iframe&apos;);document.body.appendChild(myFrame);var myArray = window.frames[window.frames.length-1].Array;var arr = new myArray(a,b,10); // [a,b,10]// myArray 的构造器已经丢失，instanceof 的结果将不正常// 构造器是不能跨 iframe 共享的arr instanceof Array; // false 获取数组中的最大值和最小值 123var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];var maxInNumbers = Math.max.apply(Math, numbers);var minInNumbers = Math.min.apply(Math, numbers); 清空数组 12var myArray = [12 , 222 , 1000 ];myArray.length = 0; // myArray will be equal to []. 不要直接从数组中delete或remove元素 如果对数组元素直接使用delete，其实并没有删除，只是将元素置为了undefined。数组元素删除应使用splice切忌：12345var items = [12, 548 ,&apos;a&apos; , 2 , 5478 , &apos;foo&apos; , 8852, , &apos;Doe&apos; ,2154 , 119 ];items.length; // return 11delete items[3]; // return trueitems.length; // return 11/* items 结果为 [12, 548, &quot;a&quot;, undefined × 1, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119] */ 而应：12345var items = [12, 548 ,&apos;a&apos; , 2 , 5478 , &apos;foo&apos; , 8852, , &apos;Doe&apos; ,2154 , 119 ];items.length; // return 11items.splice(3,1) ;items.length; // return 10/* items 结果为 [12, 548, &quot;a&quot;, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119] 删除对象的属性时可以使用delete 使用length属性截断数组 前面的例子中用length属性清空数组，同样还可用它来截断数组：12var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ];myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124]. 与此同时，如果把length属性变大，数组的长度值变会增加，会使用undefined来作为新的元素填充。length是一个可写的属性12myArray.length = 10; // the new array length is 10myArray[myArray.length - 1] ; // undefined 在条件中使用逻辑与或 123var foo = 10;foo == 10 &amp;&amp; doSomething(); // is the same thing as if (foo == 10) doSomething();foo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething(); 逻辑或还可用来设置默认值，比如函数参数的默认值123function doSomething(arg1)&#123; arg1 = arg1 || 10; // arg1 will have 10 as a default value if it’s not already set&#125; 使得map()函数方法对数据循环 1234var squares = [1,2,3,4].map(function (val) &#123; return val * val;&#125;);// squares will be equal to [1, 4, 9, 16] 保留指定小数位数 12var num =2.443242342;num = num.toFixed(4); // num will be equal to 2.4432 注意，toFixed()返回的是字符串，不是数字 浮点计算的问题 1230.1 + 0.2 === 0.3 // is false9007199254740992 + 1 // is equal to 90071992547409929007199254740992 + 2 // is equal to 9007199254740994 为什么呢？因为0.1+0.2=0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示,可以通过使用toFixed()和toPrecision()来解决这个问题 通过for-in循环检查对象的属性 下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。12345for (var name in object) &#123; if (object.hasOwnProperty(name)) &#123; // do something with name &#125;&#125; 逗号操作符 1234var a = 0;var b = ( a++, 99 );console.log(a); // a will be equal to 1console.log(b); // b is equal to 99 临时存储用于计算和查询的变量 在jQuery选择器中，可以临时存储整个DOM元素。1234var navright = document.querySelector(&apos;#right&apos;);var navleft = document.querySelector(&apos;#left&apos;);var navup = document.querySelector(&apos;#up&apos;);var navdown = document.querySelector(&apos;#down&apos;); 提前检查传入isFinite()的参数 1234567isFinite(0/0) ; // falseisFinite(&quot;foo&quot;); // falseisFinite(&quot;10&quot;); // trueisFinite(10); // trueisFinite(undefined); // falseisFinite(); // falseisFinite(null); // true，这点当特别注意 避免在数组中使用负数做索引 123var numbersArray = [1,2,3,4,5];var from = numbersArray.indexOf(&quot;foo&quot;) ; // from is equal to -1numbersArray.splice(from,2); // will return [5] 注意传给splice的索引参数不要是负数，当是负数时，会从数组结尾处删除元素 用JSON来序列化与反序列化 12345var person = &#123;name :&apos;Saad&apos;, age : 26, department : &#123;ID : 15, name : &quot;R&amp;D&quot;&#125; &#125;;var stringFromPerson = JSON.stringify(person);/* stringFromPerson 结果为 &quot;&#123;&quot;name&quot;:&quot;Saad&quot;,&quot;age&quot;:26,&quot;department&quot;:&#123;&quot;ID&quot;:15,&quot;name&quot;:&quot;R&amp;D&quot;&#125;&#125;&quot; */var personFromString = JSON.parse(stringFromPerson);/* personFromString 的值与 person 对象相同 */ 不要使用eval()或者函数构造器 eval()和函数构造器的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码12var func1 = new Function(functionCode);var func2 = eval(functionCode); 避免使用with() 使用with()可以把变量加入到全局作用域中，因此，如果有其它的同名变量，一来容易混淆，二来值也会被覆盖 不要对数组使用for-in 避免：1234var sum = 0;for (var i in arrayNumbers) &#123; sum += arrayNumbers[i];&#125; 而是：1234var sum = 0;for (var i = 0, len = arrayNumbers.length; i &lt; len; i++) &#123; sum += arrayNumbers[i];&#125; 另外一个好处是，i和len两个变量是在for循环的第一个声明中，二者只会初始化一次，这要比下面这种写法快：1for (var i = 0; i &lt; arrayNumbers.length; i++) 传给setInterval()和setTimeout()时使用函数而不是字符串 如果传给setTimeout()和setInterval()一个字符串，他们将会用类似于eval方式进行转换，这肯定会要慢些，因此不要使用：12setInterval(&apos;doSomethingPeriodically()&apos;, 1000);setTimeout(&apos;doSomethingAfterFiveSeconds()&apos;, 5000); 而是用：12setInterval(doSomethingPeriodically, 1000); setTimeout(doSomethingAfterFiveSeconds, 5000); 使用switch/case代替一大叠的if/else 当判断有超过两个分支的时候使用switch/case要更快一些，而且也更优雅，更利于代码的组织，当然，如果有超过10个分支，就不要使用switch/case了 在switch/case中使用数字区间 其实，switch/case中的case条件，还可以这样写：12345678910111213141516171819function getCategory(age) &#123; var category = &quot;&quot;; switch (true) &#123; case isNaN(age): category = &quot;not an age&quot;; break; case (age &gt;= 50): category = &quot;Old&quot;; break; case (age &lt;= 20): category = &quot;Baby&quot;; break; default: category = &quot;Young&quot;; break; &#125;; return category;&#125;getCategory(5); // 将返回 &quot;Baby&quot; 使用对象作为对象的原型 下面这样，便可以给定对象作为参数，来创建以此为原型的新对象：123456function clone(object) &#123; function OneShotConstructor()&#123;&#125;; OneShotConstructor.prototype = object; return new OneShotConstructor();&#125;clone(Array).prototype ; // [] HTML字段转换函数 123456function escapeHTML(text) &#123; var replacements= &#123;&quot;&lt;&quot;: &quot;&lt;&quot;, &quot;&gt;&quot;: &quot;&gt;&quot;,&quot;&amp;&quot;: &quot;&amp;&quot;, &quot;\\&quot;&quot;: &quot;&quot;&quot;&#125;; return text.replace(/[&lt;&gt;&amp;&quot;]/g, function(character) &#123; return replacements[character]; &#125;);&#125; 不要在循环内部使用try-catch-finally try-catch-finally中catch部分在执行时会将异常赋给一个变量，这个变量会被构建成一个运行时作用域内的新的变量切忌：123456789var object = [&apos;foo&apos;, &apos;bar&apos;], i;for (i = 0, len = object.length; i &lt;len; i++) &#123; try &#123; // do something that throws an exception &#125; catch (e) &#123; // handle exception &#125;&#125; 而应该：123456789var object = [&apos;foo&apos;, &apos;bar&apos;], i;try &#123; for (i = 0, len = object.length; i &lt;len; i++) &#123; // do something that throws an exception &#125;&#125;catch (e) &#123; // handle exception&#125; 使用XMLHttpRequests时注意设置超时 XMLHttpRequests在执行时，当长时间没有响应（如出现网络问题等）时，应该中止掉连接，可以通过setTimeout()来完成这个工作：123456789101112var xhr = new XMLHttpRequest ();xhr.onreadystatechange = function () &#123; if (this.readyState == 4) &#123; clearTimeout(timeout); // do something with response data &#125;&#125;var timeout = setTimeout( function () &#123; xhr.abort(); // call error callback&#125;, 60*1000 /* timeout after a minute */ );xhr.open(&apos;GET&apos;, url, true);xhr.send(); 同时需要注意的是，不要同时发起多个XMLHttpRequests请求 处理WebSocket的超时 通常情况下，WebSocket连接创建后，如果30秒内没有任何活动，服务器端会对连接进行超时处理，防火墙也可以对单位周期没有活动的连接进行超时处理为了防止这种情况的发生，可以每隔一定时间，往服务器发送一条空的消息。可以通过下面这两个函数来实现这个需求，一个用于使连接保持活动状态，另一个专门用于结束这个状态。12345678910111213var timerID = 0;function keepAlive() &#123; var timeout = 15000; if (webSocket.readyState == webSocket.OPEN) &#123; webSocket.send(&apos;&apos;); &#125; timerId = setTimeout(keepAlive, timeout);&#125;function cancelKeepAlive() &#123; if (timerId) &#123; cancelTimeout(timerId); &#125;&#125; keepAlive()函数可以放在WebSocket连接的onOpen()方法的最后面，cancelKeepAlive()放在onClose()方法的最末尾 注意原始操作符比函数调用快 比如，一般不要这样：12var min = Math.min(a,b);A.push(v); 可以这样来代替：12var min = a &lt; b ? a : b;A[A.length] = v; 开发时注意代码结构，上线前检查并压缩JavaScript代码 别忘了在写代码时使用一个代码美化工具。使用JSLint(一个语法检查工具)并且在上线前压缩代码（比如使用JSMin）。注：现在代码压缩一般推荐UglifyJS JavaScript博大精深，这里有些不错的学习资源 Code Academy资源：http://www.codecademy.com/tracks/javascriptMarjin Haverbekex编写的Eloquent JavaScript：http://eloquentjavascript.net/John Resig编写的Advanced JavaScript：http://ejohn.org/apps/learn/来源：http://www.codeceo.com/article/javascript-45-tips.html","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"前端开发面试题集锦","slug":"front-end-development","date":"2015-12-14T16:00:00.000Z","updated":"2016-11-20T10:47:23.469Z","comments":true,"path":"2015/12/15/front-end-development/","link":"","permalink":"https://blog.luckyw.cn/2015/12/15/front-end-development/","excerpt":"你如何理解HTML结构的语意化? 1、去掉或样式丢失的时候能让页面呈现清晰的结构2、屏幕阅读器（如果访客有视障）会完全根据你的标记来”读”你的网页3、PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）4、搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重5、你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记，而只注重语义标记6、便于团队开发和维护 Doctype文档声明的严格模式和混杂模式，如何触发这两种模式，区分它们有何意义? 1、如何触发两种模式加入xml头部声明，可以触发IE浏览器的Quirks mode(怪异模式)，触发之后，浏览器解析方式就和IE5.5一样，拥有IE5.5一样的bug和其他问题，行为（Javascript）也是如此。2、IE6的触发：在XHTML的DOCTYPE前加入XML声明12&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 3、IE7的触发：在XML声明和XHTML的DOCTYPE之间，加入HTML注释123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- ... and keep IE7 in quirks mode --&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 4、IE6和IE7都可以触发的：在HTML4.01的DOCTYPE文档头部，加入HTML注释1&lt;!-- quirks mode --&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;","text":"你如何理解HTML结构的语意化? 1、去掉或样式丢失的时候能让页面呈现清晰的结构2、屏幕阅读器（如果访客有视障）会完全根据你的标记来”读”你的网页3、PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）4、搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重5、你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记，而只注重语义标记6、便于团队开发和维护 Doctype文档声明的严格模式和混杂模式，如何触发这两种模式，区分它们有何意义? 1、如何触发两种模式加入xml头部声明，可以触发IE浏览器的Quirks mode(怪异模式)，触发之后，浏览器解析方式就和IE5.5一样，拥有IE5.5一样的bug和其他问题，行为（Javascript）也是如此。2、IE6的触发：在XHTML的DOCTYPE前加入XML声明12&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 3、IE7的触发：在XML声明和XHTML的DOCTYPE之间，加入HTML注释123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- ... and keep IE7 in quirks mode --&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 4、IE6和IE7都可以触发的：在HTML4.01的DOCTYPE文档头部，加入HTML注释1&lt;!-- quirks mode --&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 5、在页面顶部加&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;，将触发”怪异模式”6、没有使用DTD声明或者使用HTML4以下（不包括HTML4）的DTD声明时，基本上所有的浏览器都是使用quirks mode呈现 谈谈以前端角度出发做好SEO需要考虑什么？ 1、了解搜索引擎如何抓取网页和如何索引网页2、Meta标签优化3、如何选取关键词并在网页中放置关键词4、了解主要的搜索引擎5、主要的互联网目录6、按点击付费的搜索引擎7、搜索引擎登录8、链接交换和链接广泛度9、标签的合理使用 我们知道可以以外链的方式引入CSS文件，请谈谈外链引入CSS有哪些方式，这些方式的性能有区别吗？ CSS的引入方式最常用的有三种： 第一：在head部分加入 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;my.css&quot;/&gt;, 引入外部的CSS文件。 第二：在head部分加入 123&lt;style type=&quot;text/css&quot;&gt; div&#123;margin: 0;padding: 0;border:1px red solid;&#125;&lt;/style&gt; 第三：直接在页面的标签里加，比如：&lt;div style=&quot;border:1px red solid;&quot;&gt; CSS Sprite是什么，谈谈这个技术的优缺点？ CSS sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到中去，减少对服务器的请求次数，提高访问速度1、优点： 利用CSS Sprites能很好地减少了网页的http请求，从而大大的提高了页面的性能，这也是CSS Sprite的优点，也是其被广泛传播和应用的主要原因 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素命名，从而提高了网页的制作效率 换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来也很方便 2、缺点： 在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内显示不必要的背景。这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易将背景断裂 CSS Sprites在开发的时候比较麻烦，你要通过photoshop或其他工具测量计算每一个背景单元的精确位是针线活，没什么难度，但是很繁琐 CSS Sprites在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的好不要动，这样避免改动更多的css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字加了，还要改动css 以CSS3标准定义一个webkit内核浏览器识别的圆角（尺寸随意） 12345div&#123; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius:10px;&#125; 行内元素有哪些？块级元素有哪些？CSS的盒模型？ 行内元素有： a b span I em img input select strong 级元素有： div ul ol li dl dt dd h1 h2 h3 h4 p 盒模型： margin border padding content 前端页面有哪三层构成，分别是什么？作用是什么？ 网页分成三个层次，即：结构层、表示层、行为层。 网页的结构层:由HTML或XHTML之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：”这是一个文本段。” 网页的表示层:由CSS负责创建。CSS对”如何显示有关内容”的问题做出了回答 网页的行为层:负责回答”内容应该如何对事件做出反应”这一问题。这是Javascript语言和DOM主宰的领域 html中form里action方法的get和post有什么区别？ Get是用来从服务器上获得数据，而Post是用来向服务器上传递数据 Get将表单中数据的按照variable=value的形式，添加到action所指向的URL后面，并且两者使用?连接，而各个变量之间使用&amp;连接。Post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL Get是不安全的，因为在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post的所有操作对用户来说都是不可见的 Get传输的数据量小，这主要是因为受URL长度限制。而Post可以传输大量的数据，所以在上传文件只能使用Post Get限制Form表单的数据集的值必须为ASCII字符。而Post支持整个ISO10646字符集 Get是Form的默认方法 html元素的id跟class什么区别 id和class是网页中两个通用属性，他们协同工作使整个页面丰富多彩，当我们为一个元素定义样式时，二者都可用，但有区别 1、在css样式表中书写时，id选择符前缀应加#，class选择符前缀应加.2、id属性在一个页面中书写时只能使用一次，而class可以反复使用3、id作为元素标签用于区分不同结构和内容，而class作为一个样式，可以应用到任何结构和内容当中去4、布局上的一般原则:id先确定结构和内容再为它定义样式。而class正好相反，是先定义样式，然后在页面中根据不同需求把样式应用到不同结构和内容上5、目前浏览器都允许同一个页面出现多个相同属性值的id，一般情况能正常显示，不过当javascript通过id来控制元素时就会出错6、在实际应用中，class常被用到文字版块和页面修饰上，而id多被用在宏伟布局和设计包含块，或包含框的样式 Ajax是什么？ Ajax不是一个技术，它实际上是几种技术，每种技术都有其独特这处，合在一起就成了一个功能强大的新技术。Ajax包括： XHTML和JS 使用文档对象模型作动态显示和交互 使用XML和XSLT做数据交互和操作 使用XMLHttpRequest进行异步数据接收 使用JavaScript将它们绑定在一起 html5 离线存储 Html5的一个重要特性就是离线存储，所谓的离线存储就是将一些资源文件保存在本地，这样后续的页面重新加载将使用本地资源文件，在离线情况下可以继续访问web应用，同时通过一定的手法（更新相关文件或者使用相关API），可以更新、删除离线存储等操作。Html5的离线存储使用一个manifest文件来标明哪些文件是需要被存储的，使用如 &lt;html manifest=&#39;offline.manifest&#39;&gt;来引入一个manifest文件，这个文件的路径可以是相对的，也可以是绝对的，如果你的web应用很多，而且希望能集中管理manifest文件，那么静态文件服务器是个不错的选择 iframe的优缺点？ 1、缺点：在网页中使用框架结构最大的弊病是搜索引擎的”蜘蛛”程序无法解读这种页面。当”蜘蛛”程序遇到由数个框架组成的网页时，它们只看到框架而无法找到链接，因此它们会以为该网站是个死站点，并且很快转身离去。对一个网站来说这无异于一场灾难。如果你想销售产品，你需要客户;如想得到客户，你首先要让人们访问你的网站，而要做到这一点，你就非求助于搜索引擎不可。你花费了大量的时间、精力和金钱开设了一家网上商店，却又故意不让搜索引擎检索你，这就好象开家零售商店，却将窗户全部漆成黑色，而且还不挂任何招牌一样2、优点：从上文中我们可以发现，使用iframe框架的弊端是无法被搜索引擎所爬行抓取。但凡事总是具有两面性。它的这个缺点也可能是他的优点。利用这一点那我 =们就可以把我们站点上一些需要给我们的用户查看，但是不需要搜索引擎爬行的内容用iframe框架进行显示，这样就可以让iframe发挥真正的效果了，而且有我们站点中的代码也可以得到很大的精简iframe好在能够把原先的网页全部原封不动显示下来,但是如果用在首页,是搜索引擎最套讨厌的.那么你的网站即使做的在好,也排不到好的名次!如果是动态网页，用include还好点！但是必须要去除他的&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;body&gt;标签！框架的优点 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度) 方便制作导航栏 框架的缺点 会产生很多页面，不容易管理 不容易打印 浏览器的后退按钮无效 代码复杂,无法被一些搜索引擎索引到 多数小型的移动设备无法完全显示框架 多框架的页面会增加服务器的http请求 由于上面诸多缺点，因此不符合标准网页设计的理念,已经被标准网页设计抛弃 提示: 目前框架的所有优点完全可以使用Ajax实现，因此已经没有必要使用框架了 CSS盒模型原理 W3C 盒子模型的范围包括margin、border、padding、content，并且 content 部分不包含其他部分。 IE 盒子模型的范围也包括margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE盒子模型的content部分包含了border和pading CSS display:none和visibility:hidden的区别 visibility:hidden隐藏，但在浏览时保留位置 display:none视为不存在，且不加载 jQuery是什么？ jQuery是javascript编写一个可重用的JavaScript库不使用jQuery设置文本的JavaScript代码如下：1document.getElementById(&quot;txt1&quot;).value = &quot;hello&quot;; 用jQuery类库后的的JavaScript代码如下：1$(&quot;#txt1&quot;).val(&quot;Hello&quot;); 可见，在使用jQuery类库后的JavaScript代码明显简洁了很多 jquery与JavaScript的关系，jQuery会取代JavaScript吗？ JavaScript：是一门Web最流行的脚本语言 jQuery: 是一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+） jQuery是并不是要取代的JavaScript。使用jQuery使Web开发变得简单 CDN（内容分发网络）是什么？ 在开发Web页面，考虑最多的问题之一是页面在客户端电脑的响应：时间越短，用户体验越好而制约用户体验的关键因素之一是浏览器下载Web文件大小，包括html、图片、js、css等文件。为了最大化复用和节约带宽，故CDN应运而生:其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度 如何在CDN网络不可访问情况下，能自动访问网站的jQuery文件？ 一般情况下，CDN网络节点是可靠的。但是偶尔也有失灵的时候，故为了提供双保险，可进行判断网络加载CDN失败，则自动加载网站上的jQuery, 示例代码如下：1234567&lt;script type=&quot;text/javascript&quot; src=&quot;//ajax.microsoft.com/ajax/jquery/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;if (typeof jQuery == &apos;undefined&apos;)&#123; document.write(unescape(&quot;%3Cscript src=&apos;Scripts/jquery.1.9.1.min.js&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));&#125;&lt;/script&gt; 同版本的jQuery.js文件和jQuery.min.js有何不同？ 相同：这两个文件提供相同的jQuery的功能，即在函数调用上没有区别 不同：jQuery.js文件，适合让程序员阅读。jQuery.min.js文件，通过压缩和删除所有的空格，以节省带宽和空间，使得文件更小，用于网络传输，不适合程序员阅读 何时使用jquery.js，何时使用jquery.min.js？ 开发调试场景下：用jQuery.js文件，因为你想调试，能够看到javascript代码。 生产部署环境下：用jQuery.min.js文件，可减少网络宽度，加快网页加载速度 为何要使用jQuery.noConflict()？ 有很多类似jQuery一样的类库，在这些类库中，有的也使用了$符号，如果同时使用，则会导致命名冲突为了解决这个冲突，需要用到jQuery.noConflict()，这样就不依赖$这个默认符号了。例如：1234jQuery.noConflict();(function($)&#123;...&#125;)(jQuery);","categories":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/tags/WEB/"}],"keywords":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}]},{"title":"前端面试题总结HTML——CSS部分","slug":"web-interview-css","date":"2015-12-09T16:00:00.000Z","updated":"2016-10-26T11:25:28.356Z","comments":true,"path":"2015/12/10/web-interview-css/","link":"","permalink":"https://blog.luckyw.cn/2015/12/10/web-interview-css/","excerpt":"对WEB标准以及W3C的理解与认识 标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性 XHTML和HTML有什么区别 HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同： XHTML元素必须被正确地嵌套XHTML元素必须被关闭XHTML文档必须拥有根元素标签名必须用小写字母","text":"对WEB标准以及W3C的理解与认识 标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性 XHTML和HTML有什么区别 HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同： XHTML元素必须被正确地嵌套XHTML元素必须被关闭XHTML文档必须拥有根元素标签名必须用小写字母 行内元素有哪些?块级元素有哪些?CSS的盒模型? 块级元素: div p h1 h2 h3 h4 form ul行内元素: a b br i span input selectCss盒模型: content、border、margin、padding CSS引入的方式有哪些? link和@import的区别是? 内联 内嵌 外链 导入区别：同时加载前者无兼容性，后者CSS2.1以下浏览器不支持link支持使用javascript改变样式，后者不可 CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高? 标签选择符 类选择符 id选择符继承不如指定 Id&gt;class&gt;标签选择后者优先级高 前端页面有哪三层构成，分别是什么? 结构层 Html 表示层 CSS 行为层 js 常见浏览器的内核是什么? IE(Trident) 火狐(Gecko) 谷歌(webkit) Opear(Presto) IE6 BUG的解决方法 123456789双边距BUG：float引起的使用display:inline3像素问题：使用float引起的使用_margin-left: value-3px;超链接hover点击后失效,使用正确的书写顺序：link-visited-hover-active(LVHA,简称爱恨规则)Ie z-index问题：给父级添加position:relativePng透明：使用js代码Min-height最小高度!Important解决select在ie6下遮盖使用iframe嵌套为什么没有办法定义1px左右的宽度容器(IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px)ie6不支持!important img标签上title与alt属性的区别是什么? Alt当图片不显示时用文字代表Title为该元素提供信息，鼠标hover显示内容 描述css reset的作用和用途 重置浏览器的css默认属性，浏览器的品种不同、样式不同，然后重置，让他们统一 css sprites css sprites把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量 浏览器标准模式和怪异模式之间的区别是什么? 盒子模型 渲染模式的不同使用window.top.document.compatMode可显示为什么模式 如何对网站的文件和资源进行优化? 文件合并文件最小化/文件压缩使用CDN托管缓存的使用 什么是语义化的HTML? 直观的认识标签，对于搜索引擎的抓取有好处 清除浮动的几种方式，各自的优缺点 使用空标签清除浮动clear:both(增加无意义的标签)使用overflow:auto，使用zoom:1用于兼容IE使用afert伪元素清除浮动(用于非IE浏览器)","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"圣杯布局","slug":"css-layout-shengbei","date":"2015-12-04T16:00:00.000Z","updated":"2016-11-20T10:45:14.111Z","comments":true,"path":"2015/12/05/css-layout-shengbei/","link":"","permalink":"https://blog.luckyw.cn/2015/12/05/css-layout-shengbei/","excerpt":"CSS布局终极方案之–圣杯布局（兼容IE6+，现代浏览器） 经典三列布局，也叫做圣杯布局【Holy Grail of Layouts】是Kevin Cornell在2006年提出的一个布局模型概念，在国内最早是由淘宝UED的工程师传播开来，在中国也有叫法是双飞翼布局，它的布局要求有几点： 三列布局，中间宽度自适应，两边定宽 中间栏要在浏览器中优先展示渲染 允许任意列的高度最高 要求只用一个额外的DIV标签 要求用最简单的CSS、最少的HACK语句 效果图：","text":"CSS布局终极方案之–圣杯布局（兼容IE6+，现代浏览器） 经典三列布局，也叫做圣杯布局【Holy Grail of Layouts】是Kevin Cornell在2006年提出的一个布局模型概念，在国内最早是由淘宝UED的工程师传播开来，在中国也有叫法是双飞翼布局，它的布局要求有几点： 三列布局，中间宽度自适应，两边定宽 中间栏要在浏览器中优先展示渲染 允许任意列的高度最高 要求只用一个额外的DIV标签 要求用最简单的CSS、最少的HACK语句 效果图：CSS 和 DOM 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;title&gt;圣杯布局&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123;background-color: #ffffff; font-size:14px;&#125; #hd, #ft &#123;padding:20px 3px; background-color: #cccccc; text-align: center;&#125; .bd-lft, .bd-rgt, .bd-3-lr, .bd-3-ll, .bd-3-rr &#123;margin:10px 0; min-width:400px;&#125; .main &#123;background-color: #03a9f4; color:#ffffff;&#125; .aside, .aside-1, .aside-2 &#123;background-color: #00bcd4; color:#ffffff;&#125; p &#123;margin:0; padding:20px; text-align: center;&#125; /* 左侧栏固定宽度，右侧自适应 */ .bd-lft &#123; zoom:1; overflow:hidden; padding-left:210px; &#125; .bd-lft .aside &#123; float:left; width:200px; margin-left:-100%; /*= -100%*/ position:relative; left:-210px; /* = -parantNode.paddingLeft */ _left: 0; /*IE6 hack*/ &#125; .bd-lft .main &#123; float:left; width:100%; &#125; /* 右侧栏固定宽度，左侧自适应 */ .bd-rgt &#123; zoom:1; overflow:hidden; padding-right:210px; &#125; .bd-rgt .aside &#123; float:left; width:200px; margin-left:-200px; /* = -this.width */ position:relative; right:-210px; /* = -parantNode.paddingRight */ &#125; .bd-rgt .main &#123; float:left; width:100%; &#125; /* 左中右 三栏自适应 */ .bd-3-lr &#123; zoom:1; overflow:hidden; padding-left:210px; padding-right:210px; &#125; .bd-3-lr .main &#123; float:left; width:100%; &#125; .bd-3-lr .aside-1 &#123; float: left; width:200px; margin-left: -100%; position:relative; left: -210px; _left: 210px; /*IE6 hack*/ &#125; .bd-3-lr .aside-2 &#123; float: left; width:200px; margin-left: -200px; position:relative; right: -210px; &#125; /* 都在左边，右侧自适应 */ .bd-3-ll &#123; zoom:1; overflow:hidden; padding-left:420px; &#125; .bd-3-ll .main &#123; float:left; width:100%; &#125; .bd-3-ll .aside-1 &#123; float: left; width:200px; margin-left: -100%; position:relative; left: -420px; _left: 0px; /*IE6 hack*/ &#125; .bd-3-ll .aside-2 &#123; float: left; width:200px; margin-left: -100%; position:relative; left: -210px; _left: 210px; /*IE6 hack*/ &#125; /* 都在右边，左侧自适应 */ .bd-3-rr &#123; zoom:1; overflow:hidden; padding-right:420px; &#125; .bd-3-rr .main &#123; float:left; width:100%; &#125; .bd-3-rr .aside-1 &#123; float: left; width:200px; margin-left: -200px; position:relative; right: -210px; &#125; .bd-3-rr .aside-2 &#123; float: left; width:200px; margin-left: -200px; position:relative; right: -420px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;hd&quot;&gt;头部&lt;/div&gt; &lt;div class=&quot;bd-lft&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;主内容栏自适应宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;aside&quot;&gt; &lt;p&gt;侧边栏固定宽度&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bd-rgt&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;主内容栏自适应宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;aside&quot;&gt; &lt;p&gt;侧边栏固定宽度&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bd-3-lr&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;主内容栏自适应宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;aside-1&quot;&gt; &lt;p&gt;侧边栏1固定宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;aside-2&quot;&gt; &lt;p&gt;侧边栏2固定宽度&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bd-3-ll&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;主内容栏自适应宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;aside-1&quot;&gt; &lt;p&gt;侧边栏1固定宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;aside-2&quot;&gt; &lt;p&gt;侧边栏2固定宽度&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bd-3-rr&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;主内容栏自适应宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;aside-1&quot;&gt; &lt;p&gt;侧边栏1固定宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;aside-2&quot;&gt; &lt;p&gt;侧边栏2固定宽度&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;ft&quot;&gt;底部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"行内元素与块级元素","slug":"block-inline-element","date":"2015-11-30T16:00:00.000Z","updated":"2016-10-26T11:12:53.940Z","comments":true,"path":"2015/12/01/block-inline-element/","link":"","permalink":"https://blog.luckyw.cn/2015/12/01/block-inline-element/","excerpt":"块级元素列表 元素名 含义 address 定义地址 caption 定义表格标题 dd 定义列表中定义条目 div 定义文档中的分区或节 dl 定义列表 dt 定义列表中的项目 fieldset 定义一个框架集 form 创建HTML表单 h1 定义最大的标题 h2 定义副标题 h3 定义标题 h4 定义标题 h5 定义标题 h6 定义最小的标题 hr 创建一条水平线 legend 元素为fieldset元素定义标题 li 标签定义列表项目 noframes 为那些不支持框架的浏览器显示文本，于 frameset 元素内部 noscript 定义在脚本未被执行时的替代内容 ol 定义有序列表 ul 定义无序列表 p 标签定义段落 pre 定义预格式化的文本 table 标签定义HTML表格 tbody 标签表格主体（正文） td 表格中的标准单元格 tfoot 定义表格的页脚（脚注或表注） th 定义表头单元格 thead 标签定义表格的表头 tr 定义表格中的行","text":"块级元素列表 元素名 含义 address 定义地址 caption 定义表格标题 dd 定义列表中定义条目 div 定义文档中的分区或节 dl 定义列表 dt 定义列表中的项目 fieldset 定义一个框架集 form 创建HTML表单 h1 定义最大的标题 h2 定义副标题 h3 定义标题 h4 定义标题 h5 定义标题 h6 定义最小的标题 hr 创建一条水平线 legend 元素为fieldset元素定义标题 li 标签定义列表项目 noframes 为那些不支持框架的浏览器显示文本，于 frameset 元素内部 noscript 定义在脚本未被执行时的替代内容 ol 定义有序列表 ul 定义无序列表 p 标签定义段落 pre 定义预格式化的文本 table 标签定义HTML表格 tbody 标签表格主体（正文） td 表格中的标准单元格 tfoot 定义表格的页脚（脚注或表注） th 定义表头单元格 thead 标签定义表格的表头 tr 定义表格中的行 行内元素列表 元素名 含义 a 标签可定义锚 abbr 表示一个缩写形式 acronym 定义只取首字母缩写 b 字体加粗 bdo 可覆盖默认的文本方向 big 大号字体加粗 br 换行 cite 引用进行定义 code 定义计算机代码文本 dfn 定义一个定义项目 em 定义为强调的内容 i 斜体文本效果 img 向网页中嵌入一幅图像 input 输入框 kbd 定义键盘文本 label 签为input元素定义标注 q 定义短的引用 samp 定义样本文本 select 创建单选或多选菜单 small 呈现小号字体效果 span 组合文档中的行内元素 strong 语气更强的强调的内容 sub 定义下标文本 sup 定义上标文本 textarea 多行的文本输入控件 tt 打字机或者等宽的文本效果 var 定义变量 可变元素素列表–可变元素为根据上下文语境决定该元素为块元素或者内联元素 &lt;button&gt; 按钮&lt;del&gt; 定义文档中已被删除的文本&lt;iframe&gt; 创建包含另外一个文档的内联框架（即行内框架）&lt;ins&gt; 标签定义已经被插入文档中的文本&lt;map&gt; 客户端图像映射（即热区）&lt;object&gt; object对象&lt;script&gt; 客户端脚本 行内元素与块级函数的区别 行内元素会在一条直线上排列，都是同一行的，水平方向排列 块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行 块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素 行内元素与块级元素属性的不同，主要是盒模型属性上 行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效 行内元素转换为块级元素 display:block (字面意思表现形式设为块级)","categories":[{"name":"DOM","slug":"DOM","permalink":"https://blog.luckyw.cn/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://blog.luckyw.cn/tags/DOM/"}],"keywords":[{"name":"DOM","slug":"DOM","permalink":"https://blog.luckyw.cn/categories/DOM/"}]},{"title":"Js学习总结","slug":"js-learn-summary","date":"2015-11-26T16:00:00.000Z","updated":"2016-10-26T11:19:22.115Z","comments":true,"path":"2015/11/27/js-learn-summary/","link":"","permalink":"https://blog.luckyw.cn/2015/11/27/js-learn-summary/","excerpt":"js变量名 js严格区分大小写创建合法变量名应注意：不能以数字开头，后面可以是任意字符包括字母、数字或下划线，但不能是空格，且一定不能是js保留字 js数据类型 3种主要(基本)数据类型、2种复合(引用)数据类型和2种特殊数据类型,分别是 字符串(String)、数字(Number)、布尔(Boolean)对象(Object)、数组(Array)Null、Undefined null和undefined的区别 null表示尚未存在的对象undefined表示对象属性不存在或声明了变量但未赋值12345alert(typeof undefined); //&quot;undefined&quot;alert(typeof null); //&quot;object&quot;alert(null == undefined); //&quot;true&quot;alert(null === undefined); //&quot;false&quot;alert(typeof null == typeof undefined); //&quot;false&quot;","text":"js变量名 js严格区分大小写创建合法变量名应注意：不能以数字开头，后面可以是任意字符包括字母、数字或下划线，但不能是空格，且一定不能是js保留字 js数据类型 3种主要(基本)数据类型、2种复合(引用)数据类型和2种特殊数据类型,分别是 字符串(String)、数字(Number)、布尔(Boolean)对象(Object)、数组(Array)Null、Undefined null和undefined的区别 null表示尚未存在的对象undefined表示对象属性不存在或声明了变量但未赋值12345alert(typeof undefined); //&quot;undefined&quot;alert(typeof null); //&quot;object&quot;alert(null == undefined); //&quot;true&quot;alert(null === undefined); //&quot;false&quot;alert(typeof null == typeof undefined); //&quot;false&quot; 闭包 闭包是指有权访问另一函数作用域的变量的函数应用的场合主要是设计私有的方法和变量，避免全局变量的污染闭包有3个特性: 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 缺点: 常驻内存，会增大内存使用量，使用不当很容易造成内存泄露","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"12个非常实用的JavaScript小技巧","slug":"js-12-useful-tips","date":"2015-11-21T16:00:00.000Z","updated":"2016-10-26T11:18:26.754Z","comments":true,"path":"2015/11/22/js-12-useful-tips/","link":"","permalink":"https://blog.luckyw.cn/2015/11/22/js-12-useful-tips/","excerpt":"使用!!操作符转换布尔值 有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回true。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用!!variable做检测，只要变量的值为:0、null、” “、undefined或者NaN都将返回的是false，反之返回的是true，比如下面的示例：1234567891011function Account(cash) &#123; this.cash = cash; this.hasMoney = !!cash;&#125;var account = new Account(100.50);console.log(account.cash); // 100.50console.log(account.hasMoney); // truevar emptyAccount = new Account(0);console.log(emptyAccount.cash); // 0console.log(emptyAccount.hasMoney); // false 在这个示例中，只要account.cash的值大于0，那么account.hasMoney返回的值就是true。 使用+将字符串转换成数字 这个技巧非常有用，其非常简单，可以将字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：12345function toNumber(strNumber) &#123; return +strNumber;&#125;console.log(toNumber(&quot;1234&quot;)); // 1234console.log(toNumber(&quot;ACB&quot;)); // NaN 这个也适用于Date，在本例中，它将返回的是时间戳数字:1console.log(+new Date()) // 1461288164385","text":"使用!!操作符转换布尔值 有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回true。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用!!variable做检测，只要变量的值为:0、null、” “、undefined或者NaN都将返回的是false，反之返回的是true，比如下面的示例：1234567891011function Account(cash) &#123; this.cash = cash; this.hasMoney = !!cash;&#125;var account = new Account(100.50);console.log(account.cash); // 100.50console.log(account.hasMoney); // truevar emptyAccount = new Account(0);console.log(emptyAccount.cash); // 0console.log(emptyAccount.hasMoney); // false 在这个示例中，只要account.cash的值大于0，那么account.hasMoney返回的值就是true。 使用+将字符串转换成数字 这个技巧非常有用，其非常简单，可以将字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：12345function toNumber(strNumber) &#123; return +strNumber;&#125;console.log(toNumber(&quot;1234&quot;)); // 1234console.log(toNumber(&quot;ACB&quot;)); // NaN 这个也适用于Date，在本例中，它将返回的是时间戳数字:1console.log(+new Date()) // 1461288164385 并条件符 如果你有一段这样的代码：123if (conected) &#123; login();&#125; 你也可以将变量简写，并且使用&amp;&amp;和函数连接在一起，比如上面的示例，可以简写成这样：1conected &amp;&amp; login(); 如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：1user &amp;&amp; user.login(); 使用||运算符 在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用||操作符，并且将默认值当做第二个参数传入。如果第一个参数返回的值为false，那么第二个值将会认为是一个默认值，例如下面这个示例：1234567891011function User(name, age) &#123; this.name = name || &quot;Oliver Queen&quot;; this.age = age || 27;&#125;var user1 = new User();console.log(user1.name); // Oliver Queenconsole.log(user1.age); // 27var user2 = new User(&quot;Barry Allen&quot;, 25);console.log(user2.name); // Barry Allenconsole.log(user2.age); // 25 在循环中缓存array.length 这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：123for(var i = 0; i &lt; array.length; i++) &#123; console.log(array[i]);&#125; 如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：1234var len = array.length;for(var i = 0; i &lt; len; i++) &#123; console.log(array[i]);&#125; 你也可以写在这样：123for(var i = 0, len = array.length; i &lt; len; i++) &#123; console.log(array[i]);&#125; 检测对象中属性 当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定义一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用document.querySelector()来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：12345if (&apos;querySelector&apos; in document) &#123; document.querySelector(&quot;#id&quot;);&#125; else &#123; document.getElementById(&quot;id&quot;);&#125; 在这个示例中，如果document不存在querySelector函数，那么就会调用docuemnt.getElementById(&quot;id&quot;)。 获取数组中最后一个元素 Array.prototype.slice(begin,end)用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些人可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后几个元素。如：1234var array = [1,2,3,4,5,6];console.log(array.slice(-1)); // [6]console.log(array.slice(-2)); // [5,6]console.log(array.slice(-3)); // [4,5,6] 数组截断 这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：12345var array = [1,2,3,4,5,6];console.log(array.length); // 6array.length = 3;console.log(array.length); // 3console.log(array); // [1,2,3] 替换所有 String.replace()函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll()函数功能：123var string = &quot;john john&quot;;console.log(string.replace(/hn/, &quot;ana&quot;)); // &quot;joana john&quot;console.log(string.replace(/hn/g, &quot;ana&quot;)); // &quot;joana joana&quot; 合并数组 如果你要合并两个数组，一般情况之下你都会使用Array.concat()函数：123var array1 = [1,2,3];var array2 = [4,5,6];console.log(array1.concat(array2)); // [1,2,3,4,5,6]; 然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用Array.prototype.push.apply(arr1,arr2)来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将两个数组合并在一起，同时减少内存的使用:123var array1 = [1,2,3];var array2 = [4,5,6];console.log(Array.prototype.push.apply(array1, array2)); // [1,2,3,4,5,6]; 将NodeList转换成数组 如果你运行document.querySelectorAll(“p”)函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort()、reduce()、map()、filter()等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用[].slice.call(elements)来实现：123var elements = document.querySelectorAll(&quot;p&quot;); // NodeListvar arrayElements = [].slice.call(elements); // Now the NodeList is an arrayvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array 数组元素的洗牌 对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：12var list = [1,2,3];console.log(list.sort(function() &#123; return Math.random() - 0.5 &#125;)); // [2,1,3]","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"理解DOM中的事件流","slug":"dom-event-flow","date":"2015-11-14T16:00:00.000Z","updated":"2016-11-20T10:45:58.783Z","comments":true,"path":"2015/11/15/dom-event-flow/","link":"","permalink":"https://blog.luckyw.cn/2015/11/15/dom-event-flow/","excerpt":"当浏览器发展到第四代时（IE4和Netscape Communicator 4）,浏览器团队遇到一个很有意思的问题:页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的，如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念:IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流 事件冒泡 IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。看下面的例子123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;事件流&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrapDiv&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 点击按钮，那么这个click事件会按照这样传播： &lt;input&gt; &lt;div&gt; &lt;body&gt; &lt;html&gt; document","text":"当浏览器发展到第四代时（IE4和Netscape Communicator 4）,浏览器团队遇到一个很有意思的问题:页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的，如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念:IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流 事件冒泡 IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。看下面的例子123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;事件流&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrapDiv&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 点击按钮，那么这个click事件会按照这样传播： &lt;input&gt; &lt;div&gt; &lt;body&gt; &lt;html&gt; document 所有现代浏览器都支持事件冒泡，但在具体实现上有一些差别。IE5.5及更早版本中的事件冒泡会跳过&lt;html&gt;元素（从&lt;body&gt;直接跳到document）。IE9、Firefox、Chrome和Safari则将事件一直冒泡到window对象。 事件捕获 Netscape团队提出的另一种事件流叫做事件捕获。事件捕获的思想是不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件针对上面同样的例子，点击按钮，那么此时click事件会按照这样传播： document &lt;html&gt; &lt;body&gt; &lt;div&gt; &lt;input&gt; 虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获 DOM事件流 DOM2级事件规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。以前面的例子，则会按下图顺序触发事件。在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到div后就定停止了。下一个阶段是处于目标阶段，于是事件在input上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document多数支持DOM事件流的浏览器都实现了一种特定的行为；即使DOM2级事件规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上操作事件,看如下例子:","categories":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/tags/WEB/"}],"keywords":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}]},{"title":"雅虎军规","slug":"yahoo-web-rule","date":"2015-11-09T16:00:00.000Z","updated":"2016-10-26T11:25:52.925Z","comments":true,"path":"2015/11/10/yahoo-web-rule/","link":"","permalink":"https://blog.luckyw.cn/2015/11/10/yahoo-web-rule/","excerpt":"雅虎给出了优化网站加载速度的34条法则（包括Yslow规则22条） Minimize HTTP Requests 减少HTTP请求 图片、css、script、flash等等这些都会增加http请求数，减少这些元素的数量就能减少响应时间。把多个JS、CSS在可能的情况下写进一个文件，页面里直接写入图片也是不好的做法，应该写进CSS里，利用CSS sprites将小图拼合后利用background来定位。 Use a Content Delivery Network 利用CDN技术 使用cdn技术，尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定 Add an Expires or a Cache-Control Header 设置头文件过期或者静态缓存 浏览器会用缓存来减少http请求数来加快页面加载的时间，如果页面头部加一个很长的过期时间，浏览器就会一直缓存页面里的元素。不过这样如果页面里的东西变动的话就要改名字了，否则用户端不会主动刷新 Gzip Components Gzip压缩 Gzip格式是一种很普遍的压缩技术，几乎所有的浏览器都有解压Gzip格式的能力，而且它可以压缩的比例非常大，一般压缩率为85% Put Stylesheets at the Top 把CSS放顶部 让浏览者能尽早的看到网站的完整样式","text":"雅虎给出了优化网站加载速度的34条法则（包括Yslow规则22条） Minimize HTTP Requests 减少HTTP请求 图片、css、script、flash等等这些都会增加http请求数，减少这些元素的数量就能减少响应时间。把多个JS、CSS在可能的情况下写进一个文件，页面里直接写入图片也是不好的做法，应该写进CSS里，利用CSS sprites将小图拼合后利用background来定位。 Use a Content Delivery Network 利用CDN技术 使用cdn技术，尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定 Add an Expires or a Cache-Control Header 设置头文件过期或者静态缓存 浏览器会用缓存来减少http请求数来加快页面加载的时间，如果页面头部加一个很长的过期时间，浏览器就会一直缓存页面里的元素。不过这样如果页面里的东西变动的话就要改名字了，否则用户端不会主动刷新 Gzip Components Gzip压缩 Gzip格式是一种很普遍的压缩技术，几乎所有的浏览器都有解压Gzip格式的能力，而且它可以压缩的比例非常大，一般压缩率为85% Put Stylesheets at the Top 把CSS放顶部 让浏览者能尽早的看到网站的完整样式 Put Scripts at the Bottom 把JS放底部 网站呈现完毕后再进行功能设置，当然这些JS要在你的加载过程中不影响内容表现 Avoid CSS Expressions 避免CSS Expressions CSS表达式很可怕，这个只被IE支持的东西执行时候的运算量非常大，你移动一下鼠标它都要进行重计算的，但有时候为了做浏览器的兼容必须要用到这个 Make JavaScript and CSS External 将JS和CSS外链 前面讲到了缓存这个事情，一些较为公用的JS和CSS，我们可以使用外链的形式，如果我的浏览者在浏览别的使用了这个外链文件的网站时已经下载并缓存了这个文件，那么他在浏览我的网站的时候就不需要再进行额外下载了 Reduce DNS Lookups 减少DNS查找 减少网站从外部调用资源 Minify JavaScript and CSS 减小JS和CSS的体积 写JS和CSS都是有技巧的，用最少的代码实现同样的功能，减少空白，增强逻辑性，用缩写方式等等，当然也有不少工具也能够帮你实现这一点 Avoid Redirects 避免重定向 再写入链接时，虽然http://www.example.com和http://www.example.com/仅有一个最后的/之差，但是结果是不同的，服务器需要花时间把前者重定向为后者然后进行跳转，这点需要注意 Remove Duplicate Scripts 删除重复脚本 重复调用的代码浏览器并不会识别忽略，而是会再次运算一遍，这当然是大大的浪费 Configure ETags 配置ETags Make Ajax Cacheable 缓存Ajax Ajax是实时响应的，在浏览器接收到新的数据前，旧的数据被缓存，这样能够更好的提高效率 Flush the Buffer Early 尽早的释放缓冲 当用户进行页面请求时，服务器端需要花费200~500毫秒时间来拼合HTML，将写在head与body之间，释放缓冲，这样可以将文件头先发送出去，然后再发送文件内容，提高效率 Use GET for AJAX Requests 用GET方式进行AJAX请求 Get方法和服务器只有一次交互（发送数据），而Post要两次（发送头部再发送数据）。 Post-load Components 延迟加载组件 最先加载必须的组件，进行页面初始化，然后再加载其他 Preload components 预加载组件 提前加载以后可能用到的东西，和延迟加载并不冲突，它的目的是为后续请求提供更快的响应 Reduce the Number of DOM Elements 减少DOM元素数量 复杂的页面结构意味着更长的下载及响应时间，更合理更高效的使用标签来架构页面，是好的前端的必备条件 Split Components Across Domains 跨域分离组件 页面组件多个来源可以增大你的平行下载量，但注意不要过多，超过2-4个域名会引起上面说到的DNS查找浪费 Minimize the Number of iframes 减少iframe数量 需要更有效的利用ifames优点：有利于下载缓慢的广告等第三方内容，安全沙箱，并行下载脚本缺点：即使为空也会有较大资源消耗，会阻止页面的onload，非语义 No 404s 不要出现404页面 站点本身里（非搜索结果）出现404页面，无意义的404页面会影响用户体验并且会消耗服务器资源 Reduce Cookie Size 减小Cookie Cookie在服务器及浏览器之间的通过文件头进行交换，尽可能减小Cookie体积，设置合理的过期时间，能够很好的提高效率 Use Cookie-free Domains for Components 对组件使用无Cookie的域名 对静态组件的Cookie读取是一种浪费，使用另一个无Cookie的域名来存放你的静态组件式一个好方法，或者也可以在Cookie中只存放带www的域名。 Minimize DOM Access 减少DOM的访问次数 JS访问DOM是很慢的，尽量不要用JS来设置页面布局 Develop Smart Event Handlers 开发灵活的事件处理句柄 DOM树上过多的元素被加入事件句柄的话，反应效率肯定会低 Choose over @import 使用而非@import 在IE中使用@import就和在页面底部用&lt;link&gt;一样 Avoid Filters 避免过滤器的使用 如果需要Alpha透明，不要使用AlphaImageLoader，它效率低下而且只对IE6及以下的版本适用，用PNG8图片。如果你非要使用，加上_filter以免影响IE7+用户 Optimize Images 优化图片 将你的GIF转为PNG8会是个减小体积的好办法，另外有很多方法处理你的JPG及PNG图片以达到优化效果 Optimize CSS Sprites 优化CSS Sprites 在CSS Sprites中竖直并尽量紧凑的排列图片，尽量将颜色相似的图片排在一起，会减小图片本身的大小及提高页面图片显示速度 Don’t Scale Images in HTML 不要在HTML中缩放图片 图片要用多大的就用多大的，1000X1000的图片被width=”100″ height=”100″以后，本身的KB数是不会减少的。 Make favicon. ico Small and Cacheable 缩小favicon. ico的大小并缓存它 站点的浏览器ICO应该不是经常换吧，那就长时间的缓存它，并且最好控制在1K以下 Keep Components under 25K 保证组件在25K以下 iPhone不能缓存25K以上的组件，并且这还是要在被压缩前 Pack Components into a Multipart Document 将组件打包进一个多部分的文档中 就好像在邮件中加入附件一样，一个HTTP请求就够了，但是这一技术需要确保你的代理支持，iPhone就不支持","categories":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/tags/WEB/"}],"keywords":[{"name":"WEB","slug":"WEB","permalink":"https://blog.luckyw.cn/categories/WEB/"}]},{"title":"JS创建对象的几种方式","slug":"js-creat-object","date":"2015-11-04T16:00:00.000Z","updated":"2016-10-26T11:19:04.358Z","comments":true,"path":"2015/11/05/js-creat-object/","link":"","permalink":"https://blog.luckyw.cn/2015/11/05/js-creat-object/","excerpt":"第一种模式：工厂方式 12345678910111213var say=function()&#123; return &quot;XiaoMing&quot;;&#125;;function Parent()&#123; var Child = new Object(); Child.name=&quot;小明&quot;; Child.age=&quot;30&quot;; Child.say=say; return Child;&#125;;var x = Parent();alert(x.name);alert(x.say()); 说明：1.在函数中定义对象,并定义对象的各种属性，虽然属性可以为方法，但是建议将属性为方法的属性定义到函数之外，这样可以避免重复创建该方法2.引用该对象的时候，这里使用的是var x = Parent()而不是var x = new Parent()。因为后者会可能出现很多问题（前者也成为工厂经典方式,后者称之为混合工厂方式），不推荐使用new的方式使用该对象3.在函数的最后返回该对象4.不推荐使用这种方式创建对象，但应该了解","text":"第一种模式：工厂方式 12345678910111213var say=function()&#123; return &quot;XiaoMing&quot;;&#125;;function Parent()&#123; var Child = new Object(); Child.name=&quot;小明&quot;; Child.age=&quot;30&quot;; Child.say=say; return Child;&#125;;var x = Parent();alert(x.name);alert(x.say()); 说明：1.在函数中定义对象,并定义对象的各种属性，虽然属性可以为方法，但是建议将属性为方法的属性定义到函数之外，这样可以避免重复创建该方法2.引用该对象的时候，这里使用的是var x = Parent()而不是var x = new Parent()。因为后者会可能出现很多问题（前者也成为工厂经典方式,后者称之为混合工厂方式），不推荐使用new的方式使用该对象3.在函数的最后返回该对象4.不推荐使用这种方式创建对象，但应该了解 第二种模式：构造函数方式 1234567891011var say=function()&#123; return &quot;XiaoMing&quot;;&#125;;function Parent()&#123; this.name=&quot;小明&quot;; this.age=&quot;30&quot;; this.say=say;&#125;;var x =new Parent();alert(x.name);alert(x.say()); 说明：1.与工厂方式相比，使用构造函数方式创建对象，无需在函数内部重新创建对象，而使用this指代，并且函数无需return2.同工厂模式一样，虽然属性的值可以为方法，仍建议将该方法定义在函数之外3.同样的，不推荐使用这种方式创建对象，但仍需要了解 第三种模式：原型模式 123456789101112var say=function()&#123; return &quot;XiaoMing&quot;;&#125;;function Parent()&#123;&#125;;Parent.prototype.name=&quot;小明&quot;;Parent.prototype.age=&quot;30&quot;;Parent.prototype.say=say;var x = new Parent();alert(x.name);alert(x.say()); 说明：1.函数中不对属性进行定义2.利用prototype属性对属性进行定义3.同样的，不推荐使用这样方式创建对象 第四种模式：混合的构造函数，原型方式（推荐） 12345678910function Parent()&#123; this.name=&quot;小明&quot;; this.age=30;&#125;;Parent.prototype.say=function()&#123; return this.name;&#125;;var x = new Parent();alert(x.say()); 说明：1.该模式是指混合搭配使用构造函数方式和原型方式2.将所有属性不是方法的属性定义在函数中（构造函数方式）将所有属性值为方法的属性利用prototype在函数之外定义（原型方式）3.推荐使用这样方式创建对象 第五种模式：动态原型方式 123456789101112function Parent()&#123; this.name=&quot;小明&quot;; this.age=30; if(typeof Parent._say==&quot;undefined&quot;)&#123; Parent.prototype.say=function()&#123; return this.name; &#125; Parent._say=true; &#125;&#125;;var x = new Parent();alert(x.say()); 说明：1.动态原型方式可以理解为混合构造函数，原型方式的一个特例2.该模式中,属性为方法的属性直接在函数中进行了定义，但是因为123if(typeof Parent._say==&quot;undefined&quot;)&#123; Parent._say=true;&#125; 从而保证创建该对象的实例时，属性的方法不会被重复创建3.推荐使用这种模式","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"几种有效的清除浮动的方法","slug":"css-clear-float","date":"2015-10-30T16:00:00.000Z","updated":"2016-10-26T11:14:59.658Z","comments":true,"path":"2015/10/31/css-clear-float/","link":"","permalink":"https://blog.luckyw.cn/2015/10/31/css-clear-float/","excerpt":"浮动是CSS布局中最常用的属性，然而浮动是脱离文档流的，如果不清除浮动的话，会对周围的元素产生影响。也正是浮动脱离文档流这一特性，使浮动成为CSS布局的难点之一浮动框可以左右移动，直到它的外边缘碰到包含框或另一浮动框的边缘。当元素浮动时，它将不再处于普通文档流中，相当于浮在文档之上，不占据空间，但是会缩短行框，产生文字环绕的效果清除浮动有好一些方法，但兼容各种浏览器的方法却不多，下面我就介绍几个比较有效的兼容的方法:我们以下面的HTML代码为例来说明这几种方法的用法：1234&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;sidebar&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt; 对父级设置CSS高度 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题优点：简单、代码少、容易掌握缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题建议：不推荐使用，只建议高度固定的布局时使用对应CSS代码：123456789101112131415161718#box&#123; width:500px; margin:10px auto; background:#ccc; height:500px;/*解决代码*/&#125;#sidebar&#123; width:190px; height:500px; float:left; background:#f00;&#125;#main&#123; width:300px; height:500px; float:right; background:#00f;&#125;","text":"浮动是CSS布局中最常用的属性，然而浮动是脱离文档流的，如果不清除浮动的话，会对周围的元素产生影响。也正是浮动脱离文档流这一特性，使浮动成为CSS布局的难点之一浮动框可以左右移动，直到它的外边缘碰到包含框或另一浮动框的边缘。当元素浮动时，它将不再处于普通文档流中，相当于浮在文档之上，不占据空间，但是会缩短行框，产生文字环绕的效果清除浮动有好一些方法，但兼容各种浏览器的方法却不多，下面我就介绍几个比较有效的兼容的方法:我们以下面的HTML代码为例来说明这几种方法的用法：1234&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;sidebar&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt; 对父级设置CSS高度 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题优点：简单、代码少、容易掌握缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题建议：不推荐使用，只建议高度固定的布局时使用对应CSS代码：123456789101112131415161718#box&#123; width:500px; margin:10px auto; background:#ccc; height:500px;/*解决代码*/&#125;#sidebar&#123; width:190px; height:500px; float:left; background:#f00;&#125;#main&#123; width:300px; height:500px; float:right; background:#00f;&#125; 额外标签法 这种方法是在浮动元素的最后加一个标签，用这个标签清除浮动，一般是加&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，当然也可以是其他标签，比如p、br等。本例加在&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;的后面。对应的CSS代码：123456789101112131415161718192021#box&#123; width:500px; margin:10px auto; background:#ccc;&#125;#sidebar&#123; width:190px; height:500px; float:left; background:#f00;&#125;#main&#123; width:300px; height:500px; float:right; background:#00f;&#125;/*清除浮动代码*/.clear&#123; clear:both;&#125; 原理：添加一个空div，利用css的clear:both清除浮动，让父级div能自动获取到高度优点：简单、代码少、浏览器支持好、不容易出现怪问题缺点：不少初学者不理解原理,如果页面浮动布局多，就要增加很多空div，让人感觉很不好建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 父级div定义伪类:after和zoom 1234567891011121314151617181920212223242526#box&#123; width:500px; margin:10px auto; background:#ccc; zoom:1&#125;#sidebar&#123; width:190px; height:500px; float:left; background:#f00;&#125;#main&#123; width:300px; height:500px; float:right; background:#00f;&#125;/*解决代码*/#box:after&#123; display:block; clear:both; content:&quot;&quot;; visibility:hidden; height:0&#125; 原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE专有属性)可解决ie6、ie7浮动问题优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持建议：推荐使用，建议定义公共类，以减少CSS代码 父级div定义overflow:hidden 123456789101112131415161718#box&#123; width:500px; margin:10px auto; background:#ccc; overflow:hidden;/*解决代码*/&#125;#sidebar&#123; width:190px; height:500px; float:left; background:#f00;&#125;#main&#123; width:300px; height:500px; float:right; background:#00f;&#125; 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：不能和position配合使用，因为超出的尺寸的会被隐藏建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用 父级div定义overflow:auto 123456789101112131415161718#box&#123; width:500px; margin:10 auto; background:#ccc; overflow:auto;/*解决代码*/&#125;#sidebar&#123; width:190px; height:500px; float:left; background:#f00;&#125;#main&#123; width:300px; height:500px; float:right; background:#00f;&#125; 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：内部宽高超过父级div时，会出现滚动条建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"两种盒子模型","slug":"css-box-model","date":"2015-10-24T16:00:00.000Z","updated":"2016-11-20T09:33:57.138Z","comments":true,"path":"2015/10/25/css-box-model/","link":"","permalink":"https://blog.luckyw.cn/2015/10/25/css-box-model/","excerpt":"盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是IE盒子模型和标准W3C盒子模型，他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型：","text":"盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是IE盒子模型和标准W3C盒子模型，他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型：从上图可以看到标准盒子模型的范围包括margin、border、padding、content，并且content部分不包含其他部分从上图可以看到IE盒子模型的范围也包括margin、border、padding、content，和标准W3C盒子模型不同的是：IE盒子模型的content部分包含了border和pading。例：一个盒子的margin为20px，border为1px，padding为10px，content的宽为200px、高为50px，假如用标准W3C盒子模型解释，那么这个盒子需要占据的位置为：宽20*2+1*2+10*2+200=262px、高20*2+1*2+10*2+50=112px盒子的实际大小为：宽1*2+10*2+200=222px、高1*2+10*2+50=72px假如用IE盒子模型，那么这个盒子需要占据的位置为：宽20*2+200=240px、高20*2+50=90px盒子的实际大小为：宽200px、高 50px那应该选择哪中盒子模型呢？当然是“标准W3C盒子模型”了。怎么样才算是选择了“标准W3C盒子模型”呢？很简单，就是在网页的顶部加上doctype声明。假如不加doctype声明，那么各个浏览器会根据自己的行为去理解网页，即IE浏览器会采用IE盒子模型去解释你的盒子，而FF会采用标准W3C盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。反之，假如加上了doctype声明，那么所有浏览器都会采用标准W3C盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"Js setTimeout小问题","slug":"js-settimeout","date":"2015-10-19T16:00:00.000Z","updated":"2016-10-26T11:19:53.167Z","comments":true,"path":"2015/10/20/js-settimeout/","link":"","permalink":"https://blog.luckyw.cn/2015/10/20/js-settimeout/","excerpt":"做项目的时候发现了一个setTimeout问题，比如以下代码:12345for(var i=0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000*i)&#125; 本意我是想让这个for循环每隔1秒延时后打印一次i的值，结果是每隔一秒打印了10，打印了10个10，对此我表示不求甚解","text":"做项目的时候发现了一个setTimeout问题，比如以下代码:12345for(var i=0;i&lt;10;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000*i)&#125; 本意我是想让这个for循环每隔1秒延时后打印一次i的值，结果是每隔一秒打印了10，打印了10个10，对此我表示不求甚解 产生原因 因为setTimeout是异步执行的，所以整个for循环其实是设置了10个定时器去打印i的值，而此时i的值早已经变成了10，可能有人会问为什么不是9，那是因为10次循环之后i++了变成了10，所以说控制台打印10个10,那么如何才能让控制台每隔一秒打印i了 解决办法 方法一 把计时器放到一个匿名函数里面，把i当参数传进去，这样计时器里面的i不会受到全局变量i的影响了，代码如下:1234567for (var i = 0; i &lt; 10; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000 * i) &#125;)(i)&#125; 方法二 结合使用ES6，使用let把i变成一个局部变量，代码如下:12345for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000 * i)&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"学习CSS布局","slug":"css-layout","date":"2015-10-14T16:00:00.000Z","updated":"2016-11-20T10:44:31.286Z","comments":true,"path":"2015/10/15/css-layout/","link":"","permalink":"https://blog.luckyw.cn/2015/10/15/css-layout/","excerpt":"display属性 每个元素都有默认的display属性，一般是block或者inlineblock表示块级元素，而inline表示行内元素block元素（如div、table、p、form等）会新开始一行并尽可能撑满容器。而inline元素（如span、a等）即行内元素不会打破包裹它的容器的布局另一个常用的display值为none，display:none通常是被JavaScript用来在不删除元素的情况下隐藏该元素。其他的display值还有list-item和table等,你可以随时随地人工改变一个元素的display值。常见的是:设置li元素为display:inline制作水平菜单。 marigin:auto 如何使一个元素居中，并且不用担心小屏幕会显示出滚动条：(max-width 支持IE7+)1234#main&#123; max-width:600px; margin:0 auto;&#125; 盒模型 盒模型的宽度高度我们知道要通过计算（真正的宽度=width+2padding+2border）我们使用box-sizing来改进它，当设置一个元素为box-sizing:border-box时，此元素的内边距和边框不会增加该元素的宽度。支持IE8+，如果要在所有浏览器中使用该属性，则可以利用下面的代码：12345*&#123; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box;&#125;","text":"display属性 每个元素都有默认的display属性，一般是block或者inlineblock表示块级元素，而inline表示行内元素block元素（如div、table、p、form等）会新开始一行并尽可能撑满容器。而inline元素（如span、a等）即行内元素不会打破包裹它的容器的布局另一个常用的display值为none，display:none通常是被JavaScript用来在不删除元素的情况下隐藏该元素。其他的display值还有list-item和table等,你可以随时随地人工改变一个元素的display值。常见的是:设置li元素为display:inline制作水平菜单。 marigin:auto 如何使一个元素居中，并且不用担心小屏幕会显示出滚动条：(max-width 支持IE7+)1234#main&#123; max-width:600px; margin:0 auto;&#125; 盒模型 盒模型的宽度高度我们知道要通过计算（真正的宽度=width+2padding+2border）我们使用box-sizing来改进它，当设置一个元素为box-sizing:border-box时，此元素的内边距和边框不会增加该元素的宽度。支持IE8+，如果要在所有浏览器中使用该属性，则可以利用下面的代码：12345*&#123; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box;&#125; position position的值可以为static、absolute、relative、fixed static是默认值，表示没有被定位 relative相对定位，相对于它在正常文档流中，通过top、right、bottom、left作用值产生偏移。而其他元素不会调整位置来弥补它偏离后剩下的间隙 fixed固定定位，相对于浏览器窗口，意味着即使页面滚动，它还是会停留在相同的位置 absolute绝对定位，相对于最近的被定位的祖先元素产生的偏移，如果没有，它是相对文档的body元素进行偏移 float 最开始产生float的作用就是使文字环绕图片，其本质就是包裹和破坏，它脱离了正常的文档流，可能会导致溢出，所以要clearfix hack（清除浮动） 媒体查询 针对响应式设计，，让网站针对不同浏览器和设备相应1234567891011121314@media screen and (min-width:600px) &#123;nav &#123; float: left; width: 25%;&#125;section &#123; margin-left: 25%; &#125;&#125;@media screen and (max-width:599px) &#123;nav li &#123; display: inline; &#125;&#125; inline-block 使用行内联，IE6和IE7支持看这里使用inline-box要注意以下： vertical-align属性会影响到inline-block元素，你可能会把它的值设置为top 需要设置每一列的宽度 如果html源代码中元素之间有空格，那么列与列之间会产生空隙 column 123456789.three-column &#123; padding: 1em; -moz-column-count: 3; -moz-column-gap: 1em; -webkit-column-count: 3; -webkit-column-gap: 1em; column-count: 3; column-gap: 1em;&#125; CSS3 columns是很新的标准，所以你需要使用前缀，并且它不被IE9及以下和Opera Mini支持 flexbox flexbox布局模式被用来重新定义CSS中的布局方式 其他框架 例如bootstrap的栅格布局等等","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"CSS中隐藏元素的几种方法","slug":"css-hide-element","date":"2015-10-07T16:00:00.000Z","updated":"2016-10-31T08:16:56.838Z","comments":true,"path":"2015/10/08/css-hide-element/","link":"","permalink":"https://blog.luckyw.cn/2015/10/08/css-hide-element/","excerpt":"几种方法的简单介绍 display:none 最常用的隐藏元素的方法123.hidden&#123; display:none&#125; 将元素设置为display:none后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘 visibility:hidden 此方法也是一种常用的隐藏元素的方法，和display:none的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排123.hidden&#123; visibility:hidden&#125; visibility:hidden适用于那些元素隐藏后不希望页面布局会发生变化的场景 opacity:0 opacity属性表示元素的透明度，而将元素的透明度设置为0后，在我们眼中，元素也就是隐藏起来的，这也算是一种隐藏元素的方法123.transparent &#123; opacity:0;&#125; 这种方法和visibility:hidden的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中","text":"几种方法的简单介绍 display:none 最常用的隐藏元素的方法123.hidden&#123; display:none&#125; 将元素设置为display:none后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘 visibility:hidden 此方法也是一种常用的隐藏元素的方法，和display:none的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排123.hidden&#123; visibility:hidden&#125; visibility:hidden适用于那些元素隐藏后不希望页面布局会发生变化的场景 opacity:0 opacity属性表示元素的透明度，而将元素的透明度设置为0后，在我们眼中，元素也就是隐藏起来的，这也算是一种隐藏元素的方法123.transparent &#123; opacity:0;&#125; 这种方法和visibility:hidden的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中 设置height，width等盒模型属性为0 一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其overflow:hidden来隐藏其子元素12345678.hiddenBox &#123; margin:0; border:0; padding:0; height:0; width:0; overflow:hidden;&#125; 这种方式既不实用，也存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的overflow:hidden后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果 元素隐藏后的事件响应 如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; div &#123; width: 100px; height: 100px; background: red; margin: 15px; padding: 10px; border: 5px solid green; display: inline-block; overflow: hidden; &#125; .none &#123; display: none; &#125; .hidden &#123; visibility: hidden; &#125; .opacity0 &#123; opacity: 0; &#125; .height0 &#123; height: 0; &#125;&lt;/style&gt;&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;.none&quot;).on(&quot;click&quot;, function () &#123; console.log(&quot;none clicked&quot;); &#125;) $(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123; console.log(&quot;hidden clicked&quot;); &#125;) $(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123; console.log(&quot;opacity0 clicked&quot;); &#125;) $(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123; console.log(&quot;height0 clicked&quot;); &#125;)&lt;/script&gt; 这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论： display:none:元素彻底消失，很显然不会触发其点击事件 visibility:hidden:无法触发其点击事件，有一种说法是display:none是看不见摸不着，而visibility:hidden是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间 opacity:0:可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件 height:0:将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件 但是这些结论真的准确吗？我们在上面的代码中添加这样一句代码：$(&quot;.none&quot;).click()结果发现，触发了click事件，也就是通过JS可以触发被设置为display:none的元素的事件。所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素 CSS3 transition对这几种方法的影响 CSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：12345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; div &#123; width: 100px; height: 100px; background: red; margin: 15px; padding: 10px; border: 5px solid green; display: inline-block; overflow: hidden; transition: all linear 2s; &#125;&lt;/style&gt;&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(&quot;.none&quot;).on(&quot;click&quot;, function () &#123; console.log(&quot;none clicked&quot;); $(this).css(&quot;display&quot;, &quot;none&quot;);&#125;)$(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123; console.log(&quot;hidden clicked&quot;); $(this).css(&quot;visibility&quot;, &quot;hidden&quot;);&#125;)$(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123; console.log(&quot;opacity0 clicked&quot;); $(this).css(&quot;opacity&quot;, 0);&#125;)$(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123; console.log(&quot;height0 clicked&quot;); $(this).css(&#123; &quot;height&quot;: 0, &#125;);&#125;)&lt;/script&gt; 经过测试，可以看到： display:none:完全不受transition属性的影响，元素立即消失 visibility：hidden:元素消失的时间跟transition属性设置的时间一样，但是没有动画效果 opacity和height等属性能够进行正常的动画效果 假设我们要通过CSS3来做一个淡出的动画效果，应该如下：12.fadeOut &#123; visibility: visible; opacity: 1; transition: all linear 2s; &#125;.fadeOut:hover &#123; visibility: hidden; opacity: 0; &#125; 应该同时设置元素的visibility和opacity属性 总结说明 本文总结说明了“隐藏”元素的几种方式，其中最常用的还是display:none和visibility:hidden。其他的方式只作了解即可，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景","categories":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"https://blog.luckyw.cn/categories/CSS/"}]},{"title":"JavaScript prototype 使用介绍","slug":"prototype","date":"2015-09-26T16:00:00.000Z","updated":"2016-11-20T11:59:31.686Z","comments":true,"path":"2015/09/27/prototype/","link":"","permalink":"https://blog.luckyw.cn/2015/09/27/prototype/","excerpt":"每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用（使用new操作符调用）的时候，新创建的对象会从原型对象上继承属性和方法。 私有变量、函数 在具体说prototype之前说几个相关的知识点，可以更好的理解prototype的设计意图。JavaScript的函数作用域，在函数内定义的变量和函数如果不对外提供接口，那么外部将无法访问到，也就是变为私有变量和私有函数12345function Obj()&#123; var a=0; //私有变量 var fn=function()&#123; //私有函数 &#125;&#125; 这样在函数对象Obj外部无法访问变量a和函数fn，它们就变成私有的，只能在Obj内部使用，即使是函数Obj的实例仍然无法访问这些变量和函数123var o=new Obj();console.log(o.a); //undefinedconsole.log(o.fn); //undefined","text":"每个函数都有一个prototype属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用（使用new操作符调用）的时候，新创建的对象会从原型对象上继承属性和方法。 私有变量、函数 在具体说prototype之前说几个相关的知识点，可以更好的理解prototype的设计意图。JavaScript的函数作用域，在函数内定义的变量和函数如果不对外提供接口，那么外部将无法访问到，也就是变为私有变量和私有函数12345function Obj()&#123; var a=0; //私有变量 var fn=function()&#123; //私有函数 &#125;&#125; 这样在函数对象Obj外部无法访问变量a和函数fn，它们就变成私有的，只能在Obj内部使用，即使是函数Obj的实例仍然无法访问这些变量和函数123var o=new Obj();console.log(o.a); //undefinedconsole.log(o.fn); //undefined 静态变量、函数 当定义一个函数后通过.为其添加的属性和方法，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数，用过Java、C#的同学很好理解静态的含义12345678910function Obj()&#123;&#125;Obj.a=0; //静态变量Obj.fn=function()&#123; //静态函数&#125;console.log(Obj.a); //0console.log(typeof Obj.fn); //functionvar o=new Obj();console.log(o.a); //undefinedconsole.log(typeof o.fn); //undefined 实例变量、函数 在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，JavaScript也能做到这样12345678910function Obj()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例方法 &#125;&#125;console.log(typeof Obj.a); //undefinedconsole.log(typeof Obj.fn); //undefinedvar o=new Obj();console.log(typeof o.a); //objectconsole.log(typeof o.fn); //function 这样可以达到上述目的，然而12345678910111213function Obj()&#123; this.a=[]; //实例变量 this.fn=function()&#123; //实例方法 &#125;&#125;var o1=new Obj();o1.a.push(1);o1.fn=&#123;&#125;;console.log(o1.a); //[1]console.log(typeof o1.fn); //objectvar o2=new Obj();console.log(o2.a); //[]console.log(typeof o2.fn); //function 上面的代码运行结果完全符合预期，但同时也说明一个问题，在o1中修改了a和fn，而在o2中没有改变，由于数组和函数都是对象，是引用类型，这就说明o1中的属性和方法与o2中的属性与方法虽然同名但却不是一个引用，而是对Obj对象定义的属性和方法的一个复制。这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢，prototype应运而生。 prototype 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，默认情况下prototype属性会默认获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针，有些绕了啊，写代码、上图！12function Person()&#123;&#125; 根据上图可以看出Person对象会自动获得prototype属性，而prototype也是一个对象，会自动获得一个constructor属性，该属性正是指向Person对象。当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（很多浏览器这个指针名字为__proto__）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间12345678function Person(name)&#123; this.name=name;&#125;Person.prototype.printName=function()&#123; alert(this.name);&#125;var person1=new Person(&apos;Byron&apos;);var person2=new Person(&apos;Frank&apos;); Person的实例person1中包含了name属性，同时自动生成一个__proto__属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法，大概就是这个样子的写段程序测试一下看看prototype内属性、方法是能够共享123456789101112function Person(name)&#123; this.name=name;&#125;Person.prototype.share=[];Person.prototype.printName=function()&#123; alert(this.name);&#125;var person1=new Person(&apos;Byron&apos;);var person2=new Person(&apos;Frank&apos;);person1.share.push(1);person2.share.push(2);console.log(person2.share); //[1,2] 果不其然！实际上当代码读取某个对象的某个属性的时候，都会执行一遍搜索，目标是具有给定名字的属性，搜索首先从对象实例开始，如果在实例中找到该属性则返回，如果没有则查找prototype，如果还是没有找到则继续递归prototype的prototype对象，直到找到为止，如果递归到object仍然没有则返回错误。同样道理如果在实例中定义如prototype同名的属性或函数，则会覆盖prototype的属性或函数1234567function Person(name)&#123; this.name=name;&#125;Person.prototype.share=[];var person=new Person(&apos;Byron&apos;);person.share=0;console.log(person.share); //0而不是prototype中的[] 构造简单对象当然prototype不是专门为解决上面问题而定义的，但是却解决了上面问题。了解了这些知识就可以构建一个科学些的、复用率高的对象，如果希望实例对象的属性或函数则定义到prototype中，如果希望每个实例单独拥有的属性或方法则定义到this中，可以通过构造函数传递实例化参数。1234567function Person(name)&#123; this.name=name;&#125;Person.prototype.share=[];Person.prototype.printName=function()&#123; alert(this.name);&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://blog.luckyw.cn/categories/JS/"}]},{"title":"JSON.parse和eval的区别","slug":"parse-eval","date":"2015-09-19T16:00:00.000Z","updated":"2016-10-26T11:21:38.493Z","comments":true,"path":"2015/09/20/parse-eval/","link":"","permalink":"https://blog.luckyw.cn/2015/09/20/parse-eval/","excerpt":"JSON JSON是一种轻量级的数据格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是javascript原生数据格式，这意味着在javascript中处理JSON数据时效率非常高基本格式：1var data=&#123;&quot;data1&quot;:&quot;Hello,&quot;,&quot;data2&quot;:&quot;world!&quot;&#125; 调用方法：1console.log(data.data1 + data.data2) 将json数据存入数组1var data=[&#123;&quot;name&quot;:&quot;LiLei&quot;,&quot;age&quot;:19,&quot;sex&quot;:&quot;male&quot;&#125;,&#123;&quot;name&quot;:&quot;HanMei&quot;,&quot;age&quot;:18,&quot;sex&quot;:&quot;famale&quot;&#125;]","text":"JSON JSON是一种轻量级的数据格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是javascript原生数据格式，这意味着在javascript中处理JSON数据时效率非常高基本格式：1var data=&#123;&quot;data1&quot;:&quot;Hello,&quot;,&quot;data2&quot;:&quot;world!&quot;&#125; 调用方法：1console.log(data.data1 + data.data2) 将json数据存入数组1var data=[&#123;&quot;name&quot;:&quot;LiLei&quot;,&quot;age&quot;:19,&quot;sex&quot;:&quot;male&quot;&#125;,&#123;&quot;name&quot;:&quot;HanMei&quot;,&quot;age&quot;:18,&quot;sex&quot;:&quot;famale&quot;&#125;] 调用方法：1console.log(data[0].name + &quot; is &quot; + data[0].sex) 总体而言，json是相对比较容易理解和使用的，但同时存在很多的陷阱，如果不注意的话很容易掉进去 JSON的的解析方法 json的解析方法共有两种：eval() 和 JSON.parse()，使用方法如下：123var data = &apos;&#123;&quot;data1&quot;:&quot;Hello,&quot;, &quot;data2&quot;:&quot;world!&quot;&#125;&apos;;var evalD=eval(&apos;(&apos;+data+&apos;)&apos;);var parseD=JSON.parse(data); 这样就把data这个json格式的字符串转换成了json对象。二者的区别如下：1234var value = 1;var txt = &apos;&#123;&quot;data1&quot;:&quot;hello&quot;,&quot;data2&quot;:++value&#125;&apos;;var data1 = eval(&apos;(&apos;+txt+&apos;)&apos;);console.log(value); 这时value值为212var data2=JSON.parse(txt);console.log(data2);//报错 可以从控制输出台的结果看到JSON.parse和eval的区别，第一个eval()顺利执行，第二个报错了从上例就可以明显地看出，eval在解析字符串时，会执行该字符串中的代码，如上例中，由于用eval解析一个json字符串而造成原先的value的值改变关于JSON.parse()和eval需要注意的是：在代码中使用eval是很危险的，特别是用它执行第三方的JSON数据（其中可能包含恶意代码）时，尽可能使用JSON.parse()方法解析字符串本身。该方法可以捕捉JSON中的语法错误，并允许你传入一个函数，用来过滤或转换解析结果","categories":[{"name":"JSON","slug":"JSON","permalink":"https://blog.luckyw.cn/categories/JSON/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://blog.luckyw.cn/tags/JSON/"}],"keywords":[{"name":"JSON","slug":"JSON","permalink":"https://blog.luckyw.cn/categories/JSON/"}]},{"title":"移动端必知的html5 head标签","slug":"html5-head","date":"2015-09-12T16:00:00.000Z","updated":"2016-10-26T11:17:38.017Z","comments":true,"path":"2015/09/13/html5-head/","link":"","permalink":"https://blog.luckyw.cn/2015/09/13/html5-head/","excerpt":"DOCTYPE DOCTYPE声明位于文档中最前面的位置，处于html标签之前，此标签告知浏览器文档应使用哪种HTML或者XHTML规范解析页面DTD声明以&lt;!DOCTYPE&gt;开始，不区分大小写，前面没有任何内容，如果有其他内容(空格除外)会使浏览器在IE下开启怪异模式渲染网页公共DTD，名称格式为注册//组织//类型 标签//语言 注册指组织是否由国际标准化组织ISO注册，+表示是，-表示不是组织即组织名称，如：W3C类型一般是DTD标签是指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号最后语言是DTD 语言的ISO 639语言标识符，如：EN表示英文，ZH表示中文 XHTML 1.0可声明三种DTD类型。分别表示严格版本、过渡版本、以及基于框架的HTML文档 HTML 4.01 strict 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML 4.01 Transitional 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML 4.01 Frameset 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; HTML5推出更加简洁的书写，它向前向后兼容，推荐使用 1&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;","text":"DOCTYPE DOCTYPE声明位于文档中最前面的位置，处于html标签之前，此标签告知浏览器文档应使用哪种HTML或者XHTML规范解析页面DTD声明以&lt;!DOCTYPE&gt;开始，不区分大小写，前面没有任何内容，如果有其他内容(空格除外)会使浏览器在IE下开启怪异模式渲染网页公共DTD，名称格式为注册//组织//类型 标签//语言 注册指组织是否由国际标准化组织ISO注册，+表示是，-表示不是组织即组织名称，如：W3C类型一般是DTD标签是指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号最后语言是DTD 语言的ISO 639语言标识符，如：EN表示英文，ZH表示中文 XHTML 1.0可声明三种DTD类型。分别表示严格版本、过渡版本、以及基于框架的HTML文档 HTML 4.01 strict 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML 4.01 Transitional 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML 4.01 Frameset 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; HTML5推出更加简洁的书写，它向前向后兼容，推荐使用 1&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt; 在HTML中doctype有两个主要目的: 对文档进行有效性验证它告诉用户代理和校验器这个文档是按照什么DTD写的。这个动作是被动的，每次页面加载时，浏览器并不会下载DTD并检查合法性，只有当手动校验页面时才启用 决定浏览器的呈现模式对于实际操作，通知浏览器读取文档时用哪种解析算法。如果没有写，则浏览器则根据自身的规则对代码进行解析，可能会严重影响html排版布局浏览器有三种方式解析HTML文档，非怪异(标准)模式-怪异模式-部分怪异（近乎标准）模式 charset 声明文档使用的字符编码1&lt;meta charset=&quot;utf-8&quot;&gt; lang属性 简体中文1&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 --&gt; 繁体中文1&lt;html lang=&quot;zh-cmn-Hant&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 --&gt; 优先使用 IE 最新版本和 Chrome 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; 360 使用Google Chrome Frame 1&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 360 浏览器就会在读取到这个标签后，立即切换对应的极速核。 另外为了保险起见再加入1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt; 这样写可以达到的效果是如果安装了 Google Chrome Frame，则使用 GCF 来渲染页面，如果没有安装 GCF，则使用最高版本的 IE 内核进行渲染 百度禁止转码 通过百度手机打开网页时，百度可能会对你的网页进行转码，脱下你的衣服，往你的身上贴狗皮膏药的广告，为此可在head内添加1&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt; SEO 优化 页面标题&lt;title&gt;标签 1&lt;title&gt;your title&lt;/title&gt; 页面关键词keywords 1&lt;meta name=&quot;keywords&quot; content=&quot;your keywords&quot;&gt; 页面描述内容description 1&lt;meta name=&quot;description&quot; content=&quot;your description&quot;&gt; 定义网页作者author 1&lt;meta name=&quot;author&quot; content=&quot;author,email address&quot;&gt; 定义网页搜索引擎索引方式robotterms是一组使用英文逗号分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow 1&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt; 为移动设备添加 viewport viewport可以让布局在移动浏览器上显示的更好。 通常会写1&lt;meta name =&quot;viewport&quot; content =&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt; width=device-width 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 (http://bigc.at/ios-webapp-viewport-meta.orz)content 参数： width 宽度 height 高度 initial-scale 初始缩放比例 maximum-scale 最大缩放比例 minimum-scale 最小缩放比例 user-scalable 是否允许用户缩放(yes/no) 而如果你的网站不是响应式的，请不要使用initial-scale或者禁用缩放。1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=yes&quot;&gt; 适配iPhone 6和iPhone 6plus则需要写：12&lt;meta name=&quot;viewport&quot; content=&quot;width=375&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=414&quot;&gt; 大部分4.7~5寸的安卓设备的viewport宽设为360px，iPhone 6上却是 375px，大部分5.5寸安卓机器（比如说三星 Note）的viewport宽为 400px，iPhone 6 plus上是414px ios 设备 添加到主屏后的标题（iOS 6 新增）1&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; 是否启用WebApp全屏模式1&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; 设置状态栏的背景颜色1&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt; 只有在 apple-mobile-web-app-capable content=&#39;yes&#39; 时生效content参数： default 默认值 black 状态栏背景是黑色 black-translucent 状态栏背景是黑色半透明。如果设置为default或black,网页内容从状态栏底部开始如果设置为black-translucent,网页内容充满整个屏幕，顶部会被状态栏遮挡 禁止数字自动识别为电话号码1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 禁止自动识别地址1&lt;meta name=&quot;format-detection&quot; content=&quot;address=no&quot;&gt; 禁止自动识别日期1&lt;meta name=&quot;format-detection&quot; content=&quot;date=no&quot;&gt; 禁止自动识别Email1&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt; favicon icon 1&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;!-- 添加 favicon icon --&gt; 关闭chrome浏览器下翻译插件 有些时候感觉chrome浏览器下翻译插件很烦人，可以通过下面的代码禁用它1&lt;meta name=&quot;google&quot; value=&quot;notranslate&quot; /&gt; 移动端的头部标签和meta12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta charset=&apos;utf-8&apos;&gt; &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; &lt;!-- 页面描述 --&gt; &lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt; &lt;!-- 网页作者 --&gt; &lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; &lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt; &lt;!-- 添加 RSS 订阅 --&gt; &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt; &lt;!-- 添加 favicon icon --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt; 参考文章： 常用的 HTML 头部标签 amazeui css WEB 工程师和设计师必学的 10 个 IOS 8 新鲜改变","categories":[{"name":"Html5","slug":"Html5","permalink":"https://blog.luckyw.cn/categories/Html5/"}],"tags":[{"name":"Html5","slug":"Html5","permalink":"https://blog.luckyw.cn/tags/Html5/"}],"keywords":[{"name":"Html5","slug":"Html5","permalink":"https://blog.luckyw.cn/categories/Html5/"}]},{"title":"hexo配置sitemap以及设置keywords","slug":"hexo-sitemap-keywords","date":"2015-09-07T16:00:00.000Z","updated":"2016-10-26T11:17:22.853Z","comments":true,"path":"2015/09/08/hexo-sitemap-keywords/","link":"","permalink":"https://blog.luckyw.cn/2015/09/08/hexo-sitemap-keywords/","excerpt":"本文主要是对hexo搭建的博客进行简单的SEO，比如给每篇文章加上keywords，以及生成sitemap.xml文件，方便我们提交到各大搜索引擎 hexo安装sitemap windows用户可以在博客根目录下按shift键不放再鼠标右击，即可在此目录下运行CMD窗口，运行如下代码:1npm install hexo-generator-sitemap --save 在博客根目录下找到_config.yml文件，添加如下代码:12sitemap:path: sitemap.xml 执行hexo g生成静态页面，再然后执行hexo s启动服务打开 http://localhost:4000/sitemap.xml 即可看到效果，弄好之后你就可以到各大搜索引擎提交sitemap站点地图了","text":"本文主要是对hexo搭建的博客进行简单的SEO，比如给每篇文章加上keywords，以及生成sitemap.xml文件，方便我们提交到各大搜索引擎 hexo安装sitemap windows用户可以在博客根目录下按shift键不放再鼠标右击，即可在此目录下运行CMD窗口，运行如下代码:1npm install hexo-generator-sitemap --save 在博客根目录下找到_config.yml文件，添加如下代码:12sitemap:path: sitemap.xml 执行hexo g生成静态页面，再然后执行hexo s启动服务打开 http://localhost:4000/sitemap.xml 即可看到效果，弄好之后你就可以到各大搜索引擎提交sitemap站点地图了 keywords 默认情况下hexo博客及博客里的文章是没有keywords关键字的，需要我们手动添加设置hexo博客的关键字:在博客根目录下找到_config.yml文件，在所示地方添加keywords: 关键字1,关键字2,关键字3…，采用英文逗号隔开，注意keywords与关键词之间的空格12345678# Sitetitle: 站点标题subtitle: 站点副标题description: 站点描述author: 站点作者language: zh-CNtimezone:keywords: 前端博客,JavaScript,html5,css3,Jquery,NodeJs,Ubuntu（#博客关键字） 设置文章的关键字 打开theme/icarus/layout/common/head.ejs，这是我的head.ejs所在路径，不同主题可能不同，但一般来说都是head.ejs文件，添加如下代码: 12345&lt;% if (page.keywords)&#123; %&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= page.keywords %&gt;,&lt;%= config.keywords %&gt;&quot;&gt;&lt;% &#125; else if (config.keywords)&#123; %&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= config.keywords %&gt;&quot;&gt;&lt;%&#125; %&gt; 这段话的意思是如果页面有关键字，则用页面的关键字，否则使用配置文件的关键字 在文章里面加入keywords，如下所示：1234567---title: ###date: ###categories: ###tags: ###keywords: ###---","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/categories/Hexo/"}]},{"title":"github上搭建hexo博客","slug":"github-hexo","date":"2015-09-04T16:00:00.000Z","updated":"2016-11-20T10:50:01.381Z","comments":true,"path":"2015/09/05/github-hexo/","link":"","permalink":"https://blog.luckyw.cn/2015/09/05/github-hexo/","excerpt":"环境安装 安装GitGit:主要用于上传博客页面到github和命令操作安装NodeNode.js:Hexo的运行环境安装HexoHexo:博客程序打开安装Git后的生成的右键菜单Git Bash，输入如下代码安装Hexo:1npm install -g hexo-cli 等待安装完成即可","text":"环境安装 安装GitGit:主要用于上传博客页面到github和命令操作安装NodeNode.js:Hexo的运行环境安装HexoHexo:博客程序打开安装Git后的生成的右键菜单Git Bash，输入如下代码安装Hexo:1npm install -g hexo-cli 等待安装完成即可 生成本地博客 首先切换到你需要创建博客的文件目录，鼠标右击空白处打开git bash，输入如下代码生成一个本地博客：1hexo init myblog 创建好之后输入代码切换到博客文件夹目录并使用npm包管理工具安装hexo所需的依赖模块1cd myblog &amp;&amp; npm install 继续输入：1npm install hexo-deployer-git --save 这是用于将hexo本地博客上传到github页面上必需的模块最后再输入1npm install hexo-server --save 安装hexo服务器模块，用于本地预览博客到这里就基本在本地完成博客的搭建了。可以输入如下命令来看下hexo博客的初始效果：1hexo s 这条命令是hexo server的简写形式，启动一个本地服务器，不要关闭当前git bash窗口，打开浏览器，输入网址http://localhost:4000进行访问。有一篇Hello World博文，效果图如下： 将本地博客上传到github 创建需要将博客存放在github上的仓库，我们需要一个github账户，如果没有请注册,然后点击New repository创建仓库，Repository Name按如下格式填写：1yourname.github.io 注：yourname填写你的账户名点击Create repository即可修改_config.yml文件找到_config.yml文件，用记事本打开(Nodepad++或sublime等文本编辑器都可)，鼠标拉到最下面，修改成：123deploy: type: git repo: https://github.com/yourname/yourname.github.io.git 注：两处yourname都需要填写你的账户名 部署本地博客到github 首先输入如下命令生成静态页面1hexo g 这条命令是代码hexo generator的缩写，生成好之后，继续输入1hexo d 这条命令是代码hexo deploy的缩写，用于将生成的静态文件上传到github，等待完成之后在浏览器输入yourname.github.io就可以看到你的博客页面了注：首次使用git会询问github的账号信息，填写你对应的账户信息即可推荐主题：next,里面有详细的next主题使用方法，在此我就不赘述了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/categories/Hexo/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://blog.luckyw.cn/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/categories/Hexo/"}]},{"title":"开始我的Hexo博客","slug":"welcome","date":"2015-08-31T16:00:00.000Z","updated":"2016-10-26T11:25:40.949Z","comments":true,"path":"2015/09/01/welcome/","link":"","permalink":"https://blog.luckyw.cn/2015/09/01/welcome/","excerpt":"","text":"测试页Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ab commodi cumque doloremque exercitationem inventore ipsum placeat suscipit, ut. Dolor enim nobis reprehenderit sint. Aut consequatur dolore labore neque sed suscipit.Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ab commodi cumque doloremque exercitationem inventore ipsum placeat suscipit, ut. Dolor enim nobis reprehenderit sint. Aut consequatur dolore labore neque sed suscipit.Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ab commodi cumque doloremque exercitationem inventore ipsum placeat suscipit, ut. Dolor enim nobis reprehenderit sint. Aut consequatur dolore labore neque sed suscipit.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.luckyw.cn/categories/Hexo/"}]}]}